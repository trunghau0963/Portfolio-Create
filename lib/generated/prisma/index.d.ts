
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Section
 * 
 */
export type Section = $Result.DefaultSelection<Prisma.$SectionPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Setting
 * 
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>
/**
 * Model TextBlock
 * 
 */
export type TextBlock = $Result.DefaultSelection<Prisma.$TextBlockPayload>
/**
 * Model ImageBlock
 * 
 */
export type ImageBlock = $Result.DefaultSelection<Prisma.$ImageBlockPayload>
/**
 * Model HeroSectionContent
 * 
 */
export type HeroSectionContent = $Result.DefaultSelection<Prisma.$HeroSectionContentPayload>
/**
 * Model EducationItem
 * 
 */
export type EducationItem = $Result.DefaultSelection<Prisma.$EducationItemPayload>
/**
 * Model EducationImage
 * 
 */
export type EducationImage = $Result.DefaultSelection<Prisma.$EducationImagePayload>
/**
 * Model SkillItem
 * 
 */
export type SkillItem = $Result.DefaultSelection<Prisma.$SkillItemPayload>
/**
 * Model SkillImage
 * 
 */
export type SkillImage = $Result.DefaultSelection<Prisma.$SkillImagePayload>
/**
 * Model ExperienceItem
 * 
 */
export type ExperienceItem = $Result.DefaultSelection<Prisma.$ExperienceItemPayload>
/**
 * Model ExperienceDetailImage
 * 
 */
export type ExperienceDetailImage = $Result.DefaultSelection<Prisma.$ExperienceDetailImagePayload>
/**
 * Model ProjectItem
 * 
 */
export type ProjectItem = $Result.DefaultSelection<Prisma.$ProjectItemPayload>
/**
 * Model TestimonialItem
 * 
 */
export type TestimonialItem = $Result.DefaultSelection<Prisma.$TestimonialItemPayload>
/**
 * Model ContactInfoItem
 * 
 */
export type ContactInfoItem = $Result.DefaultSelection<Prisma.$ContactInfoItemPayload>
/**
 * Model CustomSectionContentBlock
 * 
 */
export type CustomSectionContentBlock = $Result.DefaultSelection<Prisma.$CustomSectionContentBlockPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.section`: Exposes CRUD operations for the **Section** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sections
    * const sections = await prisma.section.findMany()
    * ```
    */
  get section(): Prisma.SectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.SettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.textBlock`: Exposes CRUD operations for the **TextBlock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TextBlocks
    * const textBlocks = await prisma.textBlock.findMany()
    * ```
    */
  get textBlock(): Prisma.TextBlockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.imageBlock`: Exposes CRUD operations for the **ImageBlock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImageBlocks
    * const imageBlocks = await prisma.imageBlock.findMany()
    * ```
    */
  get imageBlock(): Prisma.ImageBlockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.heroSectionContent`: Exposes CRUD operations for the **HeroSectionContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HeroSectionContents
    * const heroSectionContents = await prisma.heroSectionContent.findMany()
    * ```
    */
  get heroSectionContent(): Prisma.HeroSectionContentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.educationItem`: Exposes CRUD operations for the **EducationItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EducationItems
    * const educationItems = await prisma.educationItem.findMany()
    * ```
    */
  get educationItem(): Prisma.EducationItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.educationImage`: Exposes CRUD operations for the **EducationImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EducationImages
    * const educationImages = await prisma.educationImage.findMany()
    * ```
    */
  get educationImage(): Prisma.EducationImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skillItem`: Exposes CRUD operations for the **SkillItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkillItems
    * const skillItems = await prisma.skillItem.findMany()
    * ```
    */
  get skillItem(): Prisma.SkillItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skillImage`: Exposes CRUD operations for the **SkillImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkillImages
    * const skillImages = await prisma.skillImage.findMany()
    * ```
    */
  get skillImage(): Prisma.SkillImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.experienceItem`: Exposes CRUD operations for the **ExperienceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExperienceItems
    * const experienceItems = await prisma.experienceItem.findMany()
    * ```
    */
  get experienceItem(): Prisma.ExperienceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.experienceDetailImage`: Exposes CRUD operations for the **ExperienceDetailImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExperienceDetailImages
    * const experienceDetailImages = await prisma.experienceDetailImage.findMany()
    * ```
    */
  get experienceDetailImage(): Prisma.ExperienceDetailImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectItem`: Exposes CRUD operations for the **ProjectItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectItems
    * const projectItems = await prisma.projectItem.findMany()
    * ```
    */
  get projectItem(): Prisma.ProjectItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testimonialItem`: Exposes CRUD operations for the **TestimonialItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestimonialItems
    * const testimonialItems = await prisma.testimonialItem.findMany()
    * ```
    */
  get testimonialItem(): Prisma.TestimonialItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactInfoItem`: Exposes CRUD operations for the **ContactInfoItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactInfoItems
    * const contactInfoItems = await prisma.contactInfoItem.findMany()
    * ```
    */
  get contactInfoItem(): Prisma.ContactInfoItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customSectionContentBlock`: Exposes CRUD operations for the **CustomSectionContentBlock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomSectionContentBlocks
    * const customSectionContentBlocks = await prisma.customSectionContentBlock.findMany()
    * ```
    */
  get customSectionContentBlock(): Prisma.CustomSectionContentBlockDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Section: 'Section',
    Category: 'Category',
    Setting: 'Setting',
    TextBlock: 'TextBlock',
    ImageBlock: 'ImageBlock',
    HeroSectionContent: 'HeroSectionContent',
    EducationItem: 'EducationItem',
    EducationImage: 'EducationImage',
    SkillItem: 'SkillItem',
    SkillImage: 'SkillImage',
    ExperienceItem: 'ExperienceItem',
    ExperienceDetailImage: 'ExperienceDetailImage',
    ProjectItem: 'ProjectItem',
    TestimonialItem: 'TestimonialItem',
    ContactInfoItem: 'ContactInfoItem',
    CustomSectionContentBlock: 'CustomSectionContentBlock'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "section" | "category" | "setting" | "textBlock" | "imageBlock" | "heroSectionContent" | "educationItem" | "educationImage" | "skillItem" | "skillImage" | "experienceItem" | "experienceDetailImage" | "projectItem" | "testimonialItem" | "contactInfoItem" | "customSectionContentBlock"
      txIsolationLevel: never
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Section: {
        payload: Prisma.$SectionPayload<ExtArgs>
        fields: Prisma.SectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findFirst: {
            args: Prisma.SectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findMany: {
            args: Prisma.SectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          create: {
            args: Prisma.SectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          createMany: {
            args: Prisma.SectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          update: {
            args: Prisma.SectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          deleteMany: {
            args: Prisma.SectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          aggregate: {
            args: Prisma.SectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSection>
          }
          groupBy: {
            args: Prisma.SectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SectionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SectionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SectionCountArgs<ExtArgs>
            result: $Utils.Optional<SectionCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CategoryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CategoryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>
        fields: Prisma.SettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SettingFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SettingAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      TextBlock: {
        payload: Prisma.$TextBlockPayload<ExtArgs>
        fields: Prisma.TextBlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TextBlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextBlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TextBlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextBlockPayload>
          }
          findFirst: {
            args: Prisma.TextBlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextBlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TextBlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextBlockPayload>
          }
          findMany: {
            args: Prisma.TextBlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextBlockPayload>[]
          }
          create: {
            args: Prisma.TextBlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextBlockPayload>
          }
          createMany: {
            args: Prisma.TextBlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TextBlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextBlockPayload>
          }
          update: {
            args: Prisma.TextBlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextBlockPayload>
          }
          deleteMany: {
            args: Prisma.TextBlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TextBlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TextBlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextBlockPayload>
          }
          aggregate: {
            args: Prisma.TextBlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTextBlock>
          }
          groupBy: {
            args: Prisma.TextBlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<TextBlockGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TextBlockFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TextBlockAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TextBlockCountArgs<ExtArgs>
            result: $Utils.Optional<TextBlockCountAggregateOutputType> | number
          }
        }
      }
      ImageBlock: {
        payload: Prisma.$ImageBlockPayload<ExtArgs>
        fields: Prisma.ImageBlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImageBlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageBlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImageBlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageBlockPayload>
          }
          findFirst: {
            args: Prisma.ImageBlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageBlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImageBlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageBlockPayload>
          }
          findMany: {
            args: Prisma.ImageBlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageBlockPayload>[]
          }
          create: {
            args: Prisma.ImageBlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageBlockPayload>
          }
          createMany: {
            args: Prisma.ImageBlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ImageBlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageBlockPayload>
          }
          update: {
            args: Prisma.ImageBlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageBlockPayload>
          }
          deleteMany: {
            args: Prisma.ImageBlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImageBlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImageBlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageBlockPayload>
          }
          aggregate: {
            args: Prisma.ImageBlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImageBlock>
          }
          groupBy: {
            args: Prisma.ImageBlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImageBlockGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ImageBlockFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ImageBlockAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ImageBlockCountArgs<ExtArgs>
            result: $Utils.Optional<ImageBlockCountAggregateOutputType> | number
          }
        }
      }
      HeroSectionContent: {
        payload: Prisma.$HeroSectionContentPayload<ExtArgs>
        fields: Prisma.HeroSectionContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HeroSectionContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSectionContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HeroSectionContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSectionContentPayload>
          }
          findFirst: {
            args: Prisma.HeroSectionContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSectionContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HeroSectionContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSectionContentPayload>
          }
          findMany: {
            args: Prisma.HeroSectionContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSectionContentPayload>[]
          }
          create: {
            args: Prisma.HeroSectionContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSectionContentPayload>
          }
          createMany: {
            args: Prisma.HeroSectionContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HeroSectionContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSectionContentPayload>
          }
          update: {
            args: Prisma.HeroSectionContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSectionContentPayload>
          }
          deleteMany: {
            args: Prisma.HeroSectionContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HeroSectionContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HeroSectionContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSectionContentPayload>
          }
          aggregate: {
            args: Prisma.HeroSectionContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHeroSectionContent>
          }
          groupBy: {
            args: Prisma.HeroSectionContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<HeroSectionContentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.HeroSectionContentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.HeroSectionContentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.HeroSectionContentCountArgs<ExtArgs>
            result: $Utils.Optional<HeroSectionContentCountAggregateOutputType> | number
          }
        }
      }
      EducationItem: {
        payload: Prisma.$EducationItemPayload<ExtArgs>
        fields: Prisma.EducationItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EducationItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EducationItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationItemPayload>
          }
          findFirst: {
            args: Prisma.EducationItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EducationItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationItemPayload>
          }
          findMany: {
            args: Prisma.EducationItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationItemPayload>[]
          }
          create: {
            args: Prisma.EducationItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationItemPayload>
          }
          createMany: {
            args: Prisma.EducationItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EducationItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationItemPayload>
          }
          update: {
            args: Prisma.EducationItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationItemPayload>
          }
          deleteMany: {
            args: Prisma.EducationItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EducationItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EducationItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationItemPayload>
          }
          aggregate: {
            args: Prisma.EducationItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEducationItem>
          }
          groupBy: {
            args: Prisma.EducationItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<EducationItemGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EducationItemFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.EducationItemAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.EducationItemCountArgs<ExtArgs>
            result: $Utils.Optional<EducationItemCountAggregateOutputType> | number
          }
        }
      }
      EducationImage: {
        payload: Prisma.$EducationImagePayload<ExtArgs>
        fields: Prisma.EducationImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EducationImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EducationImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationImagePayload>
          }
          findFirst: {
            args: Prisma.EducationImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EducationImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationImagePayload>
          }
          findMany: {
            args: Prisma.EducationImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationImagePayload>[]
          }
          create: {
            args: Prisma.EducationImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationImagePayload>
          }
          createMany: {
            args: Prisma.EducationImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EducationImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationImagePayload>
          }
          update: {
            args: Prisma.EducationImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationImagePayload>
          }
          deleteMany: {
            args: Prisma.EducationImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EducationImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EducationImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationImagePayload>
          }
          aggregate: {
            args: Prisma.EducationImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEducationImage>
          }
          groupBy: {
            args: Prisma.EducationImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<EducationImageGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EducationImageFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.EducationImageAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.EducationImageCountArgs<ExtArgs>
            result: $Utils.Optional<EducationImageCountAggregateOutputType> | number
          }
        }
      }
      SkillItem: {
        payload: Prisma.$SkillItemPayload<ExtArgs>
        fields: Prisma.SkillItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillItemPayload>
          }
          findFirst: {
            args: Prisma.SkillItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillItemPayload>
          }
          findMany: {
            args: Prisma.SkillItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillItemPayload>[]
          }
          create: {
            args: Prisma.SkillItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillItemPayload>
          }
          createMany: {
            args: Prisma.SkillItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SkillItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillItemPayload>
          }
          update: {
            args: Prisma.SkillItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillItemPayload>
          }
          deleteMany: {
            args: Prisma.SkillItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkillItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillItemPayload>
          }
          aggregate: {
            args: Prisma.SkillItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkillItem>
          }
          groupBy: {
            args: Prisma.SkillItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillItemGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SkillItemFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SkillItemAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SkillItemCountArgs<ExtArgs>
            result: $Utils.Optional<SkillItemCountAggregateOutputType> | number
          }
        }
      }
      SkillImage: {
        payload: Prisma.$SkillImagePayload<ExtArgs>
        fields: Prisma.SkillImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillImagePayload>
          }
          findFirst: {
            args: Prisma.SkillImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillImagePayload>
          }
          findMany: {
            args: Prisma.SkillImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillImagePayload>[]
          }
          create: {
            args: Prisma.SkillImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillImagePayload>
          }
          createMany: {
            args: Prisma.SkillImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SkillImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillImagePayload>
          }
          update: {
            args: Prisma.SkillImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillImagePayload>
          }
          deleteMany: {
            args: Prisma.SkillImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkillImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillImagePayload>
          }
          aggregate: {
            args: Prisma.SkillImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkillImage>
          }
          groupBy: {
            args: Prisma.SkillImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillImageGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SkillImageFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SkillImageAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SkillImageCountArgs<ExtArgs>
            result: $Utils.Optional<SkillImageCountAggregateOutputType> | number
          }
        }
      }
      ExperienceItem: {
        payload: Prisma.$ExperienceItemPayload<ExtArgs>
        fields: Prisma.ExperienceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExperienceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExperienceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceItemPayload>
          }
          findFirst: {
            args: Prisma.ExperienceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExperienceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceItemPayload>
          }
          findMany: {
            args: Prisma.ExperienceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceItemPayload>[]
          }
          create: {
            args: Prisma.ExperienceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceItemPayload>
          }
          createMany: {
            args: Prisma.ExperienceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExperienceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceItemPayload>
          }
          update: {
            args: Prisma.ExperienceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceItemPayload>
          }
          deleteMany: {
            args: Prisma.ExperienceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExperienceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExperienceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceItemPayload>
          }
          aggregate: {
            args: Prisma.ExperienceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExperienceItem>
          }
          groupBy: {
            args: Prisma.ExperienceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExperienceItemGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ExperienceItemFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ExperienceItemAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ExperienceItemCountArgs<ExtArgs>
            result: $Utils.Optional<ExperienceItemCountAggregateOutputType> | number
          }
        }
      }
      ExperienceDetailImage: {
        payload: Prisma.$ExperienceDetailImagePayload<ExtArgs>
        fields: Prisma.ExperienceDetailImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExperienceDetailImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceDetailImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExperienceDetailImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceDetailImagePayload>
          }
          findFirst: {
            args: Prisma.ExperienceDetailImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceDetailImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExperienceDetailImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceDetailImagePayload>
          }
          findMany: {
            args: Prisma.ExperienceDetailImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceDetailImagePayload>[]
          }
          create: {
            args: Prisma.ExperienceDetailImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceDetailImagePayload>
          }
          createMany: {
            args: Prisma.ExperienceDetailImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExperienceDetailImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceDetailImagePayload>
          }
          update: {
            args: Prisma.ExperienceDetailImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceDetailImagePayload>
          }
          deleteMany: {
            args: Prisma.ExperienceDetailImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExperienceDetailImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExperienceDetailImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperienceDetailImagePayload>
          }
          aggregate: {
            args: Prisma.ExperienceDetailImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExperienceDetailImage>
          }
          groupBy: {
            args: Prisma.ExperienceDetailImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExperienceDetailImageGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ExperienceDetailImageFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ExperienceDetailImageAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ExperienceDetailImageCountArgs<ExtArgs>
            result: $Utils.Optional<ExperienceDetailImageCountAggregateOutputType> | number
          }
        }
      }
      ProjectItem: {
        payload: Prisma.$ProjectItemPayload<ExtArgs>
        fields: Prisma.ProjectItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectItemPayload>
          }
          findFirst: {
            args: Prisma.ProjectItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectItemPayload>
          }
          findMany: {
            args: Prisma.ProjectItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectItemPayload>[]
          }
          create: {
            args: Prisma.ProjectItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectItemPayload>
          }
          createMany: {
            args: Prisma.ProjectItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectItemPayload>
          }
          update: {
            args: Prisma.ProjectItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectItemPayload>
          }
          deleteMany: {
            args: Prisma.ProjectItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectItemPayload>
          }
          aggregate: {
            args: Prisma.ProjectItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectItem>
          }
          groupBy: {
            args: Prisma.ProjectItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectItemGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ProjectItemFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ProjectItemAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ProjectItemCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectItemCountAggregateOutputType> | number
          }
        }
      }
      TestimonialItem: {
        payload: Prisma.$TestimonialItemPayload<ExtArgs>
        fields: Prisma.TestimonialItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestimonialItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestimonialItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialItemPayload>
          }
          findFirst: {
            args: Prisma.TestimonialItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestimonialItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialItemPayload>
          }
          findMany: {
            args: Prisma.TestimonialItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialItemPayload>[]
          }
          create: {
            args: Prisma.TestimonialItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialItemPayload>
          }
          createMany: {
            args: Prisma.TestimonialItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TestimonialItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialItemPayload>
          }
          update: {
            args: Prisma.TestimonialItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialItemPayload>
          }
          deleteMany: {
            args: Prisma.TestimonialItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestimonialItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestimonialItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialItemPayload>
          }
          aggregate: {
            args: Prisma.TestimonialItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestimonialItem>
          }
          groupBy: {
            args: Prisma.TestimonialItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestimonialItemGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TestimonialItemFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TestimonialItemAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TestimonialItemCountArgs<ExtArgs>
            result: $Utils.Optional<TestimonialItemCountAggregateOutputType> | number
          }
        }
      }
      ContactInfoItem: {
        payload: Prisma.$ContactInfoItemPayload<ExtArgs>
        fields: Prisma.ContactInfoItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactInfoItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactInfoItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoItemPayload>
          }
          findFirst: {
            args: Prisma.ContactInfoItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactInfoItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoItemPayload>
          }
          findMany: {
            args: Prisma.ContactInfoItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoItemPayload>[]
          }
          create: {
            args: Prisma.ContactInfoItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoItemPayload>
          }
          createMany: {
            args: Prisma.ContactInfoItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactInfoItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoItemPayload>
          }
          update: {
            args: Prisma.ContactInfoItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoItemPayload>
          }
          deleteMany: {
            args: Prisma.ContactInfoItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactInfoItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactInfoItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoItemPayload>
          }
          aggregate: {
            args: Prisma.ContactInfoItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactInfoItem>
          }
          groupBy: {
            args: Prisma.ContactInfoItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactInfoItemGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ContactInfoItemFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ContactInfoItemAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ContactInfoItemCountArgs<ExtArgs>
            result: $Utils.Optional<ContactInfoItemCountAggregateOutputType> | number
          }
        }
      }
      CustomSectionContentBlock: {
        payload: Prisma.$CustomSectionContentBlockPayload<ExtArgs>
        fields: Prisma.CustomSectionContentBlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomSectionContentBlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomSectionContentBlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomSectionContentBlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomSectionContentBlockPayload>
          }
          findFirst: {
            args: Prisma.CustomSectionContentBlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomSectionContentBlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomSectionContentBlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomSectionContentBlockPayload>
          }
          findMany: {
            args: Prisma.CustomSectionContentBlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomSectionContentBlockPayload>[]
          }
          create: {
            args: Prisma.CustomSectionContentBlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomSectionContentBlockPayload>
          }
          createMany: {
            args: Prisma.CustomSectionContentBlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomSectionContentBlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomSectionContentBlockPayload>
          }
          update: {
            args: Prisma.CustomSectionContentBlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomSectionContentBlockPayload>
          }
          deleteMany: {
            args: Prisma.CustomSectionContentBlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomSectionContentBlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomSectionContentBlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomSectionContentBlockPayload>
          }
          aggregate: {
            args: Prisma.CustomSectionContentBlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomSectionContentBlock>
          }
          groupBy: {
            args: Prisma.CustomSectionContentBlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomSectionContentBlockGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CustomSectionContentBlockFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CustomSectionContentBlockAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CustomSectionContentBlockCountArgs<ExtArgs>
            result: $Utils.Optional<CustomSectionContentBlockCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    section?: SectionOmit
    category?: CategoryOmit
    setting?: SettingOmit
    textBlock?: TextBlockOmit
    imageBlock?: ImageBlockOmit
    heroSectionContent?: HeroSectionContentOmit
    educationItem?: EducationItemOmit
    educationImage?: EducationImageOmit
    skillItem?: SkillItemOmit
    skillImage?: SkillImageOmit
    experienceItem?: ExperienceItemOmit
    experienceDetailImage?: ExperienceDetailImageOmit
    projectItem?: ProjectItemOmit
    testimonialItem?: TestimonialItemOmit
    contactInfoItem?: ContactInfoItemOmit
    customSectionContentBlock?: CustomSectionContentBlockOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SectionCountOutputType
   */

  export type SectionCountOutputType = {
    textBlocks: number
    imageBlocks: number
    educationItems: number
    skillItems: number
    skillImages: number
    experienceItems: number
    projectItems: number
    testimonialItems: number
    contactInfoItems: number
    customSectionContentBlocks: number
  }

  export type SectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    textBlocks?: boolean | SectionCountOutputTypeCountTextBlocksArgs
    imageBlocks?: boolean | SectionCountOutputTypeCountImageBlocksArgs
    educationItems?: boolean | SectionCountOutputTypeCountEducationItemsArgs
    skillItems?: boolean | SectionCountOutputTypeCountSkillItemsArgs
    skillImages?: boolean | SectionCountOutputTypeCountSkillImagesArgs
    experienceItems?: boolean | SectionCountOutputTypeCountExperienceItemsArgs
    projectItems?: boolean | SectionCountOutputTypeCountProjectItemsArgs
    testimonialItems?: boolean | SectionCountOutputTypeCountTestimonialItemsArgs
    contactInfoItems?: boolean | SectionCountOutputTypeCountContactInfoItemsArgs
    customSectionContentBlocks?: boolean | SectionCountOutputTypeCountCustomSectionContentBlocksArgs
  }

  // Custom InputTypes
  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionCountOutputType
     */
    select?: SectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountTextBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TextBlockWhereInput
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountImageBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageBlockWhereInput
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountEducationItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationItemWhereInput
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountSkillItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillItemWhereInput
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountSkillImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillImageWhereInput
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountExperienceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExperienceItemWhereInput
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountProjectItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectItemWhereInput
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountTestimonialItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestimonialItemWhereInput
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountContactInfoItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactInfoItemWhereInput
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountCustomSectionContentBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomSectionContentBlockWhereInput
  }


  /**
   * Count Type EducationItemCountOutputType
   */

  export type EducationItemCountOutputType = {
    images: number
  }

  export type EducationItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | EducationItemCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * EducationItemCountOutputType without action
   */
  export type EducationItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationItemCountOutputType
     */
    select?: EducationItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EducationItemCountOutputType without action
   */
  export type EducationItemCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationImageWhereInput
  }


  /**
   * Count Type ExperienceItemCountOutputType
   */

  export type ExperienceItemCountOutputType = {
    detailImages: number
  }

  export type ExperienceItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detailImages?: boolean | ExperienceItemCountOutputTypeCountDetailImagesArgs
  }

  // Custom InputTypes
  /**
   * ExperienceItemCountOutputType without action
   */
  export type ExperienceItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceItemCountOutputType
     */
    select?: ExperienceItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExperienceItemCountOutputType without action
   */
  export type ExperienceItemCountOutputTypeCountDetailImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExperienceDetailImageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    isAdmin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    isAdmin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    isAdmin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    isAdmin: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    isAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    isAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "isAdmin" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      isAdmin: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly isAdmin: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
  }


  /**
   * Model Section
   */

  export type AggregateSection = {
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  export type SectionAvgAggregateOutputType = {
    order: number | null
  }

  export type SectionSumAggregateOutputType = {
    order: number | null
  }

  export type SectionMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    type: string | null
    visible: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectionMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    type: string | null
    visible: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectionCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    type: number
    visible: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SectionAvgAggregateInputType = {
    order?: true
  }

  export type SectionSumAggregateInputType = {
    order?: true
  }

  export type SectionMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    type?: true
    visible?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectionMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    type?: true
    visible?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectionCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    type?: true
    visible?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Section to aggregate.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sections
    **/
    _count?: true | SectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectionMaxAggregateInputType
  }

  export type GetSectionAggregateType<T extends SectionAggregateArgs> = {
        [P in keyof T & keyof AggregateSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSection[P]>
      : GetScalarType<T[P], AggregateSection[P]>
  }




  export type SectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithAggregationInput | SectionOrderByWithAggregationInput[]
    by: SectionScalarFieldEnum[] | SectionScalarFieldEnum
    having?: SectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectionCountAggregateInputType | true
    _avg?: SectionAvgAggregateInputType
    _sum?: SectionSumAggregateInputType
    _min?: SectionMinAggregateInputType
    _max?: SectionMaxAggregateInputType
  }

  export type SectionGroupByOutputType = {
    id: string
    slug: string
    title: string
    type: string
    visible: boolean
    order: number
    createdAt: Date
    updatedAt: Date
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  type GetSectionGroupByPayload<T extends SectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectionGroupByOutputType[P]>
            : GetScalarType<T[P], SectionGroupByOutputType[P]>
        }
      >
    >


  export type SectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    type?: boolean
    visible?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    textBlocks?: boolean | Section$textBlocksArgs<ExtArgs>
    imageBlocks?: boolean | Section$imageBlocksArgs<ExtArgs>
    heroContent?: boolean | Section$heroContentArgs<ExtArgs>
    educationItems?: boolean | Section$educationItemsArgs<ExtArgs>
    skillItems?: boolean | Section$skillItemsArgs<ExtArgs>
    skillImages?: boolean | Section$skillImagesArgs<ExtArgs>
    experienceItems?: boolean | Section$experienceItemsArgs<ExtArgs>
    projectItems?: boolean | Section$projectItemsArgs<ExtArgs>
    testimonialItems?: boolean | Section$testimonialItemsArgs<ExtArgs>
    contactInfoItems?: boolean | Section$contactInfoItemsArgs<ExtArgs>
    customSectionContentBlocks?: boolean | Section$customSectionContentBlocksArgs<ExtArgs>
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>



  export type SectionSelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    type?: boolean
    visible?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "title" | "type" | "visible" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["section"]>
  export type SectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    textBlocks?: boolean | Section$textBlocksArgs<ExtArgs>
    imageBlocks?: boolean | Section$imageBlocksArgs<ExtArgs>
    heroContent?: boolean | Section$heroContentArgs<ExtArgs>
    educationItems?: boolean | Section$educationItemsArgs<ExtArgs>
    skillItems?: boolean | Section$skillItemsArgs<ExtArgs>
    skillImages?: boolean | Section$skillImagesArgs<ExtArgs>
    experienceItems?: boolean | Section$experienceItemsArgs<ExtArgs>
    projectItems?: boolean | Section$projectItemsArgs<ExtArgs>
    testimonialItems?: boolean | Section$testimonialItemsArgs<ExtArgs>
    contactInfoItems?: boolean | Section$contactInfoItemsArgs<ExtArgs>
    customSectionContentBlocks?: boolean | Section$customSectionContentBlocksArgs<ExtArgs>
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Section"
    objects: {
      textBlocks: Prisma.$TextBlockPayload<ExtArgs>[]
      imageBlocks: Prisma.$ImageBlockPayload<ExtArgs>[]
      heroContent: Prisma.$HeroSectionContentPayload<ExtArgs> | null
      educationItems: Prisma.$EducationItemPayload<ExtArgs>[]
      skillItems: Prisma.$SkillItemPayload<ExtArgs>[]
      skillImages: Prisma.$SkillImagePayload<ExtArgs>[]
      experienceItems: Prisma.$ExperienceItemPayload<ExtArgs>[]
      projectItems: Prisma.$ProjectItemPayload<ExtArgs>[]
      testimonialItems: Prisma.$TestimonialItemPayload<ExtArgs>[]
      contactInfoItems: Prisma.$ContactInfoItemPayload<ExtArgs>[]
      customSectionContentBlocks: Prisma.$CustomSectionContentBlockPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      title: string
      type: string
      visible: boolean
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["section"]>
    composites: {}
  }

  type SectionGetPayload<S extends boolean | null | undefined | SectionDefaultArgs> = $Result.GetResult<Prisma.$SectionPayload, S>

  type SectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SectionCountAggregateInputType | true
    }

  export interface SectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Section'], meta: { name: 'Section' } }
    /**
     * Find zero or one Section that matches the filter.
     * @param {SectionFindUniqueArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectionFindUniqueArgs>(args: SelectSubset<T, SectionFindUniqueArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Section that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SectionFindUniqueOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectionFindUniqueOrThrowArgs>(args: SelectSubset<T, SectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Section that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectionFindFirstArgs>(args?: SelectSubset<T, SectionFindFirstArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Section that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectionFindFirstOrThrowArgs>(args?: SelectSubset<T, SectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sections
     * const sections = await prisma.section.findMany()
     * 
     * // Get first 10 Sections
     * const sections = await prisma.section.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectionWithIdOnly = await prisma.section.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SectionFindManyArgs>(args?: SelectSubset<T, SectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Section.
     * @param {SectionCreateArgs} args - Arguments to create a Section.
     * @example
     * // Create one Section
     * const Section = await prisma.section.create({
     *   data: {
     *     // ... data to create a Section
     *   }
     * })
     * 
     */
    create<T extends SectionCreateArgs>(args: SelectSubset<T, SectionCreateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sections.
     * @param {SectionCreateManyArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectionCreateManyArgs>(args?: SelectSubset<T, SectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Section.
     * @param {SectionDeleteArgs} args - Arguments to delete one Section.
     * @example
     * // Delete one Section
     * const Section = await prisma.section.delete({
     *   where: {
     *     // ... filter to delete one Section
     *   }
     * })
     * 
     */
    delete<T extends SectionDeleteArgs>(args: SelectSubset<T, SectionDeleteArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Section.
     * @param {SectionUpdateArgs} args - Arguments to update one Section.
     * @example
     * // Update one Section
     * const section = await prisma.section.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectionUpdateArgs>(args: SelectSubset<T, SectionUpdateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sections.
     * @param {SectionDeleteManyArgs} args - Arguments to filter Sections to delete.
     * @example
     * // Delete a few Sections
     * const { count } = await prisma.section.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectionDeleteManyArgs>(args?: SelectSubset<T, SectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sections
     * const section = await prisma.section.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectionUpdateManyArgs>(args: SelectSubset<T, SectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Section.
     * @param {SectionUpsertArgs} args - Arguments to update or create a Section.
     * @example
     * // Update or create a Section
     * const section = await prisma.section.upsert({
     *   create: {
     *     // ... data to create a Section
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Section we want to update
     *   }
     * })
     */
    upsert<T extends SectionUpsertArgs>(args: SelectSubset<T, SectionUpsertArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sections that matches the filter.
     * @param {SectionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const section = await prisma.section.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SectionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Section.
     * @param {SectionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const section = await prisma.section.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SectionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionCountArgs} args - Arguments to filter Sections to count.
     * @example
     * // Count the number of Sections
     * const count = await prisma.section.count({
     *   where: {
     *     // ... the filter for the Sections we want to count
     *   }
     * })
    **/
    count<T extends SectionCountArgs>(
      args?: Subset<T, SectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectionAggregateArgs>(args: Subset<T, SectionAggregateArgs>): Prisma.PrismaPromise<GetSectionAggregateType<T>>

    /**
     * Group by Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectionGroupByArgs['orderBy'] }
        : { orderBy?: SectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Section model
   */
  readonly fields: SectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Section.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    textBlocks<T extends Section$textBlocksArgs<ExtArgs> = {}>(args?: Subset<T, Section$textBlocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    imageBlocks<T extends Section$imageBlocksArgs<ExtArgs> = {}>(args?: Subset<T, Section$imageBlocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    heroContent<T extends Section$heroContentArgs<ExtArgs> = {}>(args?: Subset<T, Section$heroContentArgs<ExtArgs>>): Prisma__HeroSectionContentClient<$Result.GetResult<Prisma.$HeroSectionContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    educationItems<T extends Section$educationItemsArgs<ExtArgs> = {}>(args?: Subset<T, Section$educationItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    skillItems<T extends Section$skillItemsArgs<ExtArgs> = {}>(args?: Subset<T, Section$skillItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    skillImages<T extends Section$skillImagesArgs<ExtArgs> = {}>(args?: Subset<T, Section$skillImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    experienceItems<T extends Section$experienceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Section$experienceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperienceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectItems<T extends Section$projectItemsArgs<ExtArgs> = {}>(args?: Subset<T, Section$projectItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testimonialItems<T extends Section$testimonialItemsArgs<ExtArgs> = {}>(args?: Subset<T, Section$testimonialItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contactInfoItems<T extends Section$contactInfoItemsArgs<ExtArgs> = {}>(args?: Subset<T, Section$contactInfoItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactInfoItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customSectionContentBlocks<T extends Section$customSectionContentBlocksArgs<ExtArgs> = {}>(args?: Subset<T, Section$customSectionContentBlocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomSectionContentBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Section model
   */
  interface SectionFieldRefs {
    readonly id: FieldRef<"Section", 'String'>
    readonly slug: FieldRef<"Section", 'String'>
    readonly title: FieldRef<"Section", 'String'>
    readonly type: FieldRef<"Section", 'String'>
    readonly visible: FieldRef<"Section", 'Boolean'>
    readonly order: FieldRef<"Section", 'Int'>
    readonly createdAt: FieldRef<"Section", 'DateTime'>
    readonly updatedAt: FieldRef<"Section", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Section findUnique
   */
  export type SectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findUniqueOrThrow
   */
  export type SectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findFirst
   */
  export type SectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findFirstOrThrow
   */
  export type SectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findMany
   */
  export type SectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Sections to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section create
   */
  export type SectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Section.
     */
    data: XOR<SectionCreateInput, SectionUncheckedCreateInput>
  }

  /**
   * Section createMany
   */
  export type SectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
  }

  /**
   * Section update
   */
  export type SectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Section.
     */
    data: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
    /**
     * Choose, which Section to update.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section updateMany
   */
  export type SectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sections.
     */
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyInput>
    /**
     * Filter which Sections to update
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to update.
     */
    limit?: number
  }

  /**
   * Section upsert
   */
  export type SectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Section to update in case it exists.
     */
    where: SectionWhereUniqueInput
    /**
     * In case the Section found by the `where` argument doesn't exist, create a new Section with this data.
     */
    create: XOR<SectionCreateInput, SectionUncheckedCreateInput>
    /**
     * In case the Section was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
  }

  /**
   * Section delete
   */
  export type SectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter which Section to delete.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section deleteMany
   */
  export type SectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sections to delete
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to delete.
     */
    limit?: number
  }

  /**
   * Section findRaw
   */
  export type SectionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Section aggregateRaw
   */
  export type SectionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Section.textBlocks
   */
  export type Section$textBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextBlock
     */
    select?: TextBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextBlock
     */
    omit?: TextBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextBlockInclude<ExtArgs> | null
    where?: TextBlockWhereInput
    orderBy?: TextBlockOrderByWithRelationInput | TextBlockOrderByWithRelationInput[]
    cursor?: TextBlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TextBlockScalarFieldEnum | TextBlockScalarFieldEnum[]
  }

  /**
   * Section.imageBlocks
   */
  export type Section$imageBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageBlock
     */
    select?: ImageBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageBlock
     */
    omit?: ImageBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageBlockInclude<ExtArgs> | null
    where?: ImageBlockWhereInput
    orderBy?: ImageBlockOrderByWithRelationInput | ImageBlockOrderByWithRelationInput[]
    cursor?: ImageBlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageBlockScalarFieldEnum | ImageBlockScalarFieldEnum[]
  }

  /**
   * Section.heroContent
   */
  export type Section$heroContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSectionContent
     */
    select?: HeroSectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSectionContent
     */
    omit?: HeroSectionContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroSectionContentInclude<ExtArgs> | null
    where?: HeroSectionContentWhereInput
  }

  /**
   * Section.educationItems
   */
  export type Section$educationItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationItem
     */
    select?: EducationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationItem
     */
    omit?: EducationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationItemInclude<ExtArgs> | null
    where?: EducationItemWhereInput
    orderBy?: EducationItemOrderByWithRelationInput | EducationItemOrderByWithRelationInput[]
    cursor?: EducationItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EducationItemScalarFieldEnum | EducationItemScalarFieldEnum[]
  }

  /**
   * Section.skillItems
   */
  export type Section$skillItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillItem
     */
    select?: SkillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillItem
     */
    omit?: SkillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillItemInclude<ExtArgs> | null
    where?: SkillItemWhereInput
    orderBy?: SkillItemOrderByWithRelationInput | SkillItemOrderByWithRelationInput[]
    cursor?: SkillItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillItemScalarFieldEnum | SkillItemScalarFieldEnum[]
  }

  /**
   * Section.skillImages
   */
  export type Section$skillImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillImage
     */
    select?: SkillImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillImage
     */
    omit?: SkillImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillImageInclude<ExtArgs> | null
    where?: SkillImageWhereInput
    orderBy?: SkillImageOrderByWithRelationInput | SkillImageOrderByWithRelationInput[]
    cursor?: SkillImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillImageScalarFieldEnum | SkillImageScalarFieldEnum[]
  }

  /**
   * Section.experienceItems
   */
  export type Section$experienceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceItem
     */
    select?: ExperienceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceItem
     */
    omit?: ExperienceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceItemInclude<ExtArgs> | null
    where?: ExperienceItemWhereInput
    orderBy?: ExperienceItemOrderByWithRelationInput | ExperienceItemOrderByWithRelationInput[]
    cursor?: ExperienceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExperienceItemScalarFieldEnum | ExperienceItemScalarFieldEnum[]
  }

  /**
   * Section.projectItems
   */
  export type Section$projectItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectItem
     */
    select?: ProjectItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectItem
     */
    omit?: ProjectItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectItemInclude<ExtArgs> | null
    where?: ProjectItemWhereInput
    orderBy?: ProjectItemOrderByWithRelationInput | ProjectItemOrderByWithRelationInput[]
    cursor?: ProjectItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectItemScalarFieldEnum | ProjectItemScalarFieldEnum[]
  }

  /**
   * Section.testimonialItems
   */
  export type Section$testimonialItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialItem
     */
    select?: TestimonialItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialItem
     */
    omit?: TestimonialItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialItemInclude<ExtArgs> | null
    where?: TestimonialItemWhereInput
    orderBy?: TestimonialItemOrderByWithRelationInput | TestimonialItemOrderByWithRelationInput[]
    cursor?: TestimonialItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestimonialItemScalarFieldEnum | TestimonialItemScalarFieldEnum[]
  }

  /**
   * Section.contactInfoItems
   */
  export type Section$contactInfoItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfoItem
     */
    select?: ContactInfoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfoItem
     */
    omit?: ContactInfoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInfoItemInclude<ExtArgs> | null
    where?: ContactInfoItemWhereInput
    orderBy?: ContactInfoItemOrderByWithRelationInput | ContactInfoItemOrderByWithRelationInput[]
    cursor?: ContactInfoItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactInfoItemScalarFieldEnum | ContactInfoItemScalarFieldEnum[]
  }

  /**
   * Section.customSectionContentBlocks
   */
  export type Section$customSectionContentBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomSectionContentBlock
     */
    select?: CustomSectionContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomSectionContentBlock
     */
    omit?: CustomSectionContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomSectionContentBlockInclude<ExtArgs> | null
    where?: CustomSectionContentBlockWhereInput
    orderBy?: CustomSectionContentBlockOrderByWithRelationInput | CustomSectionContentBlockOrderByWithRelationInput[]
    cursor?: CustomSectionContentBlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomSectionContentBlockScalarFieldEnum | CustomSectionContentBlockScalarFieldEnum[]
  }

  /**
   * Section without action
   */
  export type SectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    order: number | null
  }

  export type CategorySumAggregateOutputType = {
    order: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    order: number
    createdAt: number
    updatedAt: number
    projectIds: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    order?: true
  }

  export type CategorySumAggregateInputType = {
    order?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    projectIds?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    order: number
    createdAt: Date
    updatedAt: Date
    projectIds: string[]
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectIds?: boolean
  }, ExtArgs["result"]["category"]>



  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectIds?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "order" | "createdAt" | "updatedAt" | "projectIds", ExtArgs["result"]["category"]>

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      order: number
      createdAt: Date
      updatedAt: Date
      projectIds: string[]
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * @param {CategoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const category = await prisma.category.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CategoryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Category.
     * @param {CategoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const category = await prisma.category.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CategoryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly order: FieldRef<"Category", 'Int'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
    readonly projectIds: FieldRef<"Category", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category findRaw
   */
  export type CategoryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Category aggregateRaw
   */
  export type CategoryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
  }


  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingMinAggregateOutputType = {
    id: string | null
    siteTitle: string | null
    theme: string | null
    showPortrait: boolean | null
    resumeUrl: string | null
    globalFontFamily: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingMaxAggregateOutputType = {
    id: string | null
    siteTitle: string | null
    theme: string | null
    showPortrait: boolean | null
    resumeUrl: string | null
    globalFontFamily: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingCountAggregateOutputType = {
    id: number
    siteTitle: number
    theme: number
    showPortrait: number
    resumeUrl: number
    globalFontFamily: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettingMinAggregateInputType = {
    id?: true
    siteTitle?: true
    theme?: true
    showPortrait?: true
    resumeUrl?: true
    globalFontFamily?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingMaxAggregateInputType = {
    id?: true
    siteTitle?: true
    theme?: true
    showPortrait?: true
    resumeUrl?: true
    globalFontFamily?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingCountAggregateInputType = {
    id?: true
    siteTitle?: true
    theme?: true
    showPortrait?: true
    resumeUrl?: true
    globalFontFamily?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type SettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    id: string
    siteTitle: string
    theme: string
    showPortrait: boolean
    resumeUrl: string
    globalFontFamily: string
    createdAt: Date
    updatedAt: Date
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteTitle?: boolean
    theme?: boolean
    showPortrait?: boolean
    resumeUrl?: boolean
    globalFontFamily?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>



  export type SettingSelectScalar = {
    id?: boolean
    siteTitle?: boolean
    theme?: boolean
    showPortrait?: boolean
    resumeUrl?: boolean
    globalFontFamily?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "siteTitle" | "theme" | "showPortrait" | "resumeUrl" | "globalFontFamily" | "createdAt" | "updatedAt", ExtArgs["result"]["setting"]>

  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Setting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      siteTitle: string
      theme: string
      showPortrait: boolean
      resumeUrl: string
      globalFontFamily: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }

  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> = $Result.GetResult<Prisma.$SettingPayload, S>

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface SettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting'], meta: { name: 'Setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingFindUniqueArgs>(args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingFindFirstArgs>(args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingFindManyArgs>(args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
     */
    create<T extends SettingCreateArgs>(args: SelectSubset<T, SettingCreateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingCreateManyArgs>(args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
     */
    delete<T extends SettingDeleteArgs>(args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingUpdateArgs>(args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingDeleteManyArgs>(args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingUpdateManyArgs>(args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends SettingUpsertArgs>(args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * @param {SettingFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const setting = await prisma.setting.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SettingFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Setting.
     * @param {SettingAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const setting = await prisma.setting.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SettingAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Setting model
   */
  readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Setting model
   */
  interface SettingFieldRefs {
    readonly id: FieldRef<"Setting", 'String'>
    readonly siteTitle: FieldRef<"Setting", 'String'>
    readonly theme: FieldRef<"Setting", 'String'>
    readonly showPortrait: FieldRef<"Setting", 'Boolean'>
    readonly resumeUrl: FieldRef<"Setting", 'String'>
    readonly globalFontFamily: FieldRef<"Setting", 'String'>
    readonly createdAt: FieldRef<"Setting", 'DateTime'>
    readonly updatedAt: FieldRef<"Setting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting create
   */
  export type SettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>
  }

  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
  }

  /**
   * Setting update
   */
  export type SettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
  }

  /**
   * Setting delete
   */
  export type SettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Setting findRaw
   */
  export type SettingFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Setting aggregateRaw
   */
  export type SettingAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Setting without action
   */
  export type SettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
  }


  /**
   * Model TextBlock
   */

  export type AggregateTextBlock = {
    _count: TextBlockCountAggregateOutputType | null
    _avg: TextBlockAvgAggregateOutputType | null
    _sum: TextBlockSumAggregateOutputType | null
    _min: TextBlockMinAggregateOutputType | null
    _max: TextBlockMaxAggregateOutputType | null
  }

  export type TextBlockAvgAggregateOutputType = {
    order: number | null
    fontSize: number | null
  }

  export type TextBlockSumAggregateOutputType = {
    order: number | null
    fontSize: number | null
  }

  export type TextBlockMinAggregateOutputType = {
    id: string | null
    content: string | null
    order: number | null
    sectionId: string | null
    fontSize: number | null
    fontFamily: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TextBlockMaxAggregateOutputType = {
    id: string | null
    content: string | null
    order: number | null
    sectionId: string | null
    fontSize: number | null
    fontFamily: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TextBlockCountAggregateOutputType = {
    id: number
    content: number
    order: number
    sectionId: number
    fontSize: number
    fontFamily: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TextBlockAvgAggregateInputType = {
    order?: true
    fontSize?: true
  }

  export type TextBlockSumAggregateInputType = {
    order?: true
    fontSize?: true
  }

  export type TextBlockMinAggregateInputType = {
    id?: true
    content?: true
    order?: true
    sectionId?: true
    fontSize?: true
    fontFamily?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TextBlockMaxAggregateInputType = {
    id?: true
    content?: true
    order?: true
    sectionId?: true
    fontSize?: true
    fontFamily?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TextBlockCountAggregateInputType = {
    id?: true
    content?: true
    order?: true
    sectionId?: true
    fontSize?: true
    fontFamily?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TextBlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TextBlock to aggregate.
     */
    where?: TextBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextBlocks to fetch.
     */
    orderBy?: TextBlockOrderByWithRelationInput | TextBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TextBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TextBlocks
    **/
    _count?: true | TextBlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TextBlockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TextBlockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TextBlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TextBlockMaxAggregateInputType
  }

  export type GetTextBlockAggregateType<T extends TextBlockAggregateArgs> = {
        [P in keyof T & keyof AggregateTextBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTextBlock[P]>
      : GetScalarType<T[P], AggregateTextBlock[P]>
  }




  export type TextBlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TextBlockWhereInput
    orderBy?: TextBlockOrderByWithAggregationInput | TextBlockOrderByWithAggregationInput[]
    by: TextBlockScalarFieldEnum[] | TextBlockScalarFieldEnum
    having?: TextBlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TextBlockCountAggregateInputType | true
    _avg?: TextBlockAvgAggregateInputType
    _sum?: TextBlockSumAggregateInputType
    _min?: TextBlockMinAggregateInputType
    _max?: TextBlockMaxAggregateInputType
  }

  export type TextBlockGroupByOutputType = {
    id: string
    content: string
    order: number
    sectionId: string
    fontSize: number | null
    fontFamily: string | null
    createdAt: Date
    updatedAt: Date
    _count: TextBlockCountAggregateOutputType | null
    _avg: TextBlockAvgAggregateOutputType | null
    _sum: TextBlockSumAggregateOutputType | null
    _min: TextBlockMinAggregateOutputType | null
    _max: TextBlockMaxAggregateOutputType | null
  }

  type GetTextBlockGroupByPayload<T extends TextBlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TextBlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TextBlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TextBlockGroupByOutputType[P]>
            : GetScalarType<T[P], TextBlockGroupByOutputType[P]>
        }
      >
    >


  export type TextBlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    order?: boolean
    sectionId?: boolean
    fontSize?: boolean
    fontFamily?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["textBlock"]>



  export type TextBlockSelectScalar = {
    id?: boolean
    content?: boolean
    order?: boolean
    sectionId?: boolean
    fontSize?: boolean
    fontFamily?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TextBlockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "order" | "sectionId" | "fontSize" | "fontFamily" | "createdAt" | "updatedAt", ExtArgs["result"]["textBlock"]>
  export type TextBlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }

  export type $TextBlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TextBlock"
    objects: {
      section: Prisma.$SectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      order: number
      sectionId: string
      fontSize: number | null
      fontFamily: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["textBlock"]>
    composites: {}
  }

  type TextBlockGetPayload<S extends boolean | null | undefined | TextBlockDefaultArgs> = $Result.GetResult<Prisma.$TextBlockPayload, S>

  type TextBlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TextBlockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TextBlockCountAggregateInputType | true
    }

  export interface TextBlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TextBlock'], meta: { name: 'TextBlock' } }
    /**
     * Find zero or one TextBlock that matches the filter.
     * @param {TextBlockFindUniqueArgs} args - Arguments to find a TextBlock
     * @example
     * // Get one TextBlock
     * const textBlock = await prisma.textBlock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TextBlockFindUniqueArgs>(args: SelectSubset<T, TextBlockFindUniqueArgs<ExtArgs>>): Prisma__TextBlockClient<$Result.GetResult<Prisma.$TextBlockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TextBlock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TextBlockFindUniqueOrThrowArgs} args - Arguments to find a TextBlock
     * @example
     * // Get one TextBlock
     * const textBlock = await prisma.textBlock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TextBlockFindUniqueOrThrowArgs>(args: SelectSubset<T, TextBlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TextBlockClient<$Result.GetResult<Prisma.$TextBlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TextBlock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextBlockFindFirstArgs} args - Arguments to find a TextBlock
     * @example
     * // Get one TextBlock
     * const textBlock = await prisma.textBlock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TextBlockFindFirstArgs>(args?: SelectSubset<T, TextBlockFindFirstArgs<ExtArgs>>): Prisma__TextBlockClient<$Result.GetResult<Prisma.$TextBlockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TextBlock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextBlockFindFirstOrThrowArgs} args - Arguments to find a TextBlock
     * @example
     * // Get one TextBlock
     * const textBlock = await prisma.textBlock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TextBlockFindFirstOrThrowArgs>(args?: SelectSubset<T, TextBlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__TextBlockClient<$Result.GetResult<Prisma.$TextBlockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TextBlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextBlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TextBlocks
     * const textBlocks = await prisma.textBlock.findMany()
     * 
     * // Get first 10 TextBlocks
     * const textBlocks = await prisma.textBlock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const textBlockWithIdOnly = await prisma.textBlock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TextBlockFindManyArgs>(args?: SelectSubset<T, TextBlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TextBlock.
     * @param {TextBlockCreateArgs} args - Arguments to create a TextBlock.
     * @example
     * // Create one TextBlock
     * const TextBlock = await prisma.textBlock.create({
     *   data: {
     *     // ... data to create a TextBlock
     *   }
     * })
     * 
     */
    create<T extends TextBlockCreateArgs>(args: SelectSubset<T, TextBlockCreateArgs<ExtArgs>>): Prisma__TextBlockClient<$Result.GetResult<Prisma.$TextBlockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TextBlocks.
     * @param {TextBlockCreateManyArgs} args - Arguments to create many TextBlocks.
     * @example
     * // Create many TextBlocks
     * const textBlock = await prisma.textBlock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TextBlockCreateManyArgs>(args?: SelectSubset<T, TextBlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TextBlock.
     * @param {TextBlockDeleteArgs} args - Arguments to delete one TextBlock.
     * @example
     * // Delete one TextBlock
     * const TextBlock = await prisma.textBlock.delete({
     *   where: {
     *     // ... filter to delete one TextBlock
     *   }
     * })
     * 
     */
    delete<T extends TextBlockDeleteArgs>(args: SelectSubset<T, TextBlockDeleteArgs<ExtArgs>>): Prisma__TextBlockClient<$Result.GetResult<Prisma.$TextBlockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TextBlock.
     * @param {TextBlockUpdateArgs} args - Arguments to update one TextBlock.
     * @example
     * // Update one TextBlock
     * const textBlock = await prisma.textBlock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TextBlockUpdateArgs>(args: SelectSubset<T, TextBlockUpdateArgs<ExtArgs>>): Prisma__TextBlockClient<$Result.GetResult<Prisma.$TextBlockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TextBlocks.
     * @param {TextBlockDeleteManyArgs} args - Arguments to filter TextBlocks to delete.
     * @example
     * // Delete a few TextBlocks
     * const { count } = await prisma.textBlock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TextBlockDeleteManyArgs>(args?: SelectSubset<T, TextBlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TextBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextBlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TextBlocks
     * const textBlock = await prisma.textBlock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TextBlockUpdateManyArgs>(args: SelectSubset<T, TextBlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TextBlock.
     * @param {TextBlockUpsertArgs} args - Arguments to update or create a TextBlock.
     * @example
     * // Update or create a TextBlock
     * const textBlock = await prisma.textBlock.upsert({
     *   create: {
     *     // ... data to create a TextBlock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TextBlock we want to update
     *   }
     * })
     */
    upsert<T extends TextBlockUpsertArgs>(args: SelectSubset<T, TextBlockUpsertArgs<ExtArgs>>): Prisma__TextBlockClient<$Result.GetResult<Prisma.$TextBlockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TextBlocks that matches the filter.
     * @param {TextBlockFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const textBlock = await prisma.textBlock.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TextBlockFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TextBlock.
     * @param {TextBlockAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const textBlock = await prisma.textBlock.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TextBlockAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TextBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextBlockCountArgs} args - Arguments to filter TextBlocks to count.
     * @example
     * // Count the number of TextBlocks
     * const count = await prisma.textBlock.count({
     *   where: {
     *     // ... the filter for the TextBlocks we want to count
     *   }
     * })
    **/
    count<T extends TextBlockCountArgs>(
      args?: Subset<T, TextBlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TextBlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TextBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextBlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TextBlockAggregateArgs>(args: Subset<T, TextBlockAggregateArgs>): Prisma.PrismaPromise<GetTextBlockAggregateType<T>>

    /**
     * Group by TextBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextBlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TextBlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TextBlockGroupByArgs['orderBy'] }
        : { orderBy?: TextBlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TextBlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTextBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TextBlock model
   */
  readonly fields: TextBlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TextBlock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TextBlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TextBlock model
   */
  interface TextBlockFieldRefs {
    readonly id: FieldRef<"TextBlock", 'String'>
    readonly content: FieldRef<"TextBlock", 'String'>
    readonly order: FieldRef<"TextBlock", 'Int'>
    readonly sectionId: FieldRef<"TextBlock", 'String'>
    readonly fontSize: FieldRef<"TextBlock", 'Int'>
    readonly fontFamily: FieldRef<"TextBlock", 'String'>
    readonly createdAt: FieldRef<"TextBlock", 'DateTime'>
    readonly updatedAt: FieldRef<"TextBlock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TextBlock findUnique
   */
  export type TextBlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextBlock
     */
    select?: TextBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextBlock
     */
    omit?: TextBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextBlockInclude<ExtArgs> | null
    /**
     * Filter, which TextBlock to fetch.
     */
    where: TextBlockWhereUniqueInput
  }

  /**
   * TextBlock findUniqueOrThrow
   */
  export type TextBlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextBlock
     */
    select?: TextBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextBlock
     */
    omit?: TextBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextBlockInclude<ExtArgs> | null
    /**
     * Filter, which TextBlock to fetch.
     */
    where: TextBlockWhereUniqueInput
  }

  /**
   * TextBlock findFirst
   */
  export type TextBlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextBlock
     */
    select?: TextBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextBlock
     */
    omit?: TextBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextBlockInclude<ExtArgs> | null
    /**
     * Filter, which TextBlock to fetch.
     */
    where?: TextBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextBlocks to fetch.
     */
    orderBy?: TextBlockOrderByWithRelationInput | TextBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TextBlocks.
     */
    cursor?: TextBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TextBlocks.
     */
    distinct?: TextBlockScalarFieldEnum | TextBlockScalarFieldEnum[]
  }

  /**
   * TextBlock findFirstOrThrow
   */
  export type TextBlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextBlock
     */
    select?: TextBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextBlock
     */
    omit?: TextBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextBlockInclude<ExtArgs> | null
    /**
     * Filter, which TextBlock to fetch.
     */
    where?: TextBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextBlocks to fetch.
     */
    orderBy?: TextBlockOrderByWithRelationInput | TextBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TextBlocks.
     */
    cursor?: TextBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TextBlocks.
     */
    distinct?: TextBlockScalarFieldEnum | TextBlockScalarFieldEnum[]
  }

  /**
   * TextBlock findMany
   */
  export type TextBlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextBlock
     */
    select?: TextBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextBlock
     */
    omit?: TextBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextBlockInclude<ExtArgs> | null
    /**
     * Filter, which TextBlocks to fetch.
     */
    where?: TextBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextBlocks to fetch.
     */
    orderBy?: TextBlockOrderByWithRelationInput | TextBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TextBlocks.
     */
    cursor?: TextBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextBlocks.
     */
    skip?: number
    distinct?: TextBlockScalarFieldEnum | TextBlockScalarFieldEnum[]
  }

  /**
   * TextBlock create
   */
  export type TextBlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextBlock
     */
    select?: TextBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextBlock
     */
    omit?: TextBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextBlockInclude<ExtArgs> | null
    /**
     * The data needed to create a TextBlock.
     */
    data: XOR<TextBlockCreateInput, TextBlockUncheckedCreateInput>
  }

  /**
   * TextBlock createMany
   */
  export type TextBlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TextBlocks.
     */
    data: TextBlockCreateManyInput | TextBlockCreateManyInput[]
  }

  /**
   * TextBlock update
   */
  export type TextBlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextBlock
     */
    select?: TextBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextBlock
     */
    omit?: TextBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextBlockInclude<ExtArgs> | null
    /**
     * The data needed to update a TextBlock.
     */
    data: XOR<TextBlockUpdateInput, TextBlockUncheckedUpdateInput>
    /**
     * Choose, which TextBlock to update.
     */
    where: TextBlockWhereUniqueInput
  }

  /**
   * TextBlock updateMany
   */
  export type TextBlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TextBlocks.
     */
    data: XOR<TextBlockUpdateManyMutationInput, TextBlockUncheckedUpdateManyInput>
    /**
     * Filter which TextBlocks to update
     */
    where?: TextBlockWhereInput
    /**
     * Limit how many TextBlocks to update.
     */
    limit?: number
  }

  /**
   * TextBlock upsert
   */
  export type TextBlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextBlock
     */
    select?: TextBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextBlock
     */
    omit?: TextBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextBlockInclude<ExtArgs> | null
    /**
     * The filter to search for the TextBlock to update in case it exists.
     */
    where: TextBlockWhereUniqueInput
    /**
     * In case the TextBlock found by the `where` argument doesn't exist, create a new TextBlock with this data.
     */
    create: XOR<TextBlockCreateInput, TextBlockUncheckedCreateInput>
    /**
     * In case the TextBlock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TextBlockUpdateInput, TextBlockUncheckedUpdateInput>
  }

  /**
   * TextBlock delete
   */
  export type TextBlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextBlock
     */
    select?: TextBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextBlock
     */
    omit?: TextBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextBlockInclude<ExtArgs> | null
    /**
     * Filter which TextBlock to delete.
     */
    where: TextBlockWhereUniqueInput
  }

  /**
   * TextBlock deleteMany
   */
  export type TextBlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TextBlocks to delete
     */
    where?: TextBlockWhereInput
    /**
     * Limit how many TextBlocks to delete.
     */
    limit?: number
  }

  /**
   * TextBlock findRaw
   */
  export type TextBlockFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TextBlock aggregateRaw
   */
  export type TextBlockAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TextBlock without action
   */
  export type TextBlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextBlock
     */
    select?: TextBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextBlock
     */
    omit?: TextBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextBlockInclude<ExtArgs> | null
  }


  /**
   * Model ImageBlock
   */

  export type AggregateImageBlock = {
    _count: ImageBlockCountAggregateOutputType | null
    _avg: ImageBlockAvgAggregateOutputType | null
    _sum: ImageBlockSumAggregateOutputType | null
    _min: ImageBlockMinAggregateOutputType | null
    _max: ImageBlockMaxAggregateOutputType | null
  }

  export type ImageBlockAvgAggregateOutputType = {
    order: number | null
  }

  export type ImageBlockSumAggregateOutputType = {
    order: number | null
  }

  export type ImageBlockMinAggregateOutputType = {
    id: string | null
    src: string | null
    alt: string | null
    caption: string | null
    imagePublicId: string | null
    order: number | null
    sectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImageBlockMaxAggregateOutputType = {
    id: string | null
    src: string | null
    alt: string | null
    caption: string | null
    imagePublicId: string | null
    order: number | null
    sectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImageBlockCountAggregateOutputType = {
    id: number
    src: number
    alt: number
    caption: number
    imagePublicId: number
    order: number
    sectionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ImageBlockAvgAggregateInputType = {
    order?: true
  }

  export type ImageBlockSumAggregateInputType = {
    order?: true
  }

  export type ImageBlockMinAggregateInputType = {
    id?: true
    src?: true
    alt?: true
    caption?: true
    imagePublicId?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImageBlockMaxAggregateInputType = {
    id?: true
    src?: true
    alt?: true
    caption?: true
    imagePublicId?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImageBlockCountAggregateInputType = {
    id?: true
    src?: true
    alt?: true
    caption?: true
    imagePublicId?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ImageBlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImageBlock to aggregate.
     */
    where?: ImageBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageBlocks to fetch.
     */
    orderBy?: ImageBlockOrderByWithRelationInput | ImageBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImageBlocks
    **/
    _count?: true | ImageBlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImageBlockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImageBlockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageBlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageBlockMaxAggregateInputType
  }

  export type GetImageBlockAggregateType<T extends ImageBlockAggregateArgs> = {
        [P in keyof T & keyof AggregateImageBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImageBlock[P]>
      : GetScalarType<T[P], AggregateImageBlock[P]>
  }




  export type ImageBlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageBlockWhereInput
    orderBy?: ImageBlockOrderByWithAggregationInput | ImageBlockOrderByWithAggregationInput[]
    by: ImageBlockScalarFieldEnum[] | ImageBlockScalarFieldEnum
    having?: ImageBlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageBlockCountAggregateInputType | true
    _avg?: ImageBlockAvgAggregateInputType
    _sum?: ImageBlockSumAggregateInputType
    _min?: ImageBlockMinAggregateInputType
    _max?: ImageBlockMaxAggregateInputType
  }

  export type ImageBlockGroupByOutputType = {
    id: string
    src: string
    alt: string | null
    caption: string | null
    imagePublicId: string | null
    order: number
    sectionId: string
    createdAt: Date
    updatedAt: Date
    _count: ImageBlockCountAggregateOutputType | null
    _avg: ImageBlockAvgAggregateOutputType | null
    _sum: ImageBlockSumAggregateOutputType | null
    _min: ImageBlockMinAggregateOutputType | null
    _max: ImageBlockMaxAggregateOutputType | null
  }

  type GetImageBlockGroupByPayload<T extends ImageBlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImageBlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageBlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageBlockGroupByOutputType[P]>
            : GetScalarType<T[P], ImageBlockGroupByOutputType[P]>
        }
      >
    >


  export type ImageBlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    src?: boolean
    alt?: boolean
    caption?: boolean
    imagePublicId?: boolean
    order?: boolean
    sectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["imageBlock"]>



  export type ImageBlockSelectScalar = {
    id?: boolean
    src?: boolean
    alt?: boolean
    caption?: boolean
    imagePublicId?: boolean
    order?: boolean
    sectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ImageBlockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "src" | "alt" | "caption" | "imagePublicId" | "order" | "sectionId" | "createdAt" | "updatedAt", ExtArgs["result"]["imageBlock"]>
  export type ImageBlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }

  export type $ImageBlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImageBlock"
    objects: {
      section: Prisma.$SectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      src: string
      alt: string | null
      caption: string | null
      imagePublicId: string | null
      order: number
      sectionId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["imageBlock"]>
    composites: {}
  }

  type ImageBlockGetPayload<S extends boolean | null | undefined | ImageBlockDefaultArgs> = $Result.GetResult<Prisma.$ImageBlockPayload, S>

  type ImageBlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImageBlockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImageBlockCountAggregateInputType | true
    }

  export interface ImageBlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImageBlock'], meta: { name: 'ImageBlock' } }
    /**
     * Find zero or one ImageBlock that matches the filter.
     * @param {ImageBlockFindUniqueArgs} args - Arguments to find a ImageBlock
     * @example
     * // Get one ImageBlock
     * const imageBlock = await prisma.imageBlock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImageBlockFindUniqueArgs>(args: SelectSubset<T, ImageBlockFindUniqueArgs<ExtArgs>>): Prisma__ImageBlockClient<$Result.GetResult<Prisma.$ImageBlockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ImageBlock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImageBlockFindUniqueOrThrowArgs} args - Arguments to find a ImageBlock
     * @example
     * // Get one ImageBlock
     * const imageBlock = await prisma.imageBlock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImageBlockFindUniqueOrThrowArgs>(args: SelectSubset<T, ImageBlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImageBlockClient<$Result.GetResult<Prisma.$ImageBlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImageBlock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageBlockFindFirstArgs} args - Arguments to find a ImageBlock
     * @example
     * // Get one ImageBlock
     * const imageBlock = await prisma.imageBlock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImageBlockFindFirstArgs>(args?: SelectSubset<T, ImageBlockFindFirstArgs<ExtArgs>>): Prisma__ImageBlockClient<$Result.GetResult<Prisma.$ImageBlockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImageBlock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageBlockFindFirstOrThrowArgs} args - Arguments to find a ImageBlock
     * @example
     * // Get one ImageBlock
     * const imageBlock = await prisma.imageBlock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImageBlockFindFirstOrThrowArgs>(args?: SelectSubset<T, ImageBlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImageBlockClient<$Result.GetResult<Prisma.$ImageBlockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImageBlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageBlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImageBlocks
     * const imageBlocks = await prisma.imageBlock.findMany()
     * 
     * // Get first 10 ImageBlocks
     * const imageBlocks = await prisma.imageBlock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageBlockWithIdOnly = await prisma.imageBlock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImageBlockFindManyArgs>(args?: SelectSubset<T, ImageBlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ImageBlock.
     * @param {ImageBlockCreateArgs} args - Arguments to create a ImageBlock.
     * @example
     * // Create one ImageBlock
     * const ImageBlock = await prisma.imageBlock.create({
     *   data: {
     *     // ... data to create a ImageBlock
     *   }
     * })
     * 
     */
    create<T extends ImageBlockCreateArgs>(args: SelectSubset<T, ImageBlockCreateArgs<ExtArgs>>): Prisma__ImageBlockClient<$Result.GetResult<Prisma.$ImageBlockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ImageBlocks.
     * @param {ImageBlockCreateManyArgs} args - Arguments to create many ImageBlocks.
     * @example
     * // Create many ImageBlocks
     * const imageBlock = await prisma.imageBlock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImageBlockCreateManyArgs>(args?: SelectSubset<T, ImageBlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ImageBlock.
     * @param {ImageBlockDeleteArgs} args - Arguments to delete one ImageBlock.
     * @example
     * // Delete one ImageBlock
     * const ImageBlock = await prisma.imageBlock.delete({
     *   where: {
     *     // ... filter to delete one ImageBlock
     *   }
     * })
     * 
     */
    delete<T extends ImageBlockDeleteArgs>(args: SelectSubset<T, ImageBlockDeleteArgs<ExtArgs>>): Prisma__ImageBlockClient<$Result.GetResult<Prisma.$ImageBlockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ImageBlock.
     * @param {ImageBlockUpdateArgs} args - Arguments to update one ImageBlock.
     * @example
     * // Update one ImageBlock
     * const imageBlock = await prisma.imageBlock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImageBlockUpdateArgs>(args: SelectSubset<T, ImageBlockUpdateArgs<ExtArgs>>): Prisma__ImageBlockClient<$Result.GetResult<Prisma.$ImageBlockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ImageBlocks.
     * @param {ImageBlockDeleteManyArgs} args - Arguments to filter ImageBlocks to delete.
     * @example
     * // Delete a few ImageBlocks
     * const { count } = await prisma.imageBlock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImageBlockDeleteManyArgs>(args?: SelectSubset<T, ImageBlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImageBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageBlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImageBlocks
     * const imageBlock = await prisma.imageBlock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImageBlockUpdateManyArgs>(args: SelectSubset<T, ImageBlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImageBlock.
     * @param {ImageBlockUpsertArgs} args - Arguments to update or create a ImageBlock.
     * @example
     * // Update or create a ImageBlock
     * const imageBlock = await prisma.imageBlock.upsert({
     *   create: {
     *     // ... data to create a ImageBlock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImageBlock we want to update
     *   }
     * })
     */
    upsert<T extends ImageBlockUpsertArgs>(args: SelectSubset<T, ImageBlockUpsertArgs<ExtArgs>>): Prisma__ImageBlockClient<$Result.GetResult<Prisma.$ImageBlockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImageBlocks that matches the filter.
     * @param {ImageBlockFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const imageBlock = await prisma.imageBlock.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ImageBlockFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ImageBlock.
     * @param {ImageBlockAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const imageBlock = await prisma.imageBlock.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ImageBlockAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ImageBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageBlockCountArgs} args - Arguments to filter ImageBlocks to count.
     * @example
     * // Count the number of ImageBlocks
     * const count = await prisma.imageBlock.count({
     *   where: {
     *     // ... the filter for the ImageBlocks we want to count
     *   }
     * })
    **/
    count<T extends ImageBlockCountArgs>(
      args?: Subset<T, ImageBlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageBlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImageBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageBlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageBlockAggregateArgs>(args: Subset<T, ImageBlockAggregateArgs>): Prisma.PrismaPromise<GetImageBlockAggregateType<T>>

    /**
     * Group by ImageBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageBlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageBlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageBlockGroupByArgs['orderBy'] }
        : { orderBy?: ImageBlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageBlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImageBlock model
   */
  readonly fields: ImageBlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImageBlock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageBlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImageBlock model
   */
  interface ImageBlockFieldRefs {
    readonly id: FieldRef<"ImageBlock", 'String'>
    readonly src: FieldRef<"ImageBlock", 'String'>
    readonly alt: FieldRef<"ImageBlock", 'String'>
    readonly caption: FieldRef<"ImageBlock", 'String'>
    readonly imagePublicId: FieldRef<"ImageBlock", 'String'>
    readonly order: FieldRef<"ImageBlock", 'Int'>
    readonly sectionId: FieldRef<"ImageBlock", 'String'>
    readonly createdAt: FieldRef<"ImageBlock", 'DateTime'>
    readonly updatedAt: FieldRef<"ImageBlock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ImageBlock findUnique
   */
  export type ImageBlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageBlock
     */
    select?: ImageBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageBlock
     */
    omit?: ImageBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageBlockInclude<ExtArgs> | null
    /**
     * Filter, which ImageBlock to fetch.
     */
    where: ImageBlockWhereUniqueInput
  }

  /**
   * ImageBlock findUniqueOrThrow
   */
  export type ImageBlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageBlock
     */
    select?: ImageBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageBlock
     */
    omit?: ImageBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageBlockInclude<ExtArgs> | null
    /**
     * Filter, which ImageBlock to fetch.
     */
    where: ImageBlockWhereUniqueInput
  }

  /**
   * ImageBlock findFirst
   */
  export type ImageBlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageBlock
     */
    select?: ImageBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageBlock
     */
    omit?: ImageBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageBlockInclude<ExtArgs> | null
    /**
     * Filter, which ImageBlock to fetch.
     */
    where?: ImageBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageBlocks to fetch.
     */
    orderBy?: ImageBlockOrderByWithRelationInput | ImageBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImageBlocks.
     */
    cursor?: ImageBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImageBlocks.
     */
    distinct?: ImageBlockScalarFieldEnum | ImageBlockScalarFieldEnum[]
  }

  /**
   * ImageBlock findFirstOrThrow
   */
  export type ImageBlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageBlock
     */
    select?: ImageBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageBlock
     */
    omit?: ImageBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageBlockInclude<ExtArgs> | null
    /**
     * Filter, which ImageBlock to fetch.
     */
    where?: ImageBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageBlocks to fetch.
     */
    orderBy?: ImageBlockOrderByWithRelationInput | ImageBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImageBlocks.
     */
    cursor?: ImageBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImageBlocks.
     */
    distinct?: ImageBlockScalarFieldEnum | ImageBlockScalarFieldEnum[]
  }

  /**
   * ImageBlock findMany
   */
  export type ImageBlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageBlock
     */
    select?: ImageBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageBlock
     */
    omit?: ImageBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageBlockInclude<ExtArgs> | null
    /**
     * Filter, which ImageBlocks to fetch.
     */
    where?: ImageBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageBlocks to fetch.
     */
    orderBy?: ImageBlockOrderByWithRelationInput | ImageBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImageBlocks.
     */
    cursor?: ImageBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageBlocks.
     */
    skip?: number
    distinct?: ImageBlockScalarFieldEnum | ImageBlockScalarFieldEnum[]
  }

  /**
   * ImageBlock create
   */
  export type ImageBlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageBlock
     */
    select?: ImageBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageBlock
     */
    omit?: ImageBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageBlockInclude<ExtArgs> | null
    /**
     * The data needed to create a ImageBlock.
     */
    data: XOR<ImageBlockCreateInput, ImageBlockUncheckedCreateInput>
  }

  /**
   * ImageBlock createMany
   */
  export type ImageBlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImageBlocks.
     */
    data: ImageBlockCreateManyInput | ImageBlockCreateManyInput[]
  }

  /**
   * ImageBlock update
   */
  export type ImageBlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageBlock
     */
    select?: ImageBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageBlock
     */
    omit?: ImageBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageBlockInclude<ExtArgs> | null
    /**
     * The data needed to update a ImageBlock.
     */
    data: XOR<ImageBlockUpdateInput, ImageBlockUncheckedUpdateInput>
    /**
     * Choose, which ImageBlock to update.
     */
    where: ImageBlockWhereUniqueInput
  }

  /**
   * ImageBlock updateMany
   */
  export type ImageBlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImageBlocks.
     */
    data: XOR<ImageBlockUpdateManyMutationInput, ImageBlockUncheckedUpdateManyInput>
    /**
     * Filter which ImageBlocks to update
     */
    where?: ImageBlockWhereInput
    /**
     * Limit how many ImageBlocks to update.
     */
    limit?: number
  }

  /**
   * ImageBlock upsert
   */
  export type ImageBlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageBlock
     */
    select?: ImageBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageBlock
     */
    omit?: ImageBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageBlockInclude<ExtArgs> | null
    /**
     * The filter to search for the ImageBlock to update in case it exists.
     */
    where: ImageBlockWhereUniqueInput
    /**
     * In case the ImageBlock found by the `where` argument doesn't exist, create a new ImageBlock with this data.
     */
    create: XOR<ImageBlockCreateInput, ImageBlockUncheckedCreateInput>
    /**
     * In case the ImageBlock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageBlockUpdateInput, ImageBlockUncheckedUpdateInput>
  }

  /**
   * ImageBlock delete
   */
  export type ImageBlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageBlock
     */
    select?: ImageBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageBlock
     */
    omit?: ImageBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageBlockInclude<ExtArgs> | null
    /**
     * Filter which ImageBlock to delete.
     */
    where: ImageBlockWhereUniqueInput
  }

  /**
   * ImageBlock deleteMany
   */
  export type ImageBlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImageBlocks to delete
     */
    where?: ImageBlockWhereInput
    /**
     * Limit how many ImageBlocks to delete.
     */
    limit?: number
  }

  /**
   * ImageBlock findRaw
   */
  export type ImageBlockFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ImageBlock aggregateRaw
   */
  export type ImageBlockAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ImageBlock without action
   */
  export type ImageBlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageBlock
     */
    select?: ImageBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageBlock
     */
    omit?: ImageBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageBlockInclude<ExtArgs> | null
  }


  /**
   * Model HeroSectionContent
   */

  export type AggregateHeroSectionContent = {
    _count: HeroSectionContentCountAggregateOutputType | null
    _min: HeroSectionContentMinAggregateOutputType | null
    _max: HeroSectionContentMaxAggregateOutputType | null
  }

  export type HeroSectionContentMinAggregateOutputType = {
    id: string | null
    portraitImageSrc: string | null
    portraitImagePublicId: string | null
    portraitAlt: string | null
    sectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HeroSectionContentMaxAggregateOutputType = {
    id: string | null
    portraitImageSrc: string | null
    portraitImagePublicId: string | null
    portraitAlt: string | null
    sectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HeroSectionContentCountAggregateOutputType = {
    id: number
    portraitImageSrc: number
    portraitImagePublicId: number
    portraitAlt: number
    sectionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HeroSectionContentMinAggregateInputType = {
    id?: true
    portraitImageSrc?: true
    portraitImagePublicId?: true
    portraitAlt?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HeroSectionContentMaxAggregateInputType = {
    id?: true
    portraitImageSrc?: true
    portraitImagePublicId?: true
    portraitAlt?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HeroSectionContentCountAggregateInputType = {
    id?: true
    portraitImageSrc?: true
    portraitImagePublicId?: true
    portraitAlt?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HeroSectionContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeroSectionContent to aggregate.
     */
    where?: HeroSectionContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroSectionContents to fetch.
     */
    orderBy?: HeroSectionContentOrderByWithRelationInput | HeroSectionContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HeroSectionContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroSectionContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroSectionContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HeroSectionContents
    **/
    _count?: true | HeroSectionContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HeroSectionContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HeroSectionContentMaxAggregateInputType
  }

  export type GetHeroSectionContentAggregateType<T extends HeroSectionContentAggregateArgs> = {
        [P in keyof T & keyof AggregateHeroSectionContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHeroSectionContent[P]>
      : GetScalarType<T[P], AggregateHeroSectionContent[P]>
  }




  export type HeroSectionContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HeroSectionContentWhereInput
    orderBy?: HeroSectionContentOrderByWithAggregationInput | HeroSectionContentOrderByWithAggregationInput[]
    by: HeroSectionContentScalarFieldEnum[] | HeroSectionContentScalarFieldEnum
    having?: HeroSectionContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HeroSectionContentCountAggregateInputType | true
    _min?: HeroSectionContentMinAggregateInputType
    _max?: HeroSectionContentMaxAggregateInputType
  }

  export type HeroSectionContentGroupByOutputType = {
    id: string
    portraitImageSrc: string | null
    portraitImagePublicId: string | null
    portraitAlt: string | null
    sectionId: string
    createdAt: Date
    updatedAt: Date
    _count: HeroSectionContentCountAggregateOutputType | null
    _min: HeroSectionContentMinAggregateOutputType | null
    _max: HeroSectionContentMaxAggregateOutputType | null
  }

  type GetHeroSectionContentGroupByPayload<T extends HeroSectionContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HeroSectionContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HeroSectionContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HeroSectionContentGroupByOutputType[P]>
            : GetScalarType<T[P], HeroSectionContentGroupByOutputType[P]>
        }
      >
    >


  export type HeroSectionContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    portraitImageSrc?: boolean
    portraitImagePublicId?: boolean
    portraitAlt?: boolean
    sectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["heroSectionContent"]>



  export type HeroSectionContentSelectScalar = {
    id?: boolean
    portraitImageSrc?: boolean
    portraitImagePublicId?: boolean
    portraitAlt?: boolean
    sectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HeroSectionContentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "portraitImageSrc" | "portraitImagePublicId" | "portraitAlt" | "sectionId" | "createdAt" | "updatedAt", ExtArgs["result"]["heroSectionContent"]>
  export type HeroSectionContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }

  export type $HeroSectionContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HeroSectionContent"
    objects: {
      section: Prisma.$SectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      portraitImageSrc: string | null
      portraitImagePublicId: string | null
      portraitAlt: string | null
      sectionId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["heroSectionContent"]>
    composites: {}
  }

  type HeroSectionContentGetPayload<S extends boolean | null | undefined | HeroSectionContentDefaultArgs> = $Result.GetResult<Prisma.$HeroSectionContentPayload, S>

  type HeroSectionContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HeroSectionContentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HeroSectionContentCountAggregateInputType | true
    }

  export interface HeroSectionContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HeroSectionContent'], meta: { name: 'HeroSectionContent' } }
    /**
     * Find zero or one HeroSectionContent that matches the filter.
     * @param {HeroSectionContentFindUniqueArgs} args - Arguments to find a HeroSectionContent
     * @example
     * // Get one HeroSectionContent
     * const heroSectionContent = await prisma.heroSectionContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HeroSectionContentFindUniqueArgs>(args: SelectSubset<T, HeroSectionContentFindUniqueArgs<ExtArgs>>): Prisma__HeroSectionContentClient<$Result.GetResult<Prisma.$HeroSectionContentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HeroSectionContent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HeroSectionContentFindUniqueOrThrowArgs} args - Arguments to find a HeroSectionContent
     * @example
     * // Get one HeroSectionContent
     * const heroSectionContent = await prisma.heroSectionContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HeroSectionContentFindUniqueOrThrowArgs>(args: SelectSubset<T, HeroSectionContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HeroSectionContentClient<$Result.GetResult<Prisma.$HeroSectionContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HeroSectionContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSectionContentFindFirstArgs} args - Arguments to find a HeroSectionContent
     * @example
     * // Get one HeroSectionContent
     * const heroSectionContent = await prisma.heroSectionContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HeroSectionContentFindFirstArgs>(args?: SelectSubset<T, HeroSectionContentFindFirstArgs<ExtArgs>>): Prisma__HeroSectionContentClient<$Result.GetResult<Prisma.$HeroSectionContentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HeroSectionContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSectionContentFindFirstOrThrowArgs} args - Arguments to find a HeroSectionContent
     * @example
     * // Get one HeroSectionContent
     * const heroSectionContent = await prisma.heroSectionContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HeroSectionContentFindFirstOrThrowArgs>(args?: SelectSubset<T, HeroSectionContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__HeroSectionContentClient<$Result.GetResult<Prisma.$HeroSectionContentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HeroSectionContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSectionContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HeroSectionContents
     * const heroSectionContents = await prisma.heroSectionContent.findMany()
     * 
     * // Get first 10 HeroSectionContents
     * const heroSectionContents = await prisma.heroSectionContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const heroSectionContentWithIdOnly = await prisma.heroSectionContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HeroSectionContentFindManyArgs>(args?: SelectSubset<T, HeroSectionContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeroSectionContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HeroSectionContent.
     * @param {HeroSectionContentCreateArgs} args - Arguments to create a HeroSectionContent.
     * @example
     * // Create one HeroSectionContent
     * const HeroSectionContent = await prisma.heroSectionContent.create({
     *   data: {
     *     // ... data to create a HeroSectionContent
     *   }
     * })
     * 
     */
    create<T extends HeroSectionContentCreateArgs>(args: SelectSubset<T, HeroSectionContentCreateArgs<ExtArgs>>): Prisma__HeroSectionContentClient<$Result.GetResult<Prisma.$HeroSectionContentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HeroSectionContents.
     * @param {HeroSectionContentCreateManyArgs} args - Arguments to create many HeroSectionContents.
     * @example
     * // Create many HeroSectionContents
     * const heroSectionContent = await prisma.heroSectionContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HeroSectionContentCreateManyArgs>(args?: SelectSubset<T, HeroSectionContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HeroSectionContent.
     * @param {HeroSectionContentDeleteArgs} args - Arguments to delete one HeroSectionContent.
     * @example
     * // Delete one HeroSectionContent
     * const HeroSectionContent = await prisma.heroSectionContent.delete({
     *   where: {
     *     // ... filter to delete one HeroSectionContent
     *   }
     * })
     * 
     */
    delete<T extends HeroSectionContentDeleteArgs>(args: SelectSubset<T, HeroSectionContentDeleteArgs<ExtArgs>>): Prisma__HeroSectionContentClient<$Result.GetResult<Prisma.$HeroSectionContentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HeroSectionContent.
     * @param {HeroSectionContentUpdateArgs} args - Arguments to update one HeroSectionContent.
     * @example
     * // Update one HeroSectionContent
     * const heroSectionContent = await prisma.heroSectionContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HeroSectionContentUpdateArgs>(args: SelectSubset<T, HeroSectionContentUpdateArgs<ExtArgs>>): Prisma__HeroSectionContentClient<$Result.GetResult<Prisma.$HeroSectionContentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HeroSectionContents.
     * @param {HeroSectionContentDeleteManyArgs} args - Arguments to filter HeroSectionContents to delete.
     * @example
     * // Delete a few HeroSectionContents
     * const { count } = await prisma.heroSectionContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HeroSectionContentDeleteManyArgs>(args?: SelectSubset<T, HeroSectionContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HeroSectionContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSectionContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HeroSectionContents
     * const heroSectionContent = await prisma.heroSectionContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HeroSectionContentUpdateManyArgs>(args: SelectSubset<T, HeroSectionContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HeroSectionContent.
     * @param {HeroSectionContentUpsertArgs} args - Arguments to update or create a HeroSectionContent.
     * @example
     * // Update or create a HeroSectionContent
     * const heroSectionContent = await prisma.heroSectionContent.upsert({
     *   create: {
     *     // ... data to create a HeroSectionContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HeroSectionContent we want to update
     *   }
     * })
     */
    upsert<T extends HeroSectionContentUpsertArgs>(args: SelectSubset<T, HeroSectionContentUpsertArgs<ExtArgs>>): Prisma__HeroSectionContentClient<$Result.GetResult<Prisma.$HeroSectionContentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HeroSectionContents that matches the filter.
     * @param {HeroSectionContentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const heroSectionContent = await prisma.heroSectionContent.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: HeroSectionContentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a HeroSectionContent.
     * @param {HeroSectionContentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const heroSectionContent = await prisma.heroSectionContent.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: HeroSectionContentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of HeroSectionContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSectionContentCountArgs} args - Arguments to filter HeroSectionContents to count.
     * @example
     * // Count the number of HeroSectionContents
     * const count = await prisma.heroSectionContent.count({
     *   where: {
     *     // ... the filter for the HeroSectionContents we want to count
     *   }
     * })
    **/
    count<T extends HeroSectionContentCountArgs>(
      args?: Subset<T, HeroSectionContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HeroSectionContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HeroSectionContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSectionContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HeroSectionContentAggregateArgs>(args: Subset<T, HeroSectionContentAggregateArgs>): Prisma.PrismaPromise<GetHeroSectionContentAggregateType<T>>

    /**
     * Group by HeroSectionContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSectionContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HeroSectionContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HeroSectionContentGroupByArgs['orderBy'] }
        : { orderBy?: HeroSectionContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HeroSectionContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHeroSectionContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HeroSectionContent model
   */
  readonly fields: HeroSectionContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HeroSectionContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HeroSectionContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HeroSectionContent model
   */
  interface HeroSectionContentFieldRefs {
    readonly id: FieldRef<"HeroSectionContent", 'String'>
    readonly portraitImageSrc: FieldRef<"HeroSectionContent", 'String'>
    readonly portraitImagePublicId: FieldRef<"HeroSectionContent", 'String'>
    readonly portraitAlt: FieldRef<"HeroSectionContent", 'String'>
    readonly sectionId: FieldRef<"HeroSectionContent", 'String'>
    readonly createdAt: FieldRef<"HeroSectionContent", 'DateTime'>
    readonly updatedAt: FieldRef<"HeroSectionContent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HeroSectionContent findUnique
   */
  export type HeroSectionContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSectionContent
     */
    select?: HeroSectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSectionContent
     */
    omit?: HeroSectionContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroSectionContentInclude<ExtArgs> | null
    /**
     * Filter, which HeroSectionContent to fetch.
     */
    where: HeroSectionContentWhereUniqueInput
  }

  /**
   * HeroSectionContent findUniqueOrThrow
   */
  export type HeroSectionContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSectionContent
     */
    select?: HeroSectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSectionContent
     */
    omit?: HeroSectionContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroSectionContentInclude<ExtArgs> | null
    /**
     * Filter, which HeroSectionContent to fetch.
     */
    where: HeroSectionContentWhereUniqueInput
  }

  /**
   * HeroSectionContent findFirst
   */
  export type HeroSectionContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSectionContent
     */
    select?: HeroSectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSectionContent
     */
    omit?: HeroSectionContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroSectionContentInclude<ExtArgs> | null
    /**
     * Filter, which HeroSectionContent to fetch.
     */
    where?: HeroSectionContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroSectionContents to fetch.
     */
    orderBy?: HeroSectionContentOrderByWithRelationInput | HeroSectionContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeroSectionContents.
     */
    cursor?: HeroSectionContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroSectionContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroSectionContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeroSectionContents.
     */
    distinct?: HeroSectionContentScalarFieldEnum | HeroSectionContentScalarFieldEnum[]
  }

  /**
   * HeroSectionContent findFirstOrThrow
   */
  export type HeroSectionContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSectionContent
     */
    select?: HeroSectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSectionContent
     */
    omit?: HeroSectionContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroSectionContentInclude<ExtArgs> | null
    /**
     * Filter, which HeroSectionContent to fetch.
     */
    where?: HeroSectionContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroSectionContents to fetch.
     */
    orderBy?: HeroSectionContentOrderByWithRelationInput | HeroSectionContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeroSectionContents.
     */
    cursor?: HeroSectionContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroSectionContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroSectionContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeroSectionContents.
     */
    distinct?: HeroSectionContentScalarFieldEnum | HeroSectionContentScalarFieldEnum[]
  }

  /**
   * HeroSectionContent findMany
   */
  export type HeroSectionContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSectionContent
     */
    select?: HeroSectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSectionContent
     */
    omit?: HeroSectionContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroSectionContentInclude<ExtArgs> | null
    /**
     * Filter, which HeroSectionContents to fetch.
     */
    where?: HeroSectionContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroSectionContents to fetch.
     */
    orderBy?: HeroSectionContentOrderByWithRelationInput | HeroSectionContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HeroSectionContents.
     */
    cursor?: HeroSectionContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroSectionContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroSectionContents.
     */
    skip?: number
    distinct?: HeroSectionContentScalarFieldEnum | HeroSectionContentScalarFieldEnum[]
  }

  /**
   * HeroSectionContent create
   */
  export type HeroSectionContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSectionContent
     */
    select?: HeroSectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSectionContent
     */
    omit?: HeroSectionContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroSectionContentInclude<ExtArgs> | null
    /**
     * The data needed to create a HeroSectionContent.
     */
    data: XOR<HeroSectionContentCreateInput, HeroSectionContentUncheckedCreateInput>
  }

  /**
   * HeroSectionContent createMany
   */
  export type HeroSectionContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HeroSectionContents.
     */
    data: HeroSectionContentCreateManyInput | HeroSectionContentCreateManyInput[]
  }

  /**
   * HeroSectionContent update
   */
  export type HeroSectionContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSectionContent
     */
    select?: HeroSectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSectionContent
     */
    omit?: HeroSectionContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroSectionContentInclude<ExtArgs> | null
    /**
     * The data needed to update a HeroSectionContent.
     */
    data: XOR<HeroSectionContentUpdateInput, HeroSectionContentUncheckedUpdateInput>
    /**
     * Choose, which HeroSectionContent to update.
     */
    where: HeroSectionContentWhereUniqueInput
  }

  /**
   * HeroSectionContent updateMany
   */
  export type HeroSectionContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HeroSectionContents.
     */
    data: XOR<HeroSectionContentUpdateManyMutationInput, HeroSectionContentUncheckedUpdateManyInput>
    /**
     * Filter which HeroSectionContents to update
     */
    where?: HeroSectionContentWhereInput
    /**
     * Limit how many HeroSectionContents to update.
     */
    limit?: number
  }

  /**
   * HeroSectionContent upsert
   */
  export type HeroSectionContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSectionContent
     */
    select?: HeroSectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSectionContent
     */
    omit?: HeroSectionContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroSectionContentInclude<ExtArgs> | null
    /**
     * The filter to search for the HeroSectionContent to update in case it exists.
     */
    where: HeroSectionContentWhereUniqueInput
    /**
     * In case the HeroSectionContent found by the `where` argument doesn't exist, create a new HeroSectionContent with this data.
     */
    create: XOR<HeroSectionContentCreateInput, HeroSectionContentUncheckedCreateInput>
    /**
     * In case the HeroSectionContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HeroSectionContentUpdateInput, HeroSectionContentUncheckedUpdateInput>
  }

  /**
   * HeroSectionContent delete
   */
  export type HeroSectionContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSectionContent
     */
    select?: HeroSectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSectionContent
     */
    omit?: HeroSectionContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroSectionContentInclude<ExtArgs> | null
    /**
     * Filter which HeroSectionContent to delete.
     */
    where: HeroSectionContentWhereUniqueInput
  }

  /**
   * HeroSectionContent deleteMany
   */
  export type HeroSectionContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeroSectionContents to delete
     */
    where?: HeroSectionContentWhereInput
    /**
     * Limit how many HeroSectionContents to delete.
     */
    limit?: number
  }

  /**
   * HeroSectionContent findRaw
   */
  export type HeroSectionContentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * HeroSectionContent aggregateRaw
   */
  export type HeroSectionContentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * HeroSectionContent without action
   */
  export type HeroSectionContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSectionContent
     */
    select?: HeroSectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSectionContent
     */
    omit?: HeroSectionContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroSectionContentInclude<ExtArgs> | null
  }


  /**
   * Model EducationItem
   */

  export type AggregateEducationItem = {
    _count: EducationItemCountAggregateOutputType | null
    _avg: EducationItemAvgAggregateOutputType | null
    _sum: EducationItemSumAggregateOutputType | null
    _min: EducationItemMinAggregateOutputType | null
    _max: EducationItemMaxAggregateOutputType | null
  }

  export type EducationItemAvgAggregateOutputType = {
    order: number | null
  }

  export type EducationItemSumAggregateOutputType = {
    order: number | null
  }

  export type EducationItemMinAggregateOutputType = {
    id: string | null
    institution: string | null
    degree: string | null
    period: string | null
    description: string | null
    order: number | null
    sectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EducationItemMaxAggregateOutputType = {
    id: string | null
    institution: string | null
    degree: string | null
    period: string | null
    description: string | null
    order: number | null
    sectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EducationItemCountAggregateOutputType = {
    id: number
    institution: number
    degree: number
    period: number
    description: number
    order: number
    sectionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EducationItemAvgAggregateInputType = {
    order?: true
  }

  export type EducationItemSumAggregateInputType = {
    order?: true
  }

  export type EducationItemMinAggregateInputType = {
    id?: true
    institution?: true
    degree?: true
    period?: true
    description?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EducationItemMaxAggregateInputType = {
    id?: true
    institution?: true
    degree?: true
    period?: true
    description?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EducationItemCountAggregateInputType = {
    id?: true
    institution?: true
    degree?: true
    period?: true
    description?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EducationItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EducationItem to aggregate.
     */
    where?: EducationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationItems to fetch.
     */
    orderBy?: EducationItemOrderByWithRelationInput | EducationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EducationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EducationItems
    **/
    _count?: true | EducationItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EducationItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EducationItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EducationItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EducationItemMaxAggregateInputType
  }

  export type GetEducationItemAggregateType<T extends EducationItemAggregateArgs> = {
        [P in keyof T & keyof AggregateEducationItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEducationItem[P]>
      : GetScalarType<T[P], AggregateEducationItem[P]>
  }




  export type EducationItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationItemWhereInput
    orderBy?: EducationItemOrderByWithAggregationInput | EducationItemOrderByWithAggregationInput[]
    by: EducationItemScalarFieldEnum[] | EducationItemScalarFieldEnum
    having?: EducationItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EducationItemCountAggregateInputType | true
    _avg?: EducationItemAvgAggregateInputType
    _sum?: EducationItemSumAggregateInputType
    _min?: EducationItemMinAggregateInputType
    _max?: EducationItemMaxAggregateInputType
  }

  export type EducationItemGroupByOutputType = {
    id: string
    institution: string
    degree: string | null
    period: string
    description: string | null
    order: number
    sectionId: string
    createdAt: Date
    updatedAt: Date
    _count: EducationItemCountAggregateOutputType | null
    _avg: EducationItemAvgAggregateOutputType | null
    _sum: EducationItemSumAggregateOutputType | null
    _min: EducationItemMinAggregateOutputType | null
    _max: EducationItemMaxAggregateOutputType | null
  }

  type GetEducationItemGroupByPayload<T extends EducationItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EducationItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EducationItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EducationItemGroupByOutputType[P]>
            : GetScalarType<T[P], EducationItemGroupByOutputType[P]>
        }
      >
    >


  export type EducationItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institution?: boolean
    degree?: boolean
    period?: boolean
    description?: boolean
    order?: boolean
    sectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
    images?: boolean | EducationItem$imagesArgs<ExtArgs>
    _count?: boolean | EducationItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["educationItem"]>



  export type EducationItemSelectScalar = {
    id?: boolean
    institution?: boolean
    degree?: boolean
    period?: boolean
    description?: boolean
    order?: boolean
    sectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EducationItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institution" | "degree" | "period" | "description" | "order" | "sectionId" | "createdAt" | "updatedAt", ExtArgs["result"]["educationItem"]>
  export type EducationItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
    images?: boolean | EducationItem$imagesArgs<ExtArgs>
    _count?: boolean | EducationItemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EducationItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EducationItem"
    objects: {
      section: Prisma.$SectionPayload<ExtArgs>
      images: Prisma.$EducationImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      institution: string
      degree: string | null
      period: string
      description: string | null
      order: number
      sectionId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["educationItem"]>
    composites: {}
  }

  type EducationItemGetPayload<S extends boolean | null | undefined | EducationItemDefaultArgs> = $Result.GetResult<Prisma.$EducationItemPayload, S>

  type EducationItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EducationItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EducationItemCountAggregateInputType | true
    }

  export interface EducationItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EducationItem'], meta: { name: 'EducationItem' } }
    /**
     * Find zero or one EducationItem that matches the filter.
     * @param {EducationItemFindUniqueArgs} args - Arguments to find a EducationItem
     * @example
     * // Get one EducationItem
     * const educationItem = await prisma.educationItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EducationItemFindUniqueArgs>(args: SelectSubset<T, EducationItemFindUniqueArgs<ExtArgs>>): Prisma__EducationItemClient<$Result.GetResult<Prisma.$EducationItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EducationItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EducationItemFindUniqueOrThrowArgs} args - Arguments to find a EducationItem
     * @example
     * // Get one EducationItem
     * const educationItem = await prisma.educationItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EducationItemFindUniqueOrThrowArgs>(args: SelectSubset<T, EducationItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EducationItemClient<$Result.GetResult<Prisma.$EducationItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EducationItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationItemFindFirstArgs} args - Arguments to find a EducationItem
     * @example
     * // Get one EducationItem
     * const educationItem = await prisma.educationItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EducationItemFindFirstArgs>(args?: SelectSubset<T, EducationItemFindFirstArgs<ExtArgs>>): Prisma__EducationItemClient<$Result.GetResult<Prisma.$EducationItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EducationItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationItemFindFirstOrThrowArgs} args - Arguments to find a EducationItem
     * @example
     * // Get one EducationItem
     * const educationItem = await prisma.educationItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EducationItemFindFirstOrThrowArgs>(args?: SelectSubset<T, EducationItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__EducationItemClient<$Result.GetResult<Prisma.$EducationItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EducationItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EducationItems
     * const educationItems = await prisma.educationItem.findMany()
     * 
     * // Get first 10 EducationItems
     * const educationItems = await prisma.educationItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const educationItemWithIdOnly = await prisma.educationItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EducationItemFindManyArgs>(args?: SelectSubset<T, EducationItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EducationItem.
     * @param {EducationItemCreateArgs} args - Arguments to create a EducationItem.
     * @example
     * // Create one EducationItem
     * const EducationItem = await prisma.educationItem.create({
     *   data: {
     *     // ... data to create a EducationItem
     *   }
     * })
     * 
     */
    create<T extends EducationItemCreateArgs>(args: SelectSubset<T, EducationItemCreateArgs<ExtArgs>>): Prisma__EducationItemClient<$Result.GetResult<Prisma.$EducationItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EducationItems.
     * @param {EducationItemCreateManyArgs} args - Arguments to create many EducationItems.
     * @example
     * // Create many EducationItems
     * const educationItem = await prisma.educationItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EducationItemCreateManyArgs>(args?: SelectSubset<T, EducationItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EducationItem.
     * @param {EducationItemDeleteArgs} args - Arguments to delete one EducationItem.
     * @example
     * // Delete one EducationItem
     * const EducationItem = await prisma.educationItem.delete({
     *   where: {
     *     // ... filter to delete one EducationItem
     *   }
     * })
     * 
     */
    delete<T extends EducationItemDeleteArgs>(args: SelectSubset<T, EducationItemDeleteArgs<ExtArgs>>): Prisma__EducationItemClient<$Result.GetResult<Prisma.$EducationItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EducationItem.
     * @param {EducationItemUpdateArgs} args - Arguments to update one EducationItem.
     * @example
     * // Update one EducationItem
     * const educationItem = await prisma.educationItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EducationItemUpdateArgs>(args: SelectSubset<T, EducationItemUpdateArgs<ExtArgs>>): Prisma__EducationItemClient<$Result.GetResult<Prisma.$EducationItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EducationItems.
     * @param {EducationItemDeleteManyArgs} args - Arguments to filter EducationItems to delete.
     * @example
     * // Delete a few EducationItems
     * const { count } = await prisma.educationItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EducationItemDeleteManyArgs>(args?: SelectSubset<T, EducationItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EducationItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EducationItems
     * const educationItem = await prisma.educationItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EducationItemUpdateManyArgs>(args: SelectSubset<T, EducationItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EducationItem.
     * @param {EducationItemUpsertArgs} args - Arguments to update or create a EducationItem.
     * @example
     * // Update or create a EducationItem
     * const educationItem = await prisma.educationItem.upsert({
     *   create: {
     *     // ... data to create a EducationItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EducationItem we want to update
     *   }
     * })
     */
    upsert<T extends EducationItemUpsertArgs>(args: SelectSubset<T, EducationItemUpsertArgs<ExtArgs>>): Prisma__EducationItemClient<$Result.GetResult<Prisma.$EducationItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EducationItems that matches the filter.
     * @param {EducationItemFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const educationItem = await prisma.educationItem.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: EducationItemFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a EducationItem.
     * @param {EducationItemAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const educationItem = await prisma.educationItem.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: EducationItemAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of EducationItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationItemCountArgs} args - Arguments to filter EducationItems to count.
     * @example
     * // Count the number of EducationItems
     * const count = await prisma.educationItem.count({
     *   where: {
     *     // ... the filter for the EducationItems we want to count
     *   }
     * })
    **/
    count<T extends EducationItemCountArgs>(
      args?: Subset<T, EducationItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EducationItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EducationItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EducationItemAggregateArgs>(args: Subset<T, EducationItemAggregateArgs>): Prisma.PrismaPromise<GetEducationItemAggregateType<T>>

    /**
     * Group by EducationItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EducationItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EducationItemGroupByArgs['orderBy'] }
        : { orderBy?: EducationItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EducationItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEducationItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EducationItem model
   */
  readonly fields: EducationItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EducationItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EducationItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    images<T extends EducationItem$imagesArgs<ExtArgs> = {}>(args?: Subset<T, EducationItem$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EducationItem model
   */
  interface EducationItemFieldRefs {
    readonly id: FieldRef<"EducationItem", 'String'>
    readonly institution: FieldRef<"EducationItem", 'String'>
    readonly degree: FieldRef<"EducationItem", 'String'>
    readonly period: FieldRef<"EducationItem", 'String'>
    readonly description: FieldRef<"EducationItem", 'String'>
    readonly order: FieldRef<"EducationItem", 'Int'>
    readonly sectionId: FieldRef<"EducationItem", 'String'>
    readonly createdAt: FieldRef<"EducationItem", 'DateTime'>
    readonly updatedAt: FieldRef<"EducationItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EducationItem findUnique
   */
  export type EducationItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationItem
     */
    select?: EducationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationItem
     */
    omit?: EducationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationItemInclude<ExtArgs> | null
    /**
     * Filter, which EducationItem to fetch.
     */
    where: EducationItemWhereUniqueInput
  }

  /**
   * EducationItem findUniqueOrThrow
   */
  export type EducationItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationItem
     */
    select?: EducationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationItem
     */
    omit?: EducationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationItemInclude<ExtArgs> | null
    /**
     * Filter, which EducationItem to fetch.
     */
    where: EducationItemWhereUniqueInput
  }

  /**
   * EducationItem findFirst
   */
  export type EducationItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationItem
     */
    select?: EducationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationItem
     */
    omit?: EducationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationItemInclude<ExtArgs> | null
    /**
     * Filter, which EducationItem to fetch.
     */
    where?: EducationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationItems to fetch.
     */
    orderBy?: EducationItemOrderByWithRelationInput | EducationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EducationItems.
     */
    cursor?: EducationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EducationItems.
     */
    distinct?: EducationItemScalarFieldEnum | EducationItemScalarFieldEnum[]
  }

  /**
   * EducationItem findFirstOrThrow
   */
  export type EducationItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationItem
     */
    select?: EducationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationItem
     */
    omit?: EducationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationItemInclude<ExtArgs> | null
    /**
     * Filter, which EducationItem to fetch.
     */
    where?: EducationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationItems to fetch.
     */
    orderBy?: EducationItemOrderByWithRelationInput | EducationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EducationItems.
     */
    cursor?: EducationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EducationItems.
     */
    distinct?: EducationItemScalarFieldEnum | EducationItemScalarFieldEnum[]
  }

  /**
   * EducationItem findMany
   */
  export type EducationItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationItem
     */
    select?: EducationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationItem
     */
    omit?: EducationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationItemInclude<ExtArgs> | null
    /**
     * Filter, which EducationItems to fetch.
     */
    where?: EducationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationItems to fetch.
     */
    orderBy?: EducationItemOrderByWithRelationInput | EducationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EducationItems.
     */
    cursor?: EducationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationItems.
     */
    skip?: number
    distinct?: EducationItemScalarFieldEnum | EducationItemScalarFieldEnum[]
  }

  /**
   * EducationItem create
   */
  export type EducationItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationItem
     */
    select?: EducationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationItem
     */
    omit?: EducationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationItemInclude<ExtArgs> | null
    /**
     * The data needed to create a EducationItem.
     */
    data: XOR<EducationItemCreateInput, EducationItemUncheckedCreateInput>
  }

  /**
   * EducationItem createMany
   */
  export type EducationItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EducationItems.
     */
    data: EducationItemCreateManyInput | EducationItemCreateManyInput[]
  }

  /**
   * EducationItem update
   */
  export type EducationItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationItem
     */
    select?: EducationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationItem
     */
    omit?: EducationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationItemInclude<ExtArgs> | null
    /**
     * The data needed to update a EducationItem.
     */
    data: XOR<EducationItemUpdateInput, EducationItemUncheckedUpdateInput>
    /**
     * Choose, which EducationItem to update.
     */
    where: EducationItemWhereUniqueInput
  }

  /**
   * EducationItem updateMany
   */
  export type EducationItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EducationItems.
     */
    data: XOR<EducationItemUpdateManyMutationInput, EducationItemUncheckedUpdateManyInput>
    /**
     * Filter which EducationItems to update
     */
    where?: EducationItemWhereInput
    /**
     * Limit how many EducationItems to update.
     */
    limit?: number
  }

  /**
   * EducationItem upsert
   */
  export type EducationItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationItem
     */
    select?: EducationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationItem
     */
    omit?: EducationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationItemInclude<ExtArgs> | null
    /**
     * The filter to search for the EducationItem to update in case it exists.
     */
    where: EducationItemWhereUniqueInput
    /**
     * In case the EducationItem found by the `where` argument doesn't exist, create a new EducationItem with this data.
     */
    create: XOR<EducationItemCreateInput, EducationItemUncheckedCreateInput>
    /**
     * In case the EducationItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EducationItemUpdateInput, EducationItemUncheckedUpdateInput>
  }

  /**
   * EducationItem delete
   */
  export type EducationItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationItem
     */
    select?: EducationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationItem
     */
    omit?: EducationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationItemInclude<ExtArgs> | null
    /**
     * Filter which EducationItem to delete.
     */
    where: EducationItemWhereUniqueInput
  }

  /**
   * EducationItem deleteMany
   */
  export type EducationItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EducationItems to delete
     */
    where?: EducationItemWhereInput
    /**
     * Limit how many EducationItems to delete.
     */
    limit?: number
  }

  /**
   * EducationItem findRaw
   */
  export type EducationItemFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * EducationItem aggregateRaw
   */
  export type EducationItemAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * EducationItem.images
   */
  export type EducationItem$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationImage
     */
    select?: EducationImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationImage
     */
    omit?: EducationImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationImageInclude<ExtArgs> | null
    where?: EducationImageWhereInput
    orderBy?: EducationImageOrderByWithRelationInput | EducationImageOrderByWithRelationInput[]
    cursor?: EducationImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EducationImageScalarFieldEnum | EducationImageScalarFieldEnum[]
  }

  /**
   * EducationItem without action
   */
  export type EducationItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationItem
     */
    select?: EducationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationItem
     */
    omit?: EducationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationItemInclude<ExtArgs> | null
  }


  /**
   * Model EducationImage
   */

  export type AggregateEducationImage = {
    _count: EducationImageCountAggregateOutputType | null
    _avg: EducationImageAvgAggregateOutputType | null
    _sum: EducationImageSumAggregateOutputType | null
    _min: EducationImageMinAggregateOutputType | null
    _max: EducationImageMaxAggregateOutputType | null
  }

  export type EducationImageAvgAggregateOutputType = {
    order: number | null
  }

  export type EducationImageSumAggregateOutputType = {
    order: number | null
  }

  export type EducationImageMinAggregateOutputType = {
    id: string | null
    src: string | null
    imagePublicId: string | null
    alt: string | null
    caption: string | null
    order: number | null
    educationItemId: string | null
    createdAt: Date | null
  }

  export type EducationImageMaxAggregateOutputType = {
    id: string | null
    src: string | null
    imagePublicId: string | null
    alt: string | null
    caption: string | null
    order: number | null
    educationItemId: string | null
    createdAt: Date | null
  }

  export type EducationImageCountAggregateOutputType = {
    id: number
    src: number
    imagePublicId: number
    alt: number
    caption: number
    order: number
    educationItemId: number
    createdAt: number
    _all: number
  }


  export type EducationImageAvgAggregateInputType = {
    order?: true
  }

  export type EducationImageSumAggregateInputType = {
    order?: true
  }

  export type EducationImageMinAggregateInputType = {
    id?: true
    src?: true
    imagePublicId?: true
    alt?: true
    caption?: true
    order?: true
    educationItemId?: true
    createdAt?: true
  }

  export type EducationImageMaxAggregateInputType = {
    id?: true
    src?: true
    imagePublicId?: true
    alt?: true
    caption?: true
    order?: true
    educationItemId?: true
    createdAt?: true
  }

  export type EducationImageCountAggregateInputType = {
    id?: true
    src?: true
    imagePublicId?: true
    alt?: true
    caption?: true
    order?: true
    educationItemId?: true
    createdAt?: true
    _all?: true
  }

  export type EducationImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EducationImage to aggregate.
     */
    where?: EducationImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationImages to fetch.
     */
    orderBy?: EducationImageOrderByWithRelationInput | EducationImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EducationImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EducationImages
    **/
    _count?: true | EducationImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EducationImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EducationImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EducationImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EducationImageMaxAggregateInputType
  }

  export type GetEducationImageAggregateType<T extends EducationImageAggregateArgs> = {
        [P in keyof T & keyof AggregateEducationImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEducationImage[P]>
      : GetScalarType<T[P], AggregateEducationImage[P]>
  }




  export type EducationImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationImageWhereInput
    orderBy?: EducationImageOrderByWithAggregationInput | EducationImageOrderByWithAggregationInput[]
    by: EducationImageScalarFieldEnum[] | EducationImageScalarFieldEnum
    having?: EducationImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EducationImageCountAggregateInputType | true
    _avg?: EducationImageAvgAggregateInputType
    _sum?: EducationImageSumAggregateInputType
    _min?: EducationImageMinAggregateInputType
    _max?: EducationImageMaxAggregateInputType
  }

  export type EducationImageGroupByOutputType = {
    id: string
    src: string
    imagePublicId: string | null
    alt: string | null
    caption: string | null
    order: number
    educationItemId: string
    createdAt: Date
    _count: EducationImageCountAggregateOutputType | null
    _avg: EducationImageAvgAggregateOutputType | null
    _sum: EducationImageSumAggregateOutputType | null
    _min: EducationImageMinAggregateOutputType | null
    _max: EducationImageMaxAggregateOutputType | null
  }

  type GetEducationImageGroupByPayload<T extends EducationImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EducationImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EducationImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EducationImageGroupByOutputType[P]>
            : GetScalarType<T[P], EducationImageGroupByOutputType[P]>
        }
      >
    >


  export type EducationImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    src?: boolean
    imagePublicId?: boolean
    alt?: boolean
    caption?: boolean
    order?: boolean
    educationItemId?: boolean
    createdAt?: boolean
    educationItem?: boolean | EducationItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["educationImage"]>



  export type EducationImageSelectScalar = {
    id?: boolean
    src?: boolean
    imagePublicId?: boolean
    alt?: boolean
    caption?: boolean
    order?: boolean
    educationItemId?: boolean
    createdAt?: boolean
  }

  export type EducationImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "src" | "imagePublicId" | "alt" | "caption" | "order" | "educationItemId" | "createdAt", ExtArgs["result"]["educationImage"]>
  export type EducationImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    educationItem?: boolean | EducationItemDefaultArgs<ExtArgs>
  }

  export type $EducationImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EducationImage"
    objects: {
      educationItem: Prisma.$EducationItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      src: string
      imagePublicId: string | null
      alt: string | null
      caption: string | null
      order: number
      educationItemId: string
      createdAt: Date
    }, ExtArgs["result"]["educationImage"]>
    composites: {}
  }

  type EducationImageGetPayload<S extends boolean | null | undefined | EducationImageDefaultArgs> = $Result.GetResult<Prisma.$EducationImagePayload, S>

  type EducationImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EducationImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EducationImageCountAggregateInputType | true
    }

  export interface EducationImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EducationImage'], meta: { name: 'EducationImage' } }
    /**
     * Find zero or one EducationImage that matches the filter.
     * @param {EducationImageFindUniqueArgs} args - Arguments to find a EducationImage
     * @example
     * // Get one EducationImage
     * const educationImage = await prisma.educationImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EducationImageFindUniqueArgs>(args: SelectSubset<T, EducationImageFindUniqueArgs<ExtArgs>>): Prisma__EducationImageClient<$Result.GetResult<Prisma.$EducationImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EducationImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EducationImageFindUniqueOrThrowArgs} args - Arguments to find a EducationImage
     * @example
     * // Get one EducationImage
     * const educationImage = await prisma.educationImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EducationImageFindUniqueOrThrowArgs>(args: SelectSubset<T, EducationImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EducationImageClient<$Result.GetResult<Prisma.$EducationImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EducationImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationImageFindFirstArgs} args - Arguments to find a EducationImage
     * @example
     * // Get one EducationImage
     * const educationImage = await prisma.educationImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EducationImageFindFirstArgs>(args?: SelectSubset<T, EducationImageFindFirstArgs<ExtArgs>>): Prisma__EducationImageClient<$Result.GetResult<Prisma.$EducationImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EducationImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationImageFindFirstOrThrowArgs} args - Arguments to find a EducationImage
     * @example
     * // Get one EducationImage
     * const educationImage = await prisma.educationImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EducationImageFindFirstOrThrowArgs>(args?: SelectSubset<T, EducationImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__EducationImageClient<$Result.GetResult<Prisma.$EducationImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EducationImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EducationImages
     * const educationImages = await prisma.educationImage.findMany()
     * 
     * // Get first 10 EducationImages
     * const educationImages = await prisma.educationImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const educationImageWithIdOnly = await prisma.educationImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EducationImageFindManyArgs>(args?: SelectSubset<T, EducationImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EducationImage.
     * @param {EducationImageCreateArgs} args - Arguments to create a EducationImage.
     * @example
     * // Create one EducationImage
     * const EducationImage = await prisma.educationImage.create({
     *   data: {
     *     // ... data to create a EducationImage
     *   }
     * })
     * 
     */
    create<T extends EducationImageCreateArgs>(args: SelectSubset<T, EducationImageCreateArgs<ExtArgs>>): Prisma__EducationImageClient<$Result.GetResult<Prisma.$EducationImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EducationImages.
     * @param {EducationImageCreateManyArgs} args - Arguments to create many EducationImages.
     * @example
     * // Create many EducationImages
     * const educationImage = await prisma.educationImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EducationImageCreateManyArgs>(args?: SelectSubset<T, EducationImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EducationImage.
     * @param {EducationImageDeleteArgs} args - Arguments to delete one EducationImage.
     * @example
     * // Delete one EducationImage
     * const EducationImage = await prisma.educationImage.delete({
     *   where: {
     *     // ... filter to delete one EducationImage
     *   }
     * })
     * 
     */
    delete<T extends EducationImageDeleteArgs>(args: SelectSubset<T, EducationImageDeleteArgs<ExtArgs>>): Prisma__EducationImageClient<$Result.GetResult<Prisma.$EducationImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EducationImage.
     * @param {EducationImageUpdateArgs} args - Arguments to update one EducationImage.
     * @example
     * // Update one EducationImage
     * const educationImage = await prisma.educationImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EducationImageUpdateArgs>(args: SelectSubset<T, EducationImageUpdateArgs<ExtArgs>>): Prisma__EducationImageClient<$Result.GetResult<Prisma.$EducationImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EducationImages.
     * @param {EducationImageDeleteManyArgs} args - Arguments to filter EducationImages to delete.
     * @example
     * // Delete a few EducationImages
     * const { count } = await prisma.educationImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EducationImageDeleteManyArgs>(args?: SelectSubset<T, EducationImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EducationImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EducationImages
     * const educationImage = await prisma.educationImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EducationImageUpdateManyArgs>(args: SelectSubset<T, EducationImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EducationImage.
     * @param {EducationImageUpsertArgs} args - Arguments to update or create a EducationImage.
     * @example
     * // Update or create a EducationImage
     * const educationImage = await prisma.educationImage.upsert({
     *   create: {
     *     // ... data to create a EducationImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EducationImage we want to update
     *   }
     * })
     */
    upsert<T extends EducationImageUpsertArgs>(args: SelectSubset<T, EducationImageUpsertArgs<ExtArgs>>): Prisma__EducationImageClient<$Result.GetResult<Prisma.$EducationImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EducationImages that matches the filter.
     * @param {EducationImageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const educationImage = await prisma.educationImage.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: EducationImageFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a EducationImage.
     * @param {EducationImageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const educationImage = await prisma.educationImage.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: EducationImageAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of EducationImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationImageCountArgs} args - Arguments to filter EducationImages to count.
     * @example
     * // Count the number of EducationImages
     * const count = await prisma.educationImage.count({
     *   where: {
     *     // ... the filter for the EducationImages we want to count
     *   }
     * })
    **/
    count<T extends EducationImageCountArgs>(
      args?: Subset<T, EducationImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EducationImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EducationImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EducationImageAggregateArgs>(args: Subset<T, EducationImageAggregateArgs>): Prisma.PrismaPromise<GetEducationImageAggregateType<T>>

    /**
     * Group by EducationImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EducationImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EducationImageGroupByArgs['orderBy'] }
        : { orderBy?: EducationImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EducationImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEducationImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EducationImage model
   */
  readonly fields: EducationImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EducationImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EducationImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    educationItem<T extends EducationItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EducationItemDefaultArgs<ExtArgs>>): Prisma__EducationItemClient<$Result.GetResult<Prisma.$EducationItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EducationImage model
   */
  interface EducationImageFieldRefs {
    readonly id: FieldRef<"EducationImage", 'String'>
    readonly src: FieldRef<"EducationImage", 'String'>
    readonly imagePublicId: FieldRef<"EducationImage", 'String'>
    readonly alt: FieldRef<"EducationImage", 'String'>
    readonly caption: FieldRef<"EducationImage", 'String'>
    readonly order: FieldRef<"EducationImage", 'Int'>
    readonly educationItemId: FieldRef<"EducationImage", 'String'>
    readonly createdAt: FieldRef<"EducationImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EducationImage findUnique
   */
  export type EducationImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationImage
     */
    select?: EducationImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationImage
     */
    omit?: EducationImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationImageInclude<ExtArgs> | null
    /**
     * Filter, which EducationImage to fetch.
     */
    where: EducationImageWhereUniqueInput
  }

  /**
   * EducationImage findUniqueOrThrow
   */
  export type EducationImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationImage
     */
    select?: EducationImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationImage
     */
    omit?: EducationImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationImageInclude<ExtArgs> | null
    /**
     * Filter, which EducationImage to fetch.
     */
    where: EducationImageWhereUniqueInput
  }

  /**
   * EducationImage findFirst
   */
  export type EducationImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationImage
     */
    select?: EducationImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationImage
     */
    omit?: EducationImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationImageInclude<ExtArgs> | null
    /**
     * Filter, which EducationImage to fetch.
     */
    where?: EducationImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationImages to fetch.
     */
    orderBy?: EducationImageOrderByWithRelationInput | EducationImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EducationImages.
     */
    cursor?: EducationImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EducationImages.
     */
    distinct?: EducationImageScalarFieldEnum | EducationImageScalarFieldEnum[]
  }

  /**
   * EducationImage findFirstOrThrow
   */
  export type EducationImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationImage
     */
    select?: EducationImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationImage
     */
    omit?: EducationImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationImageInclude<ExtArgs> | null
    /**
     * Filter, which EducationImage to fetch.
     */
    where?: EducationImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationImages to fetch.
     */
    orderBy?: EducationImageOrderByWithRelationInput | EducationImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EducationImages.
     */
    cursor?: EducationImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EducationImages.
     */
    distinct?: EducationImageScalarFieldEnum | EducationImageScalarFieldEnum[]
  }

  /**
   * EducationImage findMany
   */
  export type EducationImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationImage
     */
    select?: EducationImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationImage
     */
    omit?: EducationImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationImageInclude<ExtArgs> | null
    /**
     * Filter, which EducationImages to fetch.
     */
    where?: EducationImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationImages to fetch.
     */
    orderBy?: EducationImageOrderByWithRelationInput | EducationImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EducationImages.
     */
    cursor?: EducationImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationImages.
     */
    skip?: number
    distinct?: EducationImageScalarFieldEnum | EducationImageScalarFieldEnum[]
  }

  /**
   * EducationImage create
   */
  export type EducationImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationImage
     */
    select?: EducationImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationImage
     */
    omit?: EducationImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationImageInclude<ExtArgs> | null
    /**
     * The data needed to create a EducationImage.
     */
    data: XOR<EducationImageCreateInput, EducationImageUncheckedCreateInput>
  }

  /**
   * EducationImage createMany
   */
  export type EducationImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EducationImages.
     */
    data: EducationImageCreateManyInput | EducationImageCreateManyInput[]
  }

  /**
   * EducationImage update
   */
  export type EducationImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationImage
     */
    select?: EducationImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationImage
     */
    omit?: EducationImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationImageInclude<ExtArgs> | null
    /**
     * The data needed to update a EducationImage.
     */
    data: XOR<EducationImageUpdateInput, EducationImageUncheckedUpdateInput>
    /**
     * Choose, which EducationImage to update.
     */
    where: EducationImageWhereUniqueInput
  }

  /**
   * EducationImage updateMany
   */
  export type EducationImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EducationImages.
     */
    data: XOR<EducationImageUpdateManyMutationInput, EducationImageUncheckedUpdateManyInput>
    /**
     * Filter which EducationImages to update
     */
    where?: EducationImageWhereInput
    /**
     * Limit how many EducationImages to update.
     */
    limit?: number
  }

  /**
   * EducationImage upsert
   */
  export type EducationImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationImage
     */
    select?: EducationImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationImage
     */
    omit?: EducationImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationImageInclude<ExtArgs> | null
    /**
     * The filter to search for the EducationImage to update in case it exists.
     */
    where: EducationImageWhereUniqueInput
    /**
     * In case the EducationImage found by the `where` argument doesn't exist, create a new EducationImage with this data.
     */
    create: XOR<EducationImageCreateInput, EducationImageUncheckedCreateInput>
    /**
     * In case the EducationImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EducationImageUpdateInput, EducationImageUncheckedUpdateInput>
  }

  /**
   * EducationImage delete
   */
  export type EducationImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationImage
     */
    select?: EducationImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationImage
     */
    omit?: EducationImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationImageInclude<ExtArgs> | null
    /**
     * Filter which EducationImage to delete.
     */
    where: EducationImageWhereUniqueInput
  }

  /**
   * EducationImage deleteMany
   */
  export type EducationImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EducationImages to delete
     */
    where?: EducationImageWhereInput
    /**
     * Limit how many EducationImages to delete.
     */
    limit?: number
  }

  /**
   * EducationImage findRaw
   */
  export type EducationImageFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * EducationImage aggregateRaw
   */
  export type EducationImageAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * EducationImage without action
   */
  export type EducationImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationImage
     */
    select?: EducationImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationImage
     */
    omit?: EducationImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationImageInclude<ExtArgs> | null
  }


  /**
   * Model SkillItem
   */

  export type AggregateSkillItem = {
    _count: SkillItemCountAggregateOutputType | null
    _avg: SkillItemAvgAggregateOutputType | null
    _sum: SkillItemSumAggregateOutputType | null
    _min: SkillItemMinAggregateOutputType | null
    _max: SkillItemMaxAggregateOutputType | null
  }

  export type SkillItemAvgAggregateOutputType = {
    level: number | null
    order: number | null
  }

  export type SkillItemSumAggregateOutputType = {
    level: number | null
    order: number | null
  }

  export type SkillItemMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    level: number | null
    order: number | null
    sectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkillItemMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    level: number | null
    order: number | null
    sectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkillItemCountAggregateOutputType = {
    id: number
    title: number
    description: number
    level: number
    order: number
    sectionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SkillItemAvgAggregateInputType = {
    level?: true
    order?: true
  }

  export type SkillItemSumAggregateInputType = {
    level?: true
    order?: true
  }

  export type SkillItemMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    level?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkillItemMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    level?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkillItemCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    level?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SkillItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillItem to aggregate.
     */
    where?: SkillItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillItems to fetch.
     */
    orderBy?: SkillItemOrderByWithRelationInput | SkillItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SkillItems
    **/
    _count?: true | SkillItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillItemMaxAggregateInputType
  }

  export type GetSkillItemAggregateType<T extends SkillItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSkillItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkillItem[P]>
      : GetScalarType<T[P], AggregateSkillItem[P]>
  }




  export type SkillItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillItemWhereInput
    orderBy?: SkillItemOrderByWithAggregationInput | SkillItemOrderByWithAggregationInput[]
    by: SkillItemScalarFieldEnum[] | SkillItemScalarFieldEnum
    having?: SkillItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillItemCountAggregateInputType | true
    _avg?: SkillItemAvgAggregateInputType
    _sum?: SkillItemSumAggregateInputType
    _min?: SkillItemMinAggregateInputType
    _max?: SkillItemMaxAggregateInputType
  }

  export type SkillItemGroupByOutputType = {
    id: string
    title: string
    description: string | null
    level: number | null
    order: number
    sectionId: string
    createdAt: Date
    updatedAt: Date
    _count: SkillItemCountAggregateOutputType | null
    _avg: SkillItemAvgAggregateOutputType | null
    _sum: SkillItemSumAggregateOutputType | null
    _min: SkillItemMinAggregateOutputType | null
    _max: SkillItemMaxAggregateOutputType | null
  }

  type GetSkillItemGroupByPayload<T extends SkillItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillItemGroupByOutputType[P]>
            : GetScalarType<T[P], SkillItemGroupByOutputType[P]>
        }
      >
    >


  export type SkillItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    level?: boolean
    order?: boolean
    sectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skillItem"]>



  export type SkillItemSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    level?: boolean
    order?: boolean
    sectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SkillItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "level" | "order" | "sectionId" | "createdAt" | "updatedAt", ExtArgs["result"]["skillItem"]>
  export type SkillItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }

  export type $SkillItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SkillItem"
    objects: {
      section: Prisma.$SectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      level: number | null
      order: number
      sectionId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["skillItem"]>
    composites: {}
  }

  type SkillItemGetPayload<S extends boolean | null | undefined | SkillItemDefaultArgs> = $Result.GetResult<Prisma.$SkillItemPayload, S>

  type SkillItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkillItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillItemCountAggregateInputType | true
    }

  export interface SkillItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SkillItem'], meta: { name: 'SkillItem' } }
    /**
     * Find zero or one SkillItem that matches the filter.
     * @param {SkillItemFindUniqueArgs} args - Arguments to find a SkillItem
     * @example
     * // Get one SkillItem
     * const skillItem = await prisma.skillItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillItemFindUniqueArgs>(args: SelectSubset<T, SkillItemFindUniqueArgs<ExtArgs>>): Prisma__SkillItemClient<$Result.GetResult<Prisma.$SkillItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SkillItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkillItemFindUniqueOrThrowArgs} args - Arguments to find a SkillItem
     * @example
     * // Get one SkillItem
     * const skillItem = await prisma.skillItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillItemClient<$Result.GetResult<Prisma.$SkillItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SkillItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillItemFindFirstArgs} args - Arguments to find a SkillItem
     * @example
     * // Get one SkillItem
     * const skillItem = await prisma.skillItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillItemFindFirstArgs>(args?: SelectSubset<T, SkillItemFindFirstArgs<ExtArgs>>): Prisma__SkillItemClient<$Result.GetResult<Prisma.$SkillItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SkillItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillItemFindFirstOrThrowArgs} args - Arguments to find a SkillItem
     * @example
     * // Get one SkillItem
     * const skillItem = await prisma.skillItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillItemClient<$Result.GetResult<Prisma.$SkillItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SkillItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkillItems
     * const skillItems = await prisma.skillItem.findMany()
     * 
     * // Get first 10 SkillItems
     * const skillItems = await prisma.skillItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillItemWithIdOnly = await prisma.skillItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillItemFindManyArgs>(args?: SelectSubset<T, SkillItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SkillItem.
     * @param {SkillItemCreateArgs} args - Arguments to create a SkillItem.
     * @example
     * // Create one SkillItem
     * const SkillItem = await prisma.skillItem.create({
     *   data: {
     *     // ... data to create a SkillItem
     *   }
     * })
     * 
     */
    create<T extends SkillItemCreateArgs>(args: SelectSubset<T, SkillItemCreateArgs<ExtArgs>>): Prisma__SkillItemClient<$Result.GetResult<Prisma.$SkillItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SkillItems.
     * @param {SkillItemCreateManyArgs} args - Arguments to create many SkillItems.
     * @example
     * // Create many SkillItems
     * const skillItem = await prisma.skillItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillItemCreateManyArgs>(args?: SelectSubset<T, SkillItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SkillItem.
     * @param {SkillItemDeleteArgs} args - Arguments to delete one SkillItem.
     * @example
     * // Delete one SkillItem
     * const SkillItem = await prisma.skillItem.delete({
     *   where: {
     *     // ... filter to delete one SkillItem
     *   }
     * })
     * 
     */
    delete<T extends SkillItemDeleteArgs>(args: SelectSubset<T, SkillItemDeleteArgs<ExtArgs>>): Prisma__SkillItemClient<$Result.GetResult<Prisma.$SkillItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SkillItem.
     * @param {SkillItemUpdateArgs} args - Arguments to update one SkillItem.
     * @example
     * // Update one SkillItem
     * const skillItem = await prisma.skillItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillItemUpdateArgs>(args: SelectSubset<T, SkillItemUpdateArgs<ExtArgs>>): Prisma__SkillItemClient<$Result.GetResult<Prisma.$SkillItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SkillItems.
     * @param {SkillItemDeleteManyArgs} args - Arguments to filter SkillItems to delete.
     * @example
     * // Delete a few SkillItems
     * const { count } = await prisma.skillItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillItemDeleteManyArgs>(args?: SelectSubset<T, SkillItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkillItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkillItems
     * const skillItem = await prisma.skillItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillItemUpdateManyArgs>(args: SelectSubset<T, SkillItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SkillItem.
     * @param {SkillItemUpsertArgs} args - Arguments to update or create a SkillItem.
     * @example
     * // Update or create a SkillItem
     * const skillItem = await prisma.skillItem.upsert({
     *   create: {
     *     // ... data to create a SkillItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkillItem we want to update
     *   }
     * })
     */
    upsert<T extends SkillItemUpsertArgs>(args: SelectSubset<T, SkillItemUpsertArgs<ExtArgs>>): Prisma__SkillItemClient<$Result.GetResult<Prisma.$SkillItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SkillItems that matches the filter.
     * @param {SkillItemFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const skillItem = await prisma.skillItem.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SkillItemFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SkillItem.
     * @param {SkillItemAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const skillItem = await prisma.skillItem.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SkillItemAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SkillItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillItemCountArgs} args - Arguments to filter SkillItems to count.
     * @example
     * // Count the number of SkillItems
     * const count = await prisma.skillItem.count({
     *   where: {
     *     // ... the filter for the SkillItems we want to count
     *   }
     * })
    **/
    count<T extends SkillItemCountArgs>(
      args?: Subset<T, SkillItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkillItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillItemAggregateArgs>(args: Subset<T, SkillItemAggregateArgs>): Prisma.PrismaPromise<GetSkillItemAggregateType<T>>

    /**
     * Group by SkillItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillItemGroupByArgs['orderBy'] }
        : { orderBy?: SkillItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SkillItem model
   */
  readonly fields: SkillItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SkillItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SkillItem model
   */
  interface SkillItemFieldRefs {
    readonly id: FieldRef<"SkillItem", 'String'>
    readonly title: FieldRef<"SkillItem", 'String'>
    readonly description: FieldRef<"SkillItem", 'String'>
    readonly level: FieldRef<"SkillItem", 'Int'>
    readonly order: FieldRef<"SkillItem", 'Int'>
    readonly sectionId: FieldRef<"SkillItem", 'String'>
    readonly createdAt: FieldRef<"SkillItem", 'DateTime'>
    readonly updatedAt: FieldRef<"SkillItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SkillItem findUnique
   */
  export type SkillItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillItem
     */
    select?: SkillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillItem
     */
    omit?: SkillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillItemInclude<ExtArgs> | null
    /**
     * Filter, which SkillItem to fetch.
     */
    where: SkillItemWhereUniqueInput
  }

  /**
   * SkillItem findUniqueOrThrow
   */
  export type SkillItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillItem
     */
    select?: SkillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillItem
     */
    omit?: SkillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillItemInclude<ExtArgs> | null
    /**
     * Filter, which SkillItem to fetch.
     */
    where: SkillItemWhereUniqueInput
  }

  /**
   * SkillItem findFirst
   */
  export type SkillItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillItem
     */
    select?: SkillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillItem
     */
    omit?: SkillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillItemInclude<ExtArgs> | null
    /**
     * Filter, which SkillItem to fetch.
     */
    where?: SkillItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillItems to fetch.
     */
    orderBy?: SkillItemOrderByWithRelationInput | SkillItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillItems.
     */
    cursor?: SkillItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillItems.
     */
    distinct?: SkillItemScalarFieldEnum | SkillItemScalarFieldEnum[]
  }

  /**
   * SkillItem findFirstOrThrow
   */
  export type SkillItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillItem
     */
    select?: SkillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillItem
     */
    omit?: SkillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillItemInclude<ExtArgs> | null
    /**
     * Filter, which SkillItem to fetch.
     */
    where?: SkillItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillItems to fetch.
     */
    orderBy?: SkillItemOrderByWithRelationInput | SkillItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillItems.
     */
    cursor?: SkillItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillItems.
     */
    distinct?: SkillItemScalarFieldEnum | SkillItemScalarFieldEnum[]
  }

  /**
   * SkillItem findMany
   */
  export type SkillItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillItem
     */
    select?: SkillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillItem
     */
    omit?: SkillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillItemInclude<ExtArgs> | null
    /**
     * Filter, which SkillItems to fetch.
     */
    where?: SkillItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillItems to fetch.
     */
    orderBy?: SkillItemOrderByWithRelationInput | SkillItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SkillItems.
     */
    cursor?: SkillItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillItems.
     */
    skip?: number
    distinct?: SkillItemScalarFieldEnum | SkillItemScalarFieldEnum[]
  }

  /**
   * SkillItem create
   */
  export type SkillItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillItem
     */
    select?: SkillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillItem
     */
    omit?: SkillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SkillItem.
     */
    data: XOR<SkillItemCreateInput, SkillItemUncheckedCreateInput>
  }

  /**
   * SkillItem createMany
   */
  export type SkillItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SkillItems.
     */
    data: SkillItemCreateManyInput | SkillItemCreateManyInput[]
  }

  /**
   * SkillItem update
   */
  export type SkillItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillItem
     */
    select?: SkillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillItem
     */
    omit?: SkillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SkillItem.
     */
    data: XOR<SkillItemUpdateInput, SkillItemUncheckedUpdateInput>
    /**
     * Choose, which SkillItem to update.
     */
    where: SkillItemWhereUniqueInput
  }

  /**
   * SkillItem updateMany
   */
  export type SkillItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SkillItems.
     */
    data: XOR<SkillItemUpdateManyMutationInput, SkillItemUncheckedUpdateManyInput>
    /**
     * Filter which SkillItems to update
     */
    where?: SkillItemWhereInput
    /**
     * Limit how many SkillItems to update.
     */
    limit?: number
  }

  /**
   * SkillItem upsert
   */
  export type SkillItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillItem
     */
    select?: SkillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillItem
     */
    omit?: SkillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SkillItem to update in case it exists.
     */
    where: SkillItemWhereUniqueInput
    /**
     * In case the SkillItem found by the `where` argument doesn't exist, create a new SkillItem with this data.
     */
    create: XOR<SkillItemCreateInput, SkillItemUncheckedCreateInput>
    /**
     * In case the SkillItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillItemUpdateInput, SkillItemUncheckedUpdateInput>
  }

  /**
   * SkillItem delete
   */
  export type SkillItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillItem
     */
    select?: SkillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillItem
     */
    omit?: SkillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillItemInclude<ExtArgs> | null
    /**
     * Filter which SkillItem to delete.
     */
    where: SkillItemWhereUniqueInput
  }

  /**
   * SkillItem deleteMany
   */
  export type SkillItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillItems to delete
     */
    where?: SkillItemWhereInput
    /**
     * Limit how many SkillItems to delete.
     */
    limit?: number
  }

  /**
   * SkillItem findRaw
   */
  export type SkillItemFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SkillItem aggregateRaw
   */
  export type SkillItemAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SkillItem without action
   */
  export type SkillItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillItem
     */
    select?: SkillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillItem
     */
    omit?: SkillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillItemInclude<ExtArgs> | null
  }


  /**
   * Model SkillImage
   */

  export type AggregateSkillImage = {
    _count: SkillImageCountAggregateOutputType | null
    _avg: SkillImageAvgAggregateOutputType | null
    _sum: SkillImageSumAggregateOutputType | null
    _min: SkillImageMinAggregateOutputType | null
    _max: SkillImageMaxAggregateOutputType | null
  }

  export type SkillImageAvgAggregateOutputType = {
    order: number | null
  }

  export type SkillImageSumAggregateOutputType = {
    order: number | null
  }

  export type SkillImageMinAggregateOutputType = {
    id: string | null
    src: string | null
    imagePublicId: string | null
    alt: string | null
    caption: string | null
    order: number | null
    sectionId: string | null
    createdAt: Date | null
  }

  export type SkillImageMaxAggregateOutputType = {
    id: string | null
    src: string | null
    imagePublicId: string | null
    alt: string | null
    caption: string | null
    order: number | null
    sectionId: string | null
    createdAt: Date | null
  }

  export type SkillImageCountAggregateOutputType = {
    id: number
    src: number
    imagePublicId: number
    alt: number
    caption: number
    order: number
    sectionId: number
    createdAt: number
    _all: number
  }


  export type SkillImageAvgAggregateInputType = {
    order?: true
  }

  export type SkillImageSumAggregateInputType = {
    order?: true
  }

  export type SkillImageMinAggregateInputType = {
    id?: true
    src?: true
    imagePublicId?: true
    alt?: true
    caption?: true
    order?: true
    sectionId?: true
    createdAt?: true
  }

  export type SkillImageMaxAggregateInputType = {
    id?: true
    src?: true
    imagePublicId?: true
    alt?: true
    caption?: true
    order?: true
    sectionId?: true
    createdAt?: true
  }

  export type SkillImageCountAggregateInputType = {
    id?: true
    src?: true
    imagePublicId?: true
    alt?: true
    caption?: true
    order?: true
    sectionId?: true
    createdAt?: true
    _all?: true
  }

  export type SkillImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillImage to aggregate.
     */
    where?: SkillImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillImages to fetch.
     */
    orderBy?: SkillImageOrderByWithRelationInput | SkillImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SkillImages
    **/
    _count?: true | SkillImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillImageMaxAggregateInputType
  }

  export type GetSkillImageAggregateType<T extends SkillImageAggregateArgs> = {
        [P in keyof T & keyof AggregateSkillImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkillImage[P]>
      : GetScalarType<T[P], AggregateSkillImage[P]>
  }




  export type SkillImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillImageWhereInput
    orderBy?: SkillImageOrderByWithAggregationInput | SkillImageOrderByWithAggregationInput[]
    by: SkillImageScalarFieldEnum[] | SkillImageScalarFieldEnum
    having?: SkillImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillImageCountAggregateInputType | true
    _avg?: SkillImageAvgAggregateInputType
    _sum?: SkillImageSumAggregateInputType
    _min?: SkillImageMinAggregateInputType
    _max?: SkillImageMaxAggregateInputType
  }

  export type SkillImageGroupByOutputType = {
    id: string
    src: string
    imagePublicId: string | null
    alt: string | null
    caption: string | null
    order: number
    sectionId: string
    createdAt: Date
    _count: SkillImageCountAggregateOutputType | null
    _avg: SkillImageAvgAggregateOutputType | null
    _sum: SkillImageSumAggregateOutputType | null
    _min: SkillImageMinAggregateOutputType | null
    _max: SkillImageMaxAggregateOutputType | null
  }

  type GetSkillImageGroupByPayload<T extends SkillImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillImageGroupByOutputType[P]>
            : GetScalarType<T[P], SkillImageGroupByOutputType[P]>
        }
      >
    >


  export type SkillImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    src?: boolean
    imagePublicId?: boolean
    alt?: boolean
    caption?: boolean
    order?: boolean
    sectionId?: boolean
    createdAt?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skillImage"]>



  export type SkillImageSelectScalar = {
    id?: boolean
    src?: boolean
    imagePublicId?: boolean
    alt?: boolean
    caption?: boolean
    order?: boolean
    sectionId?: boolean
    createdAt?: boolean
  }

  export type SkillImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "src" | "imagePublicId" | "alt" | "caption" | "order" | "sectionId" | "createdAt", ExtArgs["result"]["skillImage"]>
  export type SkillImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }

  export type $SkillImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SkillImage"
    objects: {
      section: Prisma.$SectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      src: string
      imagePublicId: string | null
      alt: string | null
      caption: string | null
      order: number
      sectionId: string
      createdAt: Date
    }, ExtArgs["result"]["skillImage"]>
    composites: {}
  }

  type SkillImageGetPayload<S extends boolean | null | undefined | SkillImageDefaultArgs> = $Result.GetResult<Prisma.$SkillImagePayload, S>

  type SkillImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkillImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillImageCountAggregateInputType | true
    }

  export interface SkillImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SkillImage'], meta: { name: 'SkillImage' } }
    /**
     * Find zero or one SkillImage that matches the filter.
     * @param {SkillImageFindUniqueArgs} args - Arguments to find a SkillImage
     * @example
     * // Get one SkillImage
     * const skillImage = await prisma.skillImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillImageFindUniqueArgs>(args: SelectSubset<T, SkillImageFindUniqueArgs<ExtArgs>>): Prisma__SkillImageClient<$Result.GetResult<Prisma.$SkillImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SkillImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkillImageFindUniqueOrThrowArgs} args - Arguments to find a SkillImage
     * @example
     * // Get one SkillImage
     * const skillImage = await prisma.skillImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillImageFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillImageClient<$Result.GetResult<Prisma.$SkillImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SkillImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillImageFindFirstArgs} args - Arguments to find a SkillImage
     * @example
     * // Get one SkillImage
     * const skillImage = await prisma.skillImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillImageFindFirstArgs>(args?: SelectSubset<T, SkillImageFindFirstArgs<ExtArgs>>): Prisma__SkillImageClient<$Result.GetResult<Prisma.$SkillImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SkillImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillImageFindFirstOrThrowArgs} args - Arguments to find a SkillImage
     * @example
     * // Get one SkillImage
     * const skillImage = await prisma.skillImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillImageFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillImageClient<$Result.GetResult<Prisma.$SkillImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SkillImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkillImages
     * const skillImages = await prisma.skillImage.findMany()
     * 
     * // Get first 10 SkillImages
     * const skillImages = await prisma.skillImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillImageWithIdOnly = await prisma.skillImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillImageFindManyArgs>(args?: SelectSubset<T, SkillImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SkillImage.
     * @param {SkillImageCreateArgs} args - Arguments to create a SkillImage.
     * @example
     * // Create one SkillImage
     * const SkillImage = await prisma.skillImage.create({
     *   data: {
     *     // ... data to create a SkillImage
     *   }
     * })
     * 
     */
    create<T extends SkillImageCreateArgs>(args: SelectSubset<T, SkillImageCreateArgs<ExtArgs>>): Prisma__SkillImageClient<$Result.GetResult<Prisma.$SkillImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SkillImages.
     * @param {SkillImageCreateManyArgs} args - Arguments to create many SkillImages.
     * @example
     * // Create many SkillImages
     * const skillImage = await prisma.skillImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillImageCreateManyArgs>(args?: SelectSubset<T, SkillImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SkillImage.
     * @param {SkillImageDeleteArgs} args - Arguments to delete one SkillImage.
     * @example
     * // Delete one SkillImage
     * const SkillImage = await prisma.skillImage.delete({
     *   where: {
     *     // ... filter to delete one SkillImage
     *   }
     * })
     * 
     */
    delete<T extends SkillImageDeleteArgs>(args: SelectSubset<T, SkillImageDeleteArgs<ExtArgs>>): Prisma__SkillImageClient<$Result.GetResult<Prisma.$SkillImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SkillImage.
     * @param {SkillImageUpdateArgs} args - Arguments to update one SkillImage.
     * @example
     * // Update one SkillImage
     * const skillImage = await prisma.skillImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillImageUpdateArgs>(args: SelectSubset<T, SkillImageUpdateArgs<ExtArgs>>): Prisma__SkillImageClient<$Result.GetResult<Prisma.$SkillImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SkillImages.
     * @param {SkillImageDeleteManyArgs} args - Arguments to filter SkillImages to delete.
     * @example
     * // Delete a few SkillImages
     * const { count } = await prisma.skillImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillImageDeleteManyArgs>(args?: SelectSubset<T, SkillImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkillImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkillImages
     * const skillImage = await prisma.skillImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillImageUpdateManyArgs>(args: SelectSubset<T, SkillImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SkillImage.
     * @param {SkillImageUpsertArgs} args - Arguments to update or create a SkillImage.
     * @example
     * // Update or create a SkillImage
     * const skillImage = await prisma.skillImage.upsert({
     *   create: {
     *     // ... data to create a SkillImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkillImage we want to update
     *   }
     * })
     */
    upsert<T extends SkillImageUpsertArgs>(args: SelectSubset<T, SkillImageUpsertArgs<ExtArgs>>): Prisma__SkillImageClient<$Result.GetResult<Prisma.$SkillImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SkillImages that matches the filter.
     * @param {SkillImageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const skillImage = await prisma.skillImage.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SkillImageFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SkillImage.
     * @param {SkillImageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const skillImage = await prisma.skillImage.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SkillImageAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SkillImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillImageCountArgs} args - Arguments to filter SkillImages to count.
     * @example
     * // Count the number of SkillImages
     * const count = await prisma.skillImage.count({
     *   where: {
     *     // ... the filter for the SkillImages we want to count
     *   }
     * })
    **/
    count<T extends SkillImageCountArgs>(
      args?: Subset<T, SkillImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkillImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillImageAggregateArgs>(args: Subset<T, SkillImageAggregateArgs>): Prisma.PrismaPromise<GetSkillImageAggregateType<T>>

    /**
     * Group by SkillImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillImageGroupByArgs['orderBy'] }
        : { orderBy?: SkillImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SkillImage model
   */
  readonly fields: SkillImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SkillImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SkillImage model
   */
  interface SkillImageFieldRefs {
    readonly id: FieldRef<"SkillImage", 'String'>
    readonly src: FieldRef<"SkillImage", 'String'>
    readonly imagePublicId: FieldRef<"SkillImage", 'String'>
    readonly alt: FieldRef<"SkillImage", 'String'>
    readonly caption: FieldRef<"SkillImage", 'String'>
    readonly order: FieldRef<"SkillImage", 'Int'>
    readonly sectionId: FieldRef<"SkillImage", 'String'>
    readonly createdAt: FieldRef<"SkillImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SkillImage findUnique
   */
  export type SkillImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillImage
     */
    select?: SkillImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillImage
     */
    omit?: SkillImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillImageInclude<ExtArgs> | null
    /**
     * Filter, which SkillImage to fetch.
     */
    where: SkillImageWhereUniqueInput
  }

  /**
   * SkillImage findUniqueOrThrow
   */
  export type SkillImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillImage
     */
    select?: SkillImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillImage
     */
    omit?: SkillImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillImageInclude<ExtArgs> | null
    /**
     * Filter, which SkillImage to fetch.
     */
    where: SkillImageWhereUniqueInput
  }

  /**
   * SkillImage findFirst
   */
  export type SkillImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillImage
     */
    select?: SkillImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillImage
     */
    omit?: SkillImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillImageInclude<ExtArgs> | null
    /**
     * Filter, which SkillImage to fetch.
     */
    where?: SkillImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillImages to fetch.
     */
    orderBy?: SkillImageOrderByWithRelationInput | SkillImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillImages.
     */
    cursor?: SkillImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillImages.
     */
    distinct?: SkillImageScalarFieldEnum | SkillImageScalarFieldEnum[]
  }

  /**
   * SkillImage findFirstOrThrow
   */
  export type SkillImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillImage
     */
    select?: SkillImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillImage
     */
    omit?: SkillImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillImageInclude<ExtArgs> | null
    /**
     * Filter, which SkillImage to fetch.
     */
    where?: SkillImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillImages to fetch.
     */
    orderBy?: SkillImageOrderByWithRelationInput | SkillImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillImages.
     */
    cursor?: SkillImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillImages.
     */
    distinct?: SkillImageScalarFieldEnum | SkillImageScalarFieldEnum[]
  }

  /**
   * SkillImage findMany
   */
  export type SkillImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillImage
     */
    select?: SkillImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillImage
     */
    omit?: SkillImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillImageInclude<ExtArgs> | null
    /**
     * Filter, which SkillImages to fetch.
     */
    where?: SkillImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillImages to fetch.
     */
    orderBy?: SkillImageOrderByWithRelationInput | SkillImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SkillImages.
     */
    cursor?: SkillImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillImages.
     */
    skip?: number
    distinct?: SkillImageScalarFieldEnum | SkillImageScalarFieldEnum[]
  }

  /**
   * SkillImage create
   */
  export type SkillImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillImage
     */
    select?: SkillImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillImage
     */
    omit?: SkillImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillImageInclude<ExtArgs> | null
    /**
     * The data needed to create a SkillImage.
     */
    data: XOR<SkillImageCreateInput, SkillImageUncheckedCreateInput>
  }

  /**
   * SkillImage createMany
   */
  export type SkillImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SkillImages.
     */
    data: SkillImageCreateManyInput | SkillImageCreateManyInput[]
  }

  /**
   * SkillImage update
   */
  export type SkillImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillImage
     */
    select?: SkillImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillImage
     */
    omit?: SkillImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillImageInclude<ExtArgs> | null
    /**
     * The data needed to update a SkillImage.
     */
    data: XOR<SkillImageUpdateInput, SkillImageUncheckedUpdateInput>
    /**
     * Choose, which SkillImage to update.
     */
    where: SkillImageWhereUniqueInput
  }

  /**
   * SkillImage updateMany
   */
  export type SkillImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SkillImages.
     */
    data: XOR<SkillImageUpdateManyMutationInput, SkillImageUncheckedUpdateManyInput>
    /**
     * Filter which SkillImages to update
     */
    where?: SkillImageWhereInput
    /**
     * Limit how many SkillImages to update.
     */
    limit?: number
  }

  /**
   * SkillImage upsert
   */
  export type SkillImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillImage
     */
    select?: SkillImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillImage
     */
    omit?: SkillImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillImageInclude<ExtArgs> | null
    /**
     * The filter to search for the SkillImage to update in case it exists.
     */
    where: SkillImageWhereUniqueInput
    /**
     * In case the SkillImage found by the `where` argument doesn't exist, create a new SkillImage with this data.
     */
    create: XOR<SkillImageCreateInput, SkillImageUncheckedCreateInput>
    /**
     * In case the SkillImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillImageUpdateInput, SkillImageUncheckedUpdateInput>
  }

  /**
   * SkillImage delete
   */
  export type SkillImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillImage
     */
    select?: SkillImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillImage
     */
    omit?: SkillImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillImageInclude<ExtArgs> | null
    /**
     * Filter which SkillImage to delete.
     */
    where: SkillImageWhereUniqueInput
  }

  /**
   * SkillImage deleteMany
   */
  export type SkillImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillImages to delete
     */
    where?: SkillImageWhereInput
    /**
     * Limit how many SkillImages to delete.
     */
    limit?: number
  }

  /**
   * SkillImage findRaw
   */
  export type SkillImageFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SkillImage aggregateRaw
   */
  export type SkillImageAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SkillImage without action
   */
  export type SkillImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillImage
     */
    select?: SkillImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillImage
     */
    omit?: SkillImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillImageInclude<ExtArgs> | null
  }


  /**
   * Model ExperienceItem
   */

  export type AggregateExperienceItem = {
    _count: ExperienceItemCountAggregateOutputType | null
    _avg: ExperienceItemAvgAggregateOutputType | null
    _sum: ExperienceItemSumAggregateOutputType | null
    _min: ExperienceItemMinAggregateOutputType | null
    _max: ExperienceItemMaxAggregateOutputType | null
  }

  export type ExperienceItemAvgAggregateOutputType = {
    order: number | null
  }

  export type ExperienceItemSumAggregateOutputType = {
    order: number | null
  }

  export type ExperienceItemMinAggregateOutputType = {
    id: string | null
    positionTitle: string | null
    companyName: string | null
    period: string | null
    summary: string | null
    description: string | null
    imageSrc: string | null
    imagePublicId: string | null
    order: number | null
    sectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExperienceItemMaxAggregateOutputType = {
    id: string | null
    positionTitle: string | null
    companyName: string | null
    period: string | null
    summary: string | null
    description: string | null
    imageSrc: string | null
    imagePublicId: string | null
    order: number | null
    sectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExperienceItemCountAggregateOutputType = {
    id: number
    positionTitle: number
    companyName: number
    period: number
    summary: number
    description: number
    imageSrc: number
    imagePublicId: number
    order: number
    sectionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExperienceItemAvgAggregateInputType = {
    order?: true
  }

  export type ExperienceItemSumAggregateInputType = {
    order?: true
  }

  export type ExperienceItemMinAggregateInputType = {
    id?: true
    positionTitle?: true
    companyName?: true
    period?: true
    summary?: true
    description?: true
    imageSrc?: true
    imagePublicId?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExperienceItemMaxAggregateInputType = {
    id?: true
    positionTitle?: true
    companyName?: true
    period?: true
    summary?: true
    description?: true
    imageSrc?: true
    imagePublicId?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExperienceItemCountAggregateInputType = {
    id?: true
    positionTitle?: true
    companyName?: true
    period?: true
    summary?: true
    description?: true
    imageSrc?: true
    imagePublicId?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExperienceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExperienceItem to aggregate.
     */
    where?: ExperienceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExperienceItems to fetch.
     */
    orderBy?: ExperienceItemOrderByWithRelationInput | ExperienceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExperienceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExperienceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExperienceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExperienceItems
    **/
    _count?: true | ExperienceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExperienceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExperienceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExperienceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExperienceItemMaxAggregateInputType
  }

  export type GetExperienceItemAggregateType<T extends ExperienceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateExperienceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExperienceItem[P]>
      : GetScalarType<T[P], AggregateExperienceItem[P]>
  }




  export type ExperienceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExperienceItemWhereInput
    orderBy?: ExperienceItemOrderByWithAggregationInput | ExperienceItemOrderByWithAggregationInput[]
    by: ExperienceItemScalarFieldEnum[] | ExperienceItemScalarFieldEnum
    having?: ExperienceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExperienceItemCountAggregateInputType | true
    _avg?: ExperienceItemAvgAggregateInputType
    _sum?: ExperienceItemSumAggregateInputType
    _min?: ExperienceItemMinAggregateInputType
    _max?: ExperienceItemMaxAggregateInputType
  }

  export type ExperienceItemGroupByOutputType = {
    id: string
    positionTitle: string
    companyName: string
    period: string
    summary: string | null
    description: string | null
    imageSrc: string
    imagePublicId: string | null
    order: number
    sectionId: string
    createdAt: Date
    updatedAt: Date
    _count: ExperienceItemCountAggregateOutputType | null
    _avg: ExperienceItemAvgAggregateOutputType | null
    _sum: ExperienceItemSumAggregateOutputType | null
    _min: ExperienceItemMinAggregateOutputType | null
    _max: ExperienceItemMaxAggregateOutputType | null
  }

  type GetExperienceItemGroupByPayload<T extends ExperienceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExperienceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExperienceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExperienceItemGroupByOutputType[P]>
            : GetScalarType<T[P], ExperienceItemGroupByOutputType[P]>
        }
      >
    >


  export type ExperienceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    positionTitle?: boolean
    companyName?: boolean
    period?: boolean
    summary?: boolean
    description?: boolean
    imageSrc?: boolean
    imagePublicId?: boolean
    order?: boolean
    sectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
    detailImages?: boolean | ExperienceItem$detailImagesArgs<ExtArgs>
    _count?: boolean | ExperienceItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["experienceItem"]>



  export type ExperienceItemSelectScalar = {
    id?: boolean
    positionTitle?: boolean
    companyName?: boolean
    period?: boolean
    summary?: boolean
    description?: boolean
    imageSrc?: boolean
    imagePublicId?: boolean
    order?: boolean
    sectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExperienceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "positionTitle" | "companyName" | "period" | "summary" | "description" | "imageSrc" | "imagePublicId" | "order" | "sectionId" | "createdAt" | "updatedAt", ExtArgs["result"]["experienceItem"]>
  export type ExperienceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
    detailImages?: boolean | ExperienceItem$detailImagesArgs<ExtArgs>
    _count?: boolean | ExperienceItemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ExperienceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExperienceItem"
    objects: {
      section: Prisma.$SectionPayload<ExtArgs>
      detailImages: Prisma.$ExperienceDetailImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      positionTitle: string
      companyName: string
      period: string
      summary: string | null
      description: string | null
      imageSrc: string
      imagePublicId: string | null
      order: number
      sectionId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["experienceItem"]>
    composites: {}
  }

  type ExperienceItemGetPayload<S extends boolean | null | undefined | ExperienceItemDefaultArgs> = $Result.GetResult<Prisma.$ExperienceItemPayload, S>

  type ExperienceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExperienceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExperienceItemCountAggregateInputType | true
    }

  export interface ExperienceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExperienceItem'], meta: { name: 'ExperienceItem' } }
    /**
     * Find zero or one ExperienceItem that matches the filter.
     * @param {ExperienceItemFindUniqueArgs} args - Arguments to find a ExperienceItem
     * @example
     * // Get one ExperienceItem
     * const experienceItem = await prisma.experienceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExperienceItemFindUniqueArgs>(args: SelectSubset<T, ExperienceItemFindUniqueArgs<ExtArgs>>): Prisma__ExperienceItemClient<$Result.GetResult<Prisma.$ExperienceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExperienceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExperienceItemFindUniqueOrThrowArgs} args - Arguments to find a ExperienceItem
     * @example
     * // Get one ExperienceItem
     * const experienceItem = await prisma.experienceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExperienceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ExperienceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExperienceItemClient<$Result.GetResult<Prisma.$ExperienceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExperienceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceItemFindFirstArgs} args - Arguments to find a ExperienceItem
     * @example
     * // Get one ExperienceItem
     * const experienceItem = await prisma.experienceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExperienceItemFindFirstArgs>(args?: SelectSubset<T, ExperienceItemFindFirstArgs<ExtArgs>>): Prisma__ExperienceItemClient<$Result.GetResult<Prisma.$ExperienceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExperienceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceItemFindFirstOrThrowArgs} args - Arguments to find a ExperienceItem
     * @example
     * // Get one ExperienceItem
     * const experienceItem = await prisma.experienceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExperienceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ExperienceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExperienceItemClient<$Result.GetResult<Prisma.$ExperienceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExperienceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExperienceItems
     * const experienceItems = await prisma.experienceItem.findMany()
     * 
     * // Get first 10 ExperienceItems
     * const experienceItems = await prisma.experienceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const experienceItemWithIdOnly = await prisma.experienceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExperienceItemFindManyArgs>(args?: SelectSubset<T, ExperienceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperienceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExperienceItem.
     * @param {ExperienceItemCreateArgs} args - Arguments to create a ExperienceItem.
     * @example
     * // Create one ExperienceItem
     * const ExperienceItem = await prisma.experienceItem.create({
     *   data: {
     *     // ... data to create a ExperienceItem
     *   }
     * })
     * 
     */
    create<T extends ExperienceItemCreateArgs>(args: SelectSubset<T, ExperienceItemCreateArgs<ExtArgs>>): Prisma__ExperienceItemClient<$Result.GetResult<Prisma.$ExperienceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExperienceItems.
     * @param {ExperienceItemCreateManyArgs} args - Arguments to create many ExperienceItems.
     * @example
     * // Create many ExperienceItems
     * const experienceItem = await prisma.experienceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExperienceItemCreateManyArgs>(args?: SelectSubset<T, ExperienceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ExperienceItem.
     * @param {ExperienceItemDeleteArgs} args - Arguments to delete one ExperienceItem.
     * @example
     * // Delete one ExperienceItem
     * const ExperienceItem = await prisma.experienceItem.delete({
     *   where: {
     *     // ... filter to delete one ExperienceItem
     *   }
     * })
     * 
     */
    delete<T extends ExperienceItemDeleteArgs>(args: SelectSubset<T, ExperienceItemDeleteArgs<ExtArgs>>): Prisma__ExperienceItemClient<$Result.GetResult<Prisma.$ExperienceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExperienceItem.
     * @param {ExperienceItemUpdateArgs} args - Arguments to update one ExperienceItem.
     * @example
     * // Update one ExperienceItem
     * const experienceItem = await prisma.experienceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExperienceItemUpdateArgs>(args: SelectSubset<T, ExperienceItemUpdateArgs<ExtArgs>>): Prisma__ExperienceItemClient<$Result.GetResult<Prisma.$ExperienceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExperienceItems.
     * @param {ExperienceItemDeleteManyArgs} args - Arguments to filter ExperienceItems to delete.
     * @example
     * // Delete a few ExperienceItems
     * const { count } = await prisma.experienceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExperienceItemDeleteManyArgs>(args?: SelectSubset<T, ExperienceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExperienceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExperienceItems
     * const experienceItem = await prisma.experienceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExperienceItemUpdateManyArgs>(args: SelectSubset<T, ExperienceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExperienceItem.
     * @param {ExperienceItemUpsertArgs} args - Arguments to update or create a ExperienceItem.
     * @example
     * // Update or create a ExperienceItem
     * const experienceItem = await prisma.experienceItem.upsert({
     *   create: {
     *     // ... data to create a ExperienceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExperienceItem we want to update
     *   }
     * })
     */
    upsert<T extends ExperienceItemUpsertArgs>(args: SelectSubset<T, ExperienceItemUpsertArgs<ExtArgs>>): Prisma__ExperienceItemClient<$Result.GetResult<Prisma.$ExperienceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExperienceItems that matches the filter.
     * @param {ExperienceItemFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const experienceItem = await prisma.experienceItem.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ExperienceItemFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ExperienceItem.
     * @param {ExperienceItemAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const experienceItem = await prisma.experienceItem.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ExperienceItemAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ExperienceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceItemCountArgs} args - Arguments to filter ExperienceItems to count.
     * @example
     * // Count the number of ExperienceItems
     * const count = await prisma.experienceItem.count({
     *   where: {
     *     // ... the filter for the ExperienceItems we want to count
     *   }
     * })
    **/
    count<T extends ExperienceItemCountArgs>(
      args?: Subset<T, ExperienceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExperienceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExperienceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExperienceItemAggregateArgs>(args: Subset<T, ExperienceItemAggregateArgs>): Prisma.PrismaPromise<GetExperienceItemAggregateType<T>>

    /**
     * Group by ExperienceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExperienceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExperienceItemGroupByArgs['orderBy'] }
        : { orderBy?: ExperienceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExperienceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExperienceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExperienceItem model
   */
  readonly fields: ExperienceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExperienceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExperienceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    detailImages<T extends ExperienceItem$detailImagesArgs<ExtArgs> = {}>(args?: Subset<T, ExperienceItem$detailImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperienceDetailImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExperienceItem model
   */
  interface ExperienceItemFieldRefs {
    readonly id: FieldRef<"ExperienceItem", 'String'>
    readonly positionTitle: FieldRef<"ExperienceItem", 'String'>
    readonly companyName: FieldRef<"ExperienceItem", 'String'>
    readonly period: FieldRef<"ExperienceItem", 'String'>
    readonly summary: FieldRef<"ExperienceItem", 'String'>
    readonly description: FieldRef<"ExperienceItem", 'String'>
    readonly imageSrc: FieldRef<"ExperienceItem", 'String'>
    readonly imagePublicId: FieldRef<"ExperienceItem", 'String'>
    readonly order: FieldRef<"ExperienceItem", 'Int'>
    readonly sectionId: FieldRef<"ExperienceItem", 'String'>
    readonly createdAt: FieldRef<"ExperienceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ExperienceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExperienceItem findUnique
   */
  export type ExperienceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceItem
     */
    select?: ExperienceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceItem
     */
    omit?: ExperienceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceItemInclude<ExtArgs> | null
    /**
     * Filter, which ExperienceItem to fetch.
     */
    where: ExperienceItemWhereUniqueInput
  }

  /**
   * ExperienceItem findUniqueOrThrow
   */
  export type ExperienceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceItem
     */
    select?: ExperienceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceItem
     */
    omit?: ExperienceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceItemInclude<ExtArgs> | null
    /**
     * Filter, which ExperienceItem to fetch.
     */
    where: ExperienceItemWhereUniqueInput
  }

  /**
   * ExperienceItem findFirst
   */
  export type ExperienceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceItem
     */
    select?: ExperienceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceItem
     */
    omit?: ExperienceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceItemInclude<ExtArgs> | null
    /**
     * Filter, which ExperienceItem to fetch.
     */
    where?: ExperienceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExperienceItems to fetch.
     */
    orderBy?: ExperienceItemOrderByWithRelationInput | ExperienceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExperienceItems.
     */
    cursor?: ExperienceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExperienceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExperienceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExperienceItems.
     */
    distinct?: ExperienceItemScalarFieldEnum | ExperienceItemScalarFieldEnum[]
  }

  /**
   * ExperienceItem findFirstOrThrow
   */
  export type ExperienceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceItem
     */
    select?: ExperienceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceItem
     */
    omit?: ExperienceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceItemInclude<ExtArgs> | null
    /**
     * Filter, which ExperienceItem to fetch.
     */
    where?: ExperienceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExperienceItems to fetch.
     */
    orderBy?: ExperienceItemOrderByWithRelationInput | ExperienceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExperienceItems.
     */
    cursor?: ExperienceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExperienceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExperienceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExperienceItems.
     */
    distinct?: ExperienceItemScalarFieldEnum | ExperienceItemScalarFieldEnum[]
  }

  /**
   * ExperienceItem findMany
   */
  export type ExperienceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceItem
     */
    select?: ExperienceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceItem
     */
    omit?: ExperienceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceItemInclude<ExtArgs> | null
    /**
     * Filter, which ExperienceItems to fetch.
     */
    where?: ExperienceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExperienceItems to fetch.
     */
    orderBy?: ExperienceItemOrderByWithRelationInput | ExperienceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExperienceItems.
     */
    cursor?: ExperienceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExperienceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExperienceItems.
     */
    skip?: number
    distinct?: ExperienceItemScalarFieldEnum | ExperienceItemScalarFieldEnum[]
  }

  /**
   * ExperienceItem create
   */
  export type ExperienceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceItem
     */
    select?: ExperienceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceItem
     */
    omit?: ExperienceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ExperienceItem.
     */
    data: XOR<ExperienceItemCreateInput, ExperienceItemUncheckedCreateInput>
  }

  /**
   * ExperienceItem createMany
   */
  export type ExperienceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExperienceItems.
     */
    data: ExperienceItemCreateManyInput | ExperienceItemCreateManyInput[]
  }

  /**
   * ExperienceItem update
   */
  export type ExperienceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceItem
     */
    select?: ExperienceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceItem
     */
    omit?: ExperienceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ExperienceItem.
     */
    data: XOR<ExperienceItemUpdateInput, ExperienceItemUncheckedUpdateInput>
    /**
     * Choose, which ExperienceItem to update.
     */
    where: ExperienceItemWhereUniqueInput
  }

  /**
   * ExperienceItem updateMany
   */
  export type ExperienceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExperienceItems.
     */
    data: XOR<ExperienceItemUpdateManyMutationInput, ExperienceItemUncheckedUpdateManyInput>
    /**
     * Filter which ExperienceItems to update
     */
    where?: ExperienceItemWhereInput
    /**
     * Limit how many ExperienceItems to update.
     */
    limit?: number
  }

  /**
   * ExperienceItem upsert
   */
  export type ExperienceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceItem
     */
    select?: ExperienceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceItem
     */
    omit?: ExperienceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ExperienceItem to update in case it exists.
     */
    where: ExperienceItemWhereUniqueInput
    /**
     * In case the ExperienceItem found by the `where` argument doesn't exist, create a new ExperienceItem with this data.
     */
    create: XOR<ExperienceItemCreateInput, ExperienceItemUncheckedCreateInput>
    /**
     * In case the ExperienceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExperienceItemUpdateInput, ExperienceItemUncheckedUpdateInput>
  }

  /**
   * ExperienceItem delete
   */
  export type ExperienceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceItem
     */
    select?: ExperienceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceItem
     */
    omit?: ExperienceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceItemInclude<ExtArgs> | null
    /**
     * Filter which ExperienceItem to delete.
     */
    where: ExperienceItemWhereUniqueInput
  }

  /**
   * ExperienceItem deleteMany
   */
  export type ExperienceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExperienceItems to delete
     */
    where?: ExperienceItemWhereInput
    /**
     * Limit how many ExperienceItems to delete.
     */
    limit?: number
  }

  /**
   * ExperienceItem findRaw
   */
  export type ExperienceItemFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ExperienceItem aggregateRaw
   */
  export type ExperienceItemAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ExperienceItem.detailImages
   */
  export type ExperienceItem$detailImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceDetailImage
     */
    select?: ExperienceDetailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceDetailImage
     */
    omit?: ExperienceDetailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceDetailImageInclude<ExtArgs> | null
    where?: ExperienceDetailImageWhereInput
    orderBy?: ExperienceDetailImageOrderByWithRelationInput | ExperienceDetailImageOrderByWithRelationInput[]
    cursor?: ExperienceDetailImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExperienceDetailImageScalarFieldEnum | ExperienceDetailImageScalarFieldEnum[]
  }

  /**
   * ExperienceItem without action
   */
  export type ExperienceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceItem
     */
    select?: ExperienceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceItem
     */
    omit?: ExperienceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceItemInclude<ExtArgs> | null
  }


  /**
   * Model ExperienceDetailImage
   */

  export type AggregateExperienceDetailImage = {
    _count: ExperienceDetailImageCountAggregateOutputType | null
    _avg: ExperienceDetailImageAvgAggregateOutputType | null
    _sum: ExperienceDetailImageSumAggregateOutputType | null
    _min: ExperienceDetailImageMinAggregateOutputType | null
    _max: ExperienceDetailImageMaxAggregateOutputType | null
  }

  export type ExperienceDetailImageAvgAggregateOutputType = {
    order: number | null
  }

  export type ExperienceDetailImageSumAggregateOutputType = {
    order: number | null
  }

  export type ExperienceDetailImageMinAggregateOutputType = {
    id: string | null
    src: string | null
    imagePublicId: string | null
    alt: string | null
    caption: string | null
    order: number | null
    experienceItemId: string | null
    createdAt: Date | null
  }

  export type ExperienceDetailImageMaxAggregateOutputType = {
    id: string | null
    src: string | null
    imagePublicId: string | null
    alt: string | null
    caption: string | null
    order: number | null
    experienceItemId: string | null
    createdAt: Date | null
  }

  export type ExperienceDetailImageCountAggregateOutputType = {
    id: number
    src: number
    imagePublicId: number
    alt: number
    caption: number
    order: number
    experienceItemId: number
    createdAt: number
    _all: number
  }


  export type ExperienceDetailImageAvgAggregateInputType = {
    order?: true
  }

  export type ExperienceDetailImageSumAggregateInputType = {
    order?: true
  }

  export type ExperienceDetailImageMinAggregateInputType = {
    id?: true
    src?: true
    imagePublicId?: true
    alt?: true
    caption?: true
    order?: true
    experienceItemId?: true
    createdAt?: true
  }

  export type ExperienceDetailImageMaxAggregateInputType = {
    id?: true
    src?: true
    imagePublicId?: true
    alt?: true
    caption?: true
    order?: true
    experienceItemId?: true
    createdAt?: true
  }

  export type ExperienceDetailImageCountAggregateInputType = {
    id?: true
    src?: true
    imagePublicId?: true
    alt?: true
    caption?: true
    order?: true
    experienceItemId?: true
    createdAt?: true
    _all?: true
  }

  export type ExperienceDetailImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExperienceDetailImage to aggregate.
     */
    where?: ExperienceDetailImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExperienceDetailImages to fetch.
     */
    orderBy?: ExperienceDetailImageOrderByWithRelationInput | ExperienceDetailImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExperienceDetailImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExperienceDetailImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExperienceDetailImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExperienceDetailImages
    **/
    _count?: true | ExperienceDetailImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExperienceDetailImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExperienceDetailImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExperienceDetailImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExperienceDetailImageMaxAggregateInputType
  }

  export type GetExperienceDetailImageAggregateType<T extends ExperienceDetailImageAggregateArgs> = {
        [P in keyof T & keyof AggregateExperienceDetailImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExperienceDetailImage[P]>
      : GetScalarType<T[P], AggregateExperienceDetailImage[P]>
  }




  export type ExperienceDetailImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExperienceDetailImageWhereInput
    orderBy?: ExperienceDetailImageOrderByWithAggregationInput | ExperienceDetailImageOrderByWithAggregationInput[]
    by: ExperienceDetailImageScalarFieldEnum[] | ExperienceDetailImageScalarFieldEnum
    having?: ExperienceDetailImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExperienceDetailImageCountAggregateInputType | true
    _avg?: ExperienceDetailImageAvgAggregateInputType
    _sum?: ExperienceDetailImageSumAggregateInputType
    _min?: ExperienceDetailImageMinAggregateInputType
    _max?: ExperienceDetailImageMaxAggregateInputType
  }

  export type ExperienceDetailImageGroupByOutputType = {
    id: string
    src: string
    imagePublicId: string | null
    alt: string | null
    caption: string | null
    order: number
    experienceItemId: string
    createdAt: Date
    _count: ExperienceDetailImageCountAggregateOutputType | null
    _avg: ExperienceDetailImageAvgAggregateOutputType | null
    _sum: ExperienceDetailImageSumAggregateOutputType | null
    _min: ExperienceDetailImageMinAggregateOutputType | null
    _max: ExperienceDetailImageMaxAggregateOutputType | null
  }

  type GetExperienceDetailImageGroupByPayload<T extends ExperienceDetailImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExperienceDetailImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExperienceDetailImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExperienceDetailImageGroupByOutputType[P]>
            : GetScalarType<T[P], ExperienceDetailImageGroupByOutputType[P]>
        }
      >
    >


  export type ExperienceDetailImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    src?: boolean
    imagePublicId?: boolean
    alt?: boolean
    caption?: boolean
    order?: boolean
    experienceItemId?: boolean
    createdAt?: boolean
    experienceItem?: boolean | ExperienceItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["experienceDetailImage"]>



  export type ExperienceDetailImageSelectScalar = {
    id?: boolean
    src?: boolean
    imagePublicId?: boolean
    alt?: boolean
    caption?: boolean
    order?: boolean
    experienceItemId?: boolean
    createdAt?: boolean
  }

  export type ExperienceDetailImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "src" | "imagePublicId" | "alt" | "caption" | "order" | "experienceItemId" | "createdAt", ExtArgs["result"]["experienceDetailImage"]>
  export type ExperienceDetailImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experienceItem?: boolean | ExperienceItemDefaultArgs<ExtArgs>
  }

  export type $ExperienceDetailImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExperienceDetailImage"
    objects: {
      experienceItem: Prisma.$ExperienceItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      src: string
      imagePublicId: string | null
      alt: string | null
      caption: string | null
      order: number
      experienceItemId: string
      createdAt: Date
    }, ExtArgs["result"]["experienceDetailImage"]>
    composites: {}
  }

  type ExperienceDetailImageGetPayload<S extends boolean | null | undefined | ExperienceDetailImageDefaultArgs> = $Result.GetResult<Prisma.$ExperienceDetailImagePayload, S>

  type ExperienceDetailImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExperienceDetailImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExperienceDetailImageCountAggregateInputType | true
    }

  export interface ExperienceDetailImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExperienceDetailImage'], meta: { name: 'ExperienceDetailImage' } }
    /**
     * Find zero or one ExperienceDetailImage that matches the filter.
     * @param {ExperienceDetailImageFindUniqueArgs} args - Arguments to find a ExperienceDetailImage
     * @example
     * // Get one ExperienceDetailImage
     * const experienceDetailImage = await prisma.experienceDetailImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExperienceDetailImageFindUniqueArgs>(args: SelectSubset<T, ExperienceDetailImageFindUniqueArgs<ExtArgs>>): Prisma__ExperienceDetailImageClient<$Result.GetResult<Prisma.$ExperienceDetailImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExperienceDetailImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExperienceDetailImageFindUniqueOrThrowArgs} args - Arguments to find a ExperienceDetailImage
     * @example
     * // Get one ExperienceDetailImage
     * const experienceDetailImage = await prisma.experienceDetailImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExperienceDetailImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ExperienceDetailImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExperienceDetailImageClient<$Result.GetResult<Prisma.$ExperienceDetailImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExperienceDetailImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceDetailImageFindFirstArgs} args - Arguments to find a ExperienceDetailImage
     * @example
     * // Get one ExperienceDetailImage
     * const experienceDetailImage = await prisma.experienceDetailImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExperienceDetailImageFindFirstArgs>(args?: SelectSubset<T, ExperienceDetailImageFindFirstArgs<ExtArgs>>): Prisma__ExperienceDetailImageClient<$Result.GetResult<Prisma.$ExperienceDetailImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExperienceDetailImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceDetailImageFindFirstOrThrowArgs} args - Arguments to find a ExperienceDetailImage
     * @example
     * // Get one ExperienceDetailImage
     * const experienceDetailImage = await prisma.experienceDetailImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExperienceDetailImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ExperienceDetailImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExperienceDetailImageClient<$Result.GetResult<Prisma.$ExperienceDetailImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExperienceDetailImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceDetailImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExperienceDetailImages
     * const experienceDetailImages = await prisma.experienceDetailImage.findMany()
     * 
     * // Get first 10 ExperienceDetailImages
     * const experienceDetailImages = await prisma.experienceDetailImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const experienceDetailImageWithIdOnly = await prisma.experienceDetailImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExperienceDetailImageFindManyArgs>(args?: SelectSubset<T, ExperienceDetailImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperienceDetailImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExperienceDetailImage.
     * @param {ExperienceDetailImageCreateArgs} args - Arguments to create a ExperienceDetailImage.
     * @example
     * // Create one ExperienceDetailImage
     * const ExperienceDetailImage = await prisma.experienceDetailImage.create({
     *   data: {
     *     // ... data to create a ExperienceDetailImage
     *   }
     * })
     * 
     */
    create<T extends ExperienceDetailImageCreateArgs>(args: SelectSubset<T, ExperienceDetailImageCreateArgs<ExtArgs>>): Prisma__ExperienceDetailImageClient<$Result.GetResult<Prisma.$ExperienceDetailImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExperienceDetailImages.
     * @param {ExperienceDetailImageCreateManyArgs} args - Arguments to create many ExperienceDetailImages.
     * @example
     * // Create many ExperienceDetailImages
     * const experienceDetailImage = await prisma.experienceDetailImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExperienceDetailImageCreateManyArgs>(args?: SelectSubset<T, ExperienceDetailImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ExperienceDetailImage.
     * @param {ExperienceDetailImageDeleteArgs} args - Arguments to delete one ExperienceDetailImage.
     * @example
     * // Delete one ExperienceDetailImage
     * const ExperienceDetailImage = await prisma.experienceDetailImage.delete({
     *   where: {
     *     // ... filter to delete one ExperienceDetailImage
     *   }
     * })
     * 
     */
    delete<T extends ExperienceDetailImageDeleteArgs>(args: SelectSubset<T, ExperienceDetailImageDeleteArgs<ExtArgs>>): Prisma__ExperienceDetailImageClient<$Result.GetResult<Prisma.$ExperienceDetailImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExperienceDetailImage.
     * @param {ExperienceDetailImageUpdateArgs} args - Arguments to update one ExperienceDetailImage.
     * @example
     * // Update one ExperienceDetailImage
     * const experienceDetailImage = await prisma.experienceDetailImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExperienceDetailImageUpdateArgs>(args: SelectSubset<T, ExperienceDetailImageUpdateArgs<ExtArgs>>): Prisma__ExperienceDetailImageClient<$Result.GetResult<Prisma.$ExperienceDetailImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExperienceDetailImages.
     * @param {ExperienceDetailImageDeleteManyArgs} args - Arguments to filter ExperienceDetailImages to delete.
     * @example
     * // Delete a few ExperienceDetailImages
     * const { count } = await prisma.experienceDetailImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExperienceDetailImageDeleteManyArgs>(args?: SelectSubset<T, ExperienceDetailImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExperienceDetailImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceDetailImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExperienceDetailImages
     * const experienceDetailImage = await prisma.experienceDetailImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExperienceDetailImageUpdateManyArgs>(args: SelectSubset<T, ExperienceDetailImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExperienceDetailImage.
     * @param {ExperienceDetailImageUpsertArgs} args - Arguments to update or create a ExperienceDetailImage.
     * @example
     * // Update or create a ExperienceDetailImage
     * const experienceDetailImage = await prisma.experienceDetailImage.upsert({
     *   create: {
     *     // ... data to create a ExperienceDetailImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExperienceDetailImage we want to update
     *   }
     * })
     */
    upsert<T extends ExperienceDetailImageUpsertArgs>(args: SelectSubset<T, ExperienceDetailImageUpsertArgs<ExtArgs>>): Prisma__ExperienceDetailImageClient<$Result.GetResult<Prisma.$ExperienceDetailImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExperienceDetailImages that matches the filter.
     * @param {ExperienceDetailImageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const experienceDetailImage = await prisma.experienceDetailImage.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ExperienceDetailImageFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ExperienceDetailImage.
     * @param {ExperienceDetailImageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const experienceDetailImage = await prisma.experienceDetailImage.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ExperienceDetailImageAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ExperienceDetailImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceDetailImageCountArgs} args - Arguments to filter ExperienceDetailImages to count.
     * @example
     * // Count the number of ExperienceDetailImages
     * const count = await prisma.experienceDetailImage.count({
     *   where: {
     *     // ... the filter for the ExperienceDetailImages we want to count
     *   }
     * })
    **/
    count<T extends ExperienceDetailImageCountArgs>(
      args?: Subset<T, ExperienceDetailImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExperienceDetailImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExperienceDetailImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceDetailImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExperienceDetailImageAggregateArgs>(args: Subset<T, ExperienceDetailImageAggregateArgs>): Prisma.PrismaPromise<GetExperienceDetailImageAggregateType<T>>

    /**
     * Group by ExperienceDetailImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceDetailImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExperienceDetailImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExperienceDetailImageGroupByArgs['orderBy'] }
        : { orderBy?: ExperienceDetailImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExperienceDetailImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExperienceDetailImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExperienceDetailImage model
   */
  readonly fields: ExperienceDetailImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExperienceDetailImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExperienceDetailImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    experienceItem<T extends ExperienceItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExperienceItemDefaultArgs<ExtArgs>>): Prisma__ExperienceItemClient<$Result.GetResult<Prisma.$ExperienceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExperienceDetailImage model
   */
  interface ExperienceDetailImageFieldRefs {
    readonly id: FieldRef<"ExperienceDetailImage", 'String'>
    readonly src: FieldRef<"ExperienceDetailImage", 'String'>
    readonly imagePublicId: FieldRef<"ExperienceDetailImage", 'String'>
    readonly alt: FieldRef<"ExperienceDetailImage", 'String'>
    readonly caption: FieldRef<"ExperienceDetailImage", 'String'>
    readonly order: FieldRef<"ExperienceDetailImage", 'Int'>
    readonly experienceItemId: FieldRef<"ExperienceDetailImage", 'String'>
    readonly createdAt: FieldRef<"ExperienceDetailImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExperienceDetailImage findUnique
   */
  export type ExperienceDetailImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceDetailImage
     */
    select?: ExperienceDetailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceDetailImage
     */
    omit?: ExperienceDetailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceDetailImageInclude<ExtArgs> | null
    /**
     * Filter, which ExperienceDetailImage to fetch.
     */
    where: ExperienceDetailImageWhereUniqueInput
  }

  /**
   * ExperienceDetailImage findUniqueOrThrow
   */
  export type ExperienceDetailImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceDetailImage
     */
    select?: ExperienceDetailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceDetailImage
     */
    omit?: ExperienceDetailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceDetailImageInclude<ExtArgs> | null
    /**
     * Filter, which ExperienceDetailImage to fetch.
     */
    where: ExperienceDetailImageWhereUniqueInput
  }

  /**
   * ExperienceDetailImage findFirst
   */
  export type ExperienceDetailImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceDetailImage
     */
    select?: ExperienceDetailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceDetailImage
     */
    omit?: ExperienceDetailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceDetailImageInclude<ExtArgs> | null
    /**
     * Filter, which ExperienceDetailImage to fetch.
     */
    where?: ExperienceDetailImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExperienceDetailImages to fetch.
     */
    orderBy?: ExperienceDetailImageOrderByWithRelationInput | ExperienceDetailImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExperienceDetailImages.
     */
    cursor?: ExperienceDetailImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExperienceDetailImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExperienceDetailImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExperienceDetailImages.
     */
    distinct?: ExperienceDetailImageScalarFieldEnum | ExperienceDetailImageScalarFieldEnum[]
  }

  /**
   * ExperienceDetailImage findFirstOrThrow
   */
  export type ExperienceDetailImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceDetailImage
     */
    select?: ExperienceDetailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceDetailImage
     */
    omit?: ExperienceDetailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceDetailImageInclude<ExtArgs> | null
    /**
     * Filter, which ExperienceDetailImage to fetch.
     */
    where?: ExperienceDetailImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExperienceDetailImages to fetch.
     */
    orderBy?: ExperienceDetailImageOrderByWithRelationInput | ExperienceDetailImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExperienceDetailImages.
     */
    cursor?: ExperienceDetailImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExperienceDetailImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExperienceDetailImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExperienceDetailImages.
     */
    distinct?: ExperienceDetailImageScalarFieldEnum | ExperienceDetailImageScalarFieldEnum[]
  }

  /**
   * ExperienceDetailImage findMany
   */
  export type ExperienceDetailImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceDetailImage
     */
    select?: ExperienceDetailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceDetailImage
     */
    omit?: ExperienceDetailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceDetailImageInclude<ExtArgs> | null
    /**
     * Filter, which ExperienceDetailImages to fetch.
     */
    where?: ExperienceDetailImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExperienceDetailImages to fetch.
     */
    orderBy?: ExperienceDetailImageOrderByWithRelationInput | ExperienceDetailImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExperienceDetailImages.
     */
    cursor?: ExperienceDetailImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExperienceDetailImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExperienceDetailImages.
     */
    skip?: number
    distinct?: ExperienceDetailImageScalarFieldEnum | ExperienceDetailImageScalarFieldEnum[]
  }

  /**
   * ExperienceDetailImage create
   */
  export type ExperienceDetailImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceDetailImage
     */
    select?: ExperienceDetailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceDetailImage
     */
    omit?: ExperienceDetailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceDetailImageInclude<ExtArgs> | null
    /**
     * The data needed to create a ExperienceDetailImage.
     */
    data: XOR<ExperienceDetailImageCreateInput, ExperienceDetailImageUncheckedCreateInput>
  }

  /**
   * ExperienceDetailImage createMany
   */
  export type ExperienceDetailImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExperienceDetailImages.
     */
    data: ExperienceDetailImageCreateManyInput | ExperienceDetailImageCreateManyInput[]
  }

  /**
   * ExperienceDetailImage update
   */
  export type ExperienceDetailImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceDetailImage
     */
    select?: ExperienceDetailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceDetailImage
     */
    omit?: ExperienceDetailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceDetailImageInclude<ExtArgs> | null
    /**
     * The data needed to update a ExperienceDetailImage.
     */
    data: XOR<ExperienceDetailImageUpdateInput, ExperienceDetailImageUncheckedUpdateInput>
    /**
     * Choose, which ExperienceDetailImage to update.
     */
    where: ExperienceDetailImageWhereUniqueInput
  }

  /**
   * ExperienceDetailImage updateMany
   */
  export type ExperienceDetailImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExperienceDetailImages.
     */
    data: XOR<ExperienceDetailImageUpdateManyMutationInput, ExperienceDetailImageUncheckedUpdateManyInput>
    /**
     * Filter which ExperienceDetailImages to update
     */
    where?: ExperienceDetailImageWhereInput
    /**
     * Limit how many ExperienceDetailImages to update.
     */
    limit?: number
  }

  /**
   * ExperienceDetailImage upsert
   */
  export type ExperienceDetailImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceDetailImage
     */
    select?: ExperienceDetailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceDetailImage
     */
    omit?: ExperienceDetailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceDetailImageInclude<ExtArgs> | null
    /**
     * The filter to search for the ExperienceDetailImage to update in case it exists.
     */
    where: ExperienceDetailImageWhereUniqueInput
    /**
     * In case the ExperienceDetailImage found by the `where` argument doesn't exist, create a new ExperienceDetailImage with this data.
     */
    create: XOR<ExperienceDetailImageCreateInput, ExperienceDetailImageUncheckedCreateInput>
    /**
     * In case the ExperienceDetailImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExperienceDetailImageUpdateInput, ExperienceDetailImageUncheckedUpdateInput>
  }

  /**
   * ExperienceDetailImage delete
   */
  export type ExperienceDetailImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceDetailImage
     */
    select?: ExperienceDetailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceDetailImage
     */
    omit?: ExperienceDetailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceDetailImageInclude<ExtArgs> | null
    /**
     * Filter which ExperienceDetailImage to delete.
     */
    where: ExperienceDetailImageWhereUniqueInput
  }

  /**
   * ExperienceDetailImage deleteMany
   */
  export type ExperienceDetailImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExperienceDetailImages to delete
     */
    where?: ExperienceDetailImageWhereInput
    /**
     * Limit how many ExperienceDetailImages to delete.
     */
    limit?: number
  }

  /**
   * ExperienceDetailImage findRaw
   */
  export type ExperienceDetailImageFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ExperienceDetailImage aggregateRaw
   */
  export type ExperienceDetailImageAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ExperienceDetailImage without action
   */
  export type ExperienceDetailImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceDetailImage
     */
    select?: ExperienceDetailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExperienceDetailImage
     */
    omit?: ExperienceDetailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceDetailImageInclude<ExtArgs> | null
  }


  /**
   * Model ProjectItem
   */

  export type AggregateProjectItem = {
    _count: ProjectItemCountAggregateOutputType | null
    _avg: ProjectItemAvgAggregateOutputType | null
    _sum: ProjectItemSumAggregateOutputType | null
    _min: ProjectItemMinAggregateOutputType | null
    _max: ProjectItemMaxAggregateOutputType | null
  }

  export type ProjectItemAvgAggregateOutputType = {
    order: number | null
  }

  export type ProjectItemSumAggregateOutputType = {
    order: number | null
  }

  export type ProjectItemMinAggregateOutputType = {
    id: string | null
    projectNumber: string | null
    title: string | null
    companyName: string | null
    description1: string | null
    description2: string | null
    imageSrc: string | null
    imagePublicId: string | null
    liveLink: string | null
    sourceLink: string | null
    layout: string | null
    order: number | null
    sectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectItemMaxAggregateOutputType = {
    id: string | null
    projectNumber: string | null
    title: string | null
    companyName: string | null
    description1: string | null
    description2: string | null
    imageSrc: string | null
    imagePublicId: string | null
    liveLink: string | null
    sourceLink: string | null
    layout: string | null
    order: number | null
    sectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectItemCountAggregateOutputType = {
    id: number
    projectNumber: number
    title: number
    companyName: number
    description1: number
    description2: number
    imageSrc: number
    imagePublicId: number
    liveLink: number
    sourceLink: number
    layout: number
    order: number
    sectionId: number
    categoryIds: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectItemAvgAggregateInputType = {
    order?: true
  }

  export type ProjectItemSumAggregateInputType = {
    order?: true
  }

  export type ProjectItemMinAggregateInputType = {
    id?: true
    projectNumber?: true
    title?: true
    companyName?: true
    description1?: true
    description2?: true
    imageSrc?: true
    imagePublicId?: true
    liveLink?: true
    sourceLink?: true
    layout?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectItemMaxAggregateInputType = {
    id?: true
    projectNumber?: true
    title?: true
    companyName?: true
    description1?: true
    description2?: true
    imageSrc?: true
    imagePublicId?: true
    liveLink?: true
    sourceLink?: true
    layout?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectItemCountAggregateInputType = {
    id?: true
    projectNumber?: true
    title?: true
    companyName?: true
    description1?: true
    description2?: true
    imageSrc?: true
    imagePublicId?: true
    liveLink?: true
    sourceLink?: true
    layout?: true
    order?: true
    sectionId?: true
    categoryIds?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectItem to aggregate.
     */
    where?: ProjectItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectItems to fetch.
     */
    orderBy?: ProjectItemOrderByWithRelationInput | ProjectItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectItems
    **/
    _count?: true | ProjectItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectItemMaxAggregateInputType
  }

  export type GetProjectItemAggregateType<T extends ProjectItemAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectItem[P]>
      : GetScalarType<T[P], AggregateProjectItem[P]>
  }




  export type ProjectItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectItemWhereInput
    orderBy?: ProjectItemOrderByWithAggregationInput | ProjectItemOrderByWithAggregationInput[]
    by: ProjectItemScalarFieldEnum[] | ProjectItemScalarFieldEnum
    having?: ProjectItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectItemCountAggregateInputType | true
    _avg?: ProjectItemAvgAggregateInputType
    _sum?: ProjectItemSumAggregateInputType
    _min?: ProjectItemMinAggregateInputType
    _max?: ProjectItemMaxAggregateInputType
  }

  export type ProjectItemGroupByOutputType = {
    id: string
    projectNumber: string | null
    title: string
    companyName: string | null
    description1: string
    description2: string | null
    imageSrc: string
    imagePublicId: string | null
    liveLink: string | null
    sourceLink: string | null
    layout: string
    order: number
    sectionId: string
    categoryIds: string[]
    createdAt: Date
    updatedAt: Date
    _count: ProjectItemCountAggregateOutputType | null
    _avg: ProjectItemAvgAggregateOutputType | null
    _sum: ProjectItemSumAggregateOutputType | null
    _min: ProjectItemMinAggregateOutputType | null
    _max: ProjectItemMaxAggregateOutputType | null
  }

  type GetProjectItemGroupByPayload<T extends ProjectItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectItemGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectItemGroupByOutputType[P]>
        }
      >
    >


  export type ProjectItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectNumber?: boolean
    title?: boolean
    companyName?: boolean
    description1?: boolean
    description2?: boolean
    imageSrc?: boolean
    imagePublicId?: boolean
    liveLink?: boolean
    sourceLink?: boolean
    layout?: boolean
    order?: boolean
    sectionId?: boolean
    categoryIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectItem"]>



  export type ProjectItemSelectScalar = {
    id?: boolean
    projectNumber?: boolean
    title?: boolean
    companyName?: boolean
    description1?: boolean
    description2?: boolean
    imageSrc?: boolean
    imagePublicId?: boolean
    liveLink?: boolean
    sourceLink?: boolean
    layout?: boolean
    order?: boolean
    sectionId?: boolean
    categoryIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectNumber" | "title" | "companyName" | "description1" | "description2" | "imageSrc" | "imagePublicId" | "liveLink" | "sourceLink" | "layout" | "order" | "sectionId" | "categoryIds" | "createdAt" | "updatedAt", ExtArgs["result"]["projectItem"]>
  export type ProjectItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }

  export type $ProjectItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectItem"
    objects: {
      section: Prisma.$SectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectNumber: string | null
      title: string
      companyName: string | null
      description1: string
      description2: string | null
      imageSrc: string
      imagePublicId: string | null
      liveLink: string | null
      sourceLink: string | null
      layout: string
      order: number
      sectionId: string
      categoryIds: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectItem"]>
    composites: {}
  }

  type ProjectItemGetPayload<S extends boolean | null | undefined | ProjectItemDefaultArgs> = $Result.GetResult<Prisma.$ProjectItemPayload, S>

  type ProjectItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectItemCountAggregateInputType | true
    }

  export interface ProjectItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectItem'], meta: { name: 'ProjectItem' } }
    /**
     * Find zero or one ProjectItem that matches the filter.
     * @param {ProjectItemFindUniqueArgs} args - Arguments to find a ProjectItem
     * @example
     * // Get one ProjectItem
     * const projectItem = await prisma.projectItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectItemFindUniqueArgs>(args: SelectSubset<T, ProjectItemFindUniqueArgs<ExtArgs>>): Prisma__ProjectItemClient<$Result.GetResult<Prisma.$ProjectItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectItemFindUniqueOrThrowArgs} args - Arguments to find a ProjectItem
     * @example
     * // Get one ProjectItem
     * const projectItem = await prisma.projectItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectItemClient<$Result.GetResult<Prisma.$ProjectItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectItemFindFirstArgs} args - Arguments to find a ProjectItem
     * @example
     * // Get one ProjectItem
     * const projectItem = await prisma.projectItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectItemFindFirstArgs>(args?: SelectSubset<T, ProjectItemFindFirstArgs<ExtArgs>>): Prisma__ProjectItemClient<$Result.GetResult<Prisma.$ProjectItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectItemFindFirstOrThrowArgs} args - Arguments to find a ProjectItem
     * @example
     * // Get one ProjectItem
     * const projectItem = await prisma.projectItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectItemClient<$Result.GetResult<Prisma.$ProjectItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectItems
     * const projectItems = await prisma.projectItem.findMany()
     * 
     * // Get first 10 ProjectItems
     * const projectItems = await prisma.projectItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectItemWithIdOnly = await prisma.projectItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectItemFindManyArgs>(args?: SelectSubset<T, ProjectItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectItem.
     * @param {ProjectItemCreateArgs} args - Arguments to create a ProjectItem.
     * @example
     * // Create one ProjectItem
     * const ProjectItem = await prisma.projectItem.create({
     *   data: {
     *     // ... data to create a ProjectItem
     *   }
     * })
     * 
     */
    create<T extends ProjectItemCreateArgs>(args: SelectSubset<T, ProjectItemCreateArgs<ExtArgs>>): Prisma__ProjectItemClient<$Result.GetResult<Prisma.$ProjectItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectItems.
     * @param {ProjectItemCreateManyArgs} args - Arguments to create many ProjectItems.
     * @example
     * // Create many ProjectItems
     * const projectItem = await prisma.projectItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectItemCreateManyArgs>(args?: SelectSubset<T, ProjectItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectItem.
     * @param {ProjectItemDeleteArgs} args - Arguments to delete one ProjectItem.
     * @example
     * // Delete one ProjectItem
     * const ProjectItem = await prisma.projectItem.delete({
     *   where: {
     *     // ... filter to delete one ProjectItem
     *   }
     * })
     * 
     */
    delete<T extends ProjectItemDeleteArgs>(args: SelectSubset<T, ProjectItemDeleteArgs<ExtArgs>>): Prisma__ProjectItemClient<$Result.GetResult<Prisma.$ProjectItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectItem.
     * @param {ProjectItemUpdateArgs} args - Arguments to update one ProjectItem.
     * @example
     * // Update one ProjectItem
     * const projectItem = await prisma.projectItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectItemUpdateArgs>(args: SelectSubset<T, ProjectItemUpdateArgs<ExtArgs>>): Prisma__ProjectItemClient<$Result.GetResult<Prisma.$ProjectItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectItems.
     * @param {ProjectItemDeleteManyArgs} args - Arguments to filter ProjectItems to delete.
     * @example
     * // Delete a few ProjectItems
     * const { count } = await prisma.projectItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectItemDeleteManyArgs>(args?: SelectSubset<T, ProjectItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectItems
     * const projectItem = await prisma.projectItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectItemUpdateManyArgs>(args: SelectSubset<T, ProjectItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectItem.
     * @param {ProjectItemUpsertArgs} args - Arguments to update or create a ProjectItem.
     * @example
     * // Update or create a ProjectItem
     * const projectItem = await prisma.projectItem.upsert({
     *   create: {
     *     // ... data to create a ProjectItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectItem we want to update
     *   }
     * })
     */
    upsert<T extends ProjectItemUpsertArgs>(args: SelectSubset<T, ProjectItemUpsertArgs<ExtArgs>>): Prisma__ProjectItemClient<$Result.GetResult<Prisma.$ProjectItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectItems that matches the filter.
     * @param {ProjectItemFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const projectItem = await prisma.projectItem.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ProjectItemFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ProjectItem.
     * @param {ProjectItemAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const projectItem = await prisma.projectItem.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ProjectItemAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ProjectItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectItemCountArgs} args - Arguments to filter ProjectItems to count.
     * @example
     * // Count the number of ProjectItems
     * const count = await prisma.projectItem.count({
     *   where: {
     *     // ... the filter for the ProjectItems we want to count
     *   }
     * })
    **/
    count<T extends ProjectItemCountArgs>(
      args?: Subset<T, ProjectItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectItemAggregateArgs>(args: Subset<T, ProjectItemAggregateArgs>): Prisma.PrismaPromise<GetProjectItemAggregateType<T>>

    /**
     * Group by ProjectItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectItemGroupByArgs['orderBy'] }
        : { orderBy?: ProjectItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectItem model
   */
  readonly fields: ProjectItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectItem model
   */
  interface ProjectItemFieldRefs {
    readonly id: FieldRef<"ProjectItem", 'String'>
    readonly projectNumber: FieldRef<"ProjectItem", 'String'>
    readonly title: FieldRef<"ProjectItem", 'String'>
    readonly companyName: FieldRef<"ProjectItem", 'String'>
    readonly description1: FieldRef<"ProjectItem", 'String'>
    readonly description2: FieldRef<"ProjectItem", 'String'>
    readonly imageSrc: FieldRef<"ProjectItem", 'String'>
    readonly imagePublicId: FieldRef<"ProjectItem", 'String'>
    readonly liveLink: FieldRef<"ProjectItem", 'String'>
    readonly sourceLink: FieldRef<"ProjectItem", 'String'>
    readonly layout: FieldRef<"ProjectItem", 'String'>
    readonly order: FieldRef<"ProjectItem", 'Int'>
    readonly sectionId: FieldRef<"ProjectItem", 'String'>
    readonly categoryIds: FieldRef<"ProjectItem", 'String[]'>
    readonly createdAt: FieldRef<"ProjectItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectItem findUnique
   */
  export type ProjectItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectItem
     */
    select?: ProjectItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectItem
     */
    omit?: ProjectItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectItemInclude<ExtArgs> | null
    /**
     * Filter, which ProjectItem to fetch.
     */
    where: ProjectItemWhereUniqueInput
  }

  /**
   * ProjectItem findUniqueOrThrow
   */
  export type ProjectItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectItem
     */
    select?: ProjectItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectItem
     */
    omit?: ProjectItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectItemInclude<ExtArgs> | null
    /**
     * Filter, which ProjectItem to fetch.
     */
    where: ProjectItemWhereUniqueInput
  }

  /**
   * ProjectItem findFirst
   */
  export type ProjectItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectItem
     */
    select?: ProjectItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectItem
     */
    omit?: ProjectItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectItemInclude<ExtArgs> | null
    /**
     * Filter, which ProjectItem to fetch.
     */
    where?: ProjectItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectItems to fetch.
     */
    orderBy?: ProjectItemOrderByWithRelationInput | ProjectItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectItems.
     */
    cursor?: ProjectItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectItems.
     */
    distinct?: ProjectItemScalarFieldEnum | ProjectItemScalarFieldEnum[]
  }

  /**
   * ProjectItem findFirstOrThrow
   */
  export type ProjectItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectItem
     */
    select?: ProjectItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectItem
     */
    omit?: ProjectItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectItemInclude<ExtArgs> | null
    /**
     * Filter, which ProjectItem to fetch.
     */
    where?: ProjectItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectItems to fetch.
     */
    orderBy?: ProjectItemOrderByWithRelationInput | ProjectItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectItems.
     */
    cursor?: ProjectItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectItems.
     */
    distinct?: ProjectItemScalarFieldEnum | ProjectItemScalarFieldEnum[]
  }

  /**
   * ProjectItem findMany
   */
  export type ProjectItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectItem
     */
    select?: ProjectItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectItem
     */
    omit?: ProjectItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectItemInclude<ExtArgs> | null
    /**
     * Filter, which ProjectItems to fetch.
     */
    where?: ProjectItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectItems to fetch.
     */
    orderBy?: ProjectItemOrderByWithRelationInput | ProjectItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectItems.
     */
    cursor?: ProjectItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectItems.
     */
    skip?: number
    distinct?: ProjectItemScalarFieldEnum | ProjectItemScalarFieldEnum[]
  }

  /**
   * ProjectItem create
   */
  export type ProjectItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectItem
     */
    select?: ProjectItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectItem
     */
    omit?: ProjectItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectItem.
     */
    data: XOR<ProjectItemCreateInput, ProjectItemUncheckedCreateInput>
  }

  /**
   * ProjectItem createMany
   */
  export type ProjectItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectItems.
     */
    data: ProjectItemCreateManyInput | ProjectItemCreateManyInput[]
  }

  /**
   * ProjectItem update
   */
  export type ProjectItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectItem
     */
    select?: ProjectItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectItem
     */
    omit?: ProjectItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectItem.
     */
    data: XOR<ProjectItemUpdateInput, ProjectItemUncheckedUpdateInput>
    /**
     * Choose, which ProjectItem to update.
     */
    where: ProjectItemWhereUniqueInput
  }

  /**
   * ProjectItem updateMany
   */
  export type ProjectItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectItems.
     */
    data: XOR<ProjectItemUpdateManyMutationInput, ProjectItemUncheckedUpdateManyInput>
    /**
     * Filter which ProjectItems to update
     */
    where?: ProjectItemWhereInput
    /**
     * Limit how many ProjectItems to update.
     */
    limit?: number
  }

  /**
   * ProjectItem upsert
   */
  export type ProjectItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectItem
     */
    select?: ProjectItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectItem
     */
    omit?: ProjectItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectItem to update in case it exists.
     */
    where: ProjectItemWhereUniqueInput
    /**
     * In case the ProjectItem found by the `where` argument doesn't exist, create a new ProjectItem with this data.
     */
    create: XOR<ProjectItemCreateInput, ProjectItemUncheckedCreateInput>
    /**
     * In case the ProjectItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectItemUpdateInput, ProjectItemUncheckedUpdateInput>
  }

  /**
   * ProjectItem delete
   */
  export type ProjectItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectItem
     */
    select?: ProjectItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectItem
     */
    omit?: ProjectItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectItemInclude<ExtArgs> | null
    /**
     * Filter which ProjectItem to delete.
     */
    where: ProjectItemWhereUniqueInput
  }

  /**
   * ProjectItem deleteMany
   */
  export type ProjectItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectItems to delete
     */
    where?: ProjectItemWhereInput
    /**
     * Limit how many ProjectItems to delete.
     */
    limit?: number
  }

  /**
   * ProjectItem findRaw
   */
  export type ProjectItemFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ProjectItem aggregateRaw
   */
  export type ProjectItemAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ProjectItem without action
   */
  export type ProjectItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectItem
     */
    select?: ProjectItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectItem
     */
    omit?: ProjectItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectItemInclude<ExtArgs> | null
  }


  /**
   * Model TestimonialItem
   */

  export type AggregateTestimonialItem = {
    _count: TestimonialItemCountAggregateOutputType | null
    _avg: TestimonialItemAvgAggregateOutputType | null
    _sum: TestimonialItemSumAggregateOutputType | null
    _min: TestimonialItemMinAggregateOutputType | null
    _max: TestimonialItemMaxAggregateOutputType | null
  }

  export type TestimonialItemAvgAggregateOutputType = {
    rating: number | null
    order: number | null
  }

  export type TestimonialItemSumAggregateOutputType = {
    rating: number | null
    order: number | null
  }

  export type TestimonialItemMinAggregateOutputType = {
    id: string | null
    clientName: string | null
    role: string | null
    company: string | null
    content: string | null
    rating: number | null
    imageSrc: string | null
    imagePublicId: string | null
    order: number | null
    sectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestimonialItemMaxAggregateOutputType = {
    id: string | null
    clientName: string | null
    role: string | null
    company: string | null
    content: string | null
    rating: number | null
    imageSrc: string | null
    imagePublicId: string | null
    order: number | null
    sectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestimonialItemCountAggregateOutputType = {
    id: number
    clientName: number
    role: number
    company: number
    content: number
    rating: number
    imageSrc: number
    imagePublicId: number
    order: number
    sectionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestimonialItemAvgAggregateInputType = {
    rating?: true
    order?: true
  }

  export type TestimonialItemSumAggregateInputType = {
    rating?: true
    order?: true
  }

  export type TestimonialItemMinAggregateInputType = {
    id?: true
    clientName?: true
    role?: true
    company?: true
    content?: true
    rating?: true
    imageSrc?: true
    imagePublicId?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestimonialItemMaxAggregateInputType = {
    id?: true
    clientName?: true
    role?: true
    company?: true
    content?: true
    rating?: true
    imageSrc?: true
    imagePublicId?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestimonialItemCountAggregateInputType = {
    id?: true
    clientName?: true
    role?: true
    company?: true
    content?: true
    rating?: true
    imageSrc?: true
    imagePublicId?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestimonialItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestimonialItem to aggregate.
     */
    where?: TestimonialItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestimonialItems to fetch.
     */
    orderBy?: TestimonialItemOrderByWithRelationInput | TestimonialItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestimonialItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestimonialItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestimonialItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestimonialItems
    **/
    _count?: true | TestimonialItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestimonialItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestimonialItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestimonialItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestimonialItemMaxAggregateInputType
  }

  export type GetTestimonialItemAggregateType<T extends TestimonialItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTestimonialItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestimonialItem[P]>
      : GetScalarType<T[P], AggregateTestimonialItem[P]>
  }




  export type TestimonialItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestimonialItemWhereInput
    orderBy?: TestimonialItemOrderByWithAggregationInput | TestimonialItemOrderByWithAggregationInput[]
    by: TestimonialItemScalarFieldEnum[] | TestimonialItemScalarFieldEnum
    having?: TestimonialItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestimonialItemCountAggregateInputType | true
    _avg?: TestimonialItemAvgAggregateInputType
    _sum?: TestimonialItemSumAggregateInputType
    _min?: TestimonialItemMinAggregateInputType
    _max?: TestimonialItemMaxAggregateInputType
  }

  export type TestimonialItemGroupByOutputType = {
    id: string
    clientName: string
    role: string | null
    company: string | null
    content: string
    rating: number
    imageSrc: string | null
    imagePublicId: string | null
    order: number
    sectionId: string
    createdAt: Date
    updatedAt: Date
    _count: TestimonialItemCountAggregateOutputType | null
    _avg: TestimonialItemAvgAggregateOutputType | null
    _sum: TestimonialItemSumAggregateOutputType | null
    _min: TestimonialItemMinAggregateOutputType | null
    _max: TestimonialItemMaxAggregateOutputType | null
  }

  type GetTestimonialItemGroupByPayload<T extends TestimonialItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestimonialItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestimonialItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestimonialItemGroupByOutputType[P]>
            : GetScalarType<T[P], TestimonialItemGroupByOutputType[P]>
        }
      >
    >


  export type TestimonialItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientName?: boolean
    role?: boolean
    company?: boolean
    content?: boolean
    rating?: boolean
    imageSrc?: boolean
    imagePublicId?: boolean
    order?: boolean
    sectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testimonialItem"]>



  export type TestimonialItemSelectScalar = {
    id?: boolean
    clientName?: boolean
    role?: boolean
    company?: boolean
    content?: boolean
    rating?: boolean
    imageSrc?: boolean
    imagePublicId?: boolean
    order?: boolean
    sectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TestimonialItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientName" | "role" | "company" | "content" | "rating" | "imageSrc" | "imagePublicId" | "order" | "sectionId" | "createdAt" | "updatedAt", ExtArgs["result"]["testimonialItem"]>
  export type TestimonialItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }

  export type $TestimonialItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestimonialItem"
    objects: {
      section: Prisma.$SectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientName: string
      role: string | null
      company: string | null
      content: string
      rating: number
      imageSrc: string | null
      imagePublicId: string | null
      order: number
      sectionId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testimonialItem"]>
    composites: {}
  }

  type TestimonialItemGetPayload<S extends boolean | null | undefined | TestimonialItemDefaultArgs> = $Result.GetResult<Prisma.$TestimonialItemPayload, S>

  type TestimonialItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestimonialItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestimonialItemCountAggregateInputType | true
    }

  export interface TestimonialItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestimonialItem'], meta: { name: 'TestimonialItem' } }
    /**
     * Find zero or one TestimonialItem that matches the filter.
     * @param {TestimonialItemFindUniqueArgs} args - Arguments to find a TestimonialItem
     * @example
     * // Get one TestimonialItem
     * const testimonialItem = await prisma.testimonialItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestimonialItemFindUniqueArgs>(args: SelectSubset<T, TestimonialItemFindUniqueArgs<ExtArgs>>): Prisma__TestimonialItemClient<$Result.GetResult<Prisma.$TestimonialItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestimonialItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestimonialItemFindUniqueOrThrowArgs} args - Arguments to find a TestimonialItem
     * @example
     * // Get one TestimonialItem
     * const testimonialItem = await prisma.testimonialItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestimonialItemFindUniqueOrThrowArgs>(args: SelectSubset<T, TestimonialItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestimonialItemClient<$Result.GetResult<Prisma.$TestimonialItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestimonialItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialItemFindFirstArgs} args - Arguments to find a TestimonialItem
     * @example
     * // Get one TestimonialItem
     * const testimonialItem = await prisma.testimonialItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestimonialItemFindFirstArgs>(args?: SelectSubset<T, TestimonialItemFindFirstArgs<ExtArgs>>): Prisma__TestimonialItemClient<$Result.GetResult<Prisma.$TestimonialItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestimonialItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialItemFindFirstOrThrowArgs} args - Arguments to find a TestimonialItem
     * @example
     * // Get one TestimonialItem
     * const testimonialItem = await prisma.testimonialItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestimonialItemFindFirstOrThrowArgs>(args?: SelectSubset<T, TestimonialItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestimonialItemClient<$Result.GetResult<Prisma.$TestimonialItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestimonialItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestimonialItems
     * const testimonialItems = await prisma.testimonialItem.findMany()
     * 
     * // Get first 10 TestimonialItems
     * const testimonialItems = await prisma.testimonialItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testimonialItemWithIdOnly = await prisma.testimonialItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestimonialItemFindManyArgs>(args?: SelectSubset<T, TestimonialItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestimonialItem.
     * @param {TestimonialItemCreateArgs} args - Arguments to create a TestimonialItem.
     * @example
     * // Create one TestimonialItem
     * const TestimonialItem = await prisma.testimonialItem.create({
     *   data: {
     *     // ... data to create a TestimonialItem
     *   }
     * })
     * 
     */
    create<T extends TestimonialItemCreateArgs>(args: SelectSubset<T, TestimonialItemCreateArgs<ExtArgs>>): Prisma__TestimonialItemClient<$Result.GetResult<Prisma.$TestimonialItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestimonialItems.
     * @param {TestimonialItemCreateManyArgs} args - Arguments to create many TestimonialItems.
     * @example
     * // Create many TestimonialItems
     * const testimonialItem = await prisma.testimonialItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestimonialItemCreateManyArgs>(args?: SelectSubset<T, TestimonialItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TestimonialItem.
     * @param {TestimonialItemDeleteArgs} args - Arguments to delete one TestimonialItem.
     * @example
     * // Delete one TestimonialItem
     * const TestimonialItem = await prisma.testimonialItem.delete({
     *   where: {
     *     // ... filter to delete one TestimonialItem
     *   }
     * })
     * 
     */
    delete<T extends TestimonialItemDeleteArgs>(args: SelectSubset<T, TestimonialItemDeleteArgs<ExtArgs>>): Prisma__TestimonialItemClient<$Result.GetResult<Prisma.$TestimonialItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestimonialItem.
     * @param {TestimonialItemUpdateArgs} args - Arguments to update one TestimonialItem.
     * @example
     * // Update one TestimonialItem
     * const testimonialItem = await prisma.testimonialItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestimonialItemUpdateArgs>(args: SelectSubset<T, TestimonialItemUpdateArgs<ExtArgs>>): Prisma__TestimonialItemClient<$Result.GetResult<Prisma.$TestimonialItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestimonialItems.
     * @param {TestimonialItemDeleteManyArgs} args - Arguments to filter TestimonialItems to delete.
     * @example
     * // Delete a few TestimonialItems
     * const { count } = await prisma.testimonialItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestimonialItemDeleteManyArgs>(args?: SelectSubset<T, TestimonialItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestimonialItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestimonialItems
     * const testimonialItem = await prisma.testimonialItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestimonialItemUpdateManyArgs>(args: SelectSubset<T, TestimonialItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TestimonialItem.
     * @param {TestimonialItemUpsertArgs} args - Arguments to update or create a TestimonialItem.
     * @example
     * // Update or create a TestimonialItem
     * const testimonialItem = await prisma.testimonialItem.upsert({
     *   create: {
     *     // ... data to create a TestimonialItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestimonialItem we want to update
     *   }
     * })
     */
    upsert<T extends TestimonialItemUpsertArgs>(args: SelectSubset<T, TestimonialItemUpsertArgs<ExtArgs>>): Prisma__TestimonialItemClient<$Result.GetResult<Prisma.$TestimonialItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestimonialItems that matches the filter.
     * @param {TestimonialItemFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const testimonialItem = await prisma.testimonialItem.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TestimonialItemFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TestimonialItem.
     * @param {TestimonialItemAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const testimonialItem = await prisma.testimonialItem.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TestimonialItemAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TestimonialItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialItemCountArgs} args - Arguments to filter TestimonialItems to count.
     * @example
     * // Count the number of TestimonialItems
     * const count = await prisma.testimonialItem.count({
     *   where: {
     *     // ... the filter for the TestimonialItems we want to count
     *   }
     * })
    **/
    count<T extends TestimonialItemCountArgs>(
      args?: Subset<T, TestimonialItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestimonialItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestimonialItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestimonialItemAggregateArgs>(args: Subset<T, TestimonialItemAggregateArgs>): Prisma.PrismaPromise<GetTestimonialItemAggregateType<T>>

    /**
     * Group by TestimonialItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestimonialItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestimonialItemGroupByArgs['orderBy'] }
        : { orderBy?: TestimonialItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestimonialItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestimonialItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestimonialItem model
   */
  readonly fields: TestimonialItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestimonialItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestimonialItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestimonialItem model
   */
  interface TestimonialItemFieldRefs {
    readonly id: FieldRef<"TestimonialItem", 'String'>
    readonly clientName: FieldRef<"TestimonialItem", 'String'>
    readonly role: FieldRef<"TestimonialItem", 'String'>
    readonly company: FieldRef<"TestimonialItem", 'String'>
    readonly content: FieldRef<"TestimonialItem", 'String'>
    readonly rating: FieldRef<"TestimonialItem", 'Float'>
    readonly imageSrc: FieldRef<"TestimonialItem", 'String'>
    readonly imagePublicId: FieldRef<"TestimonialItem", 'String'>
    readonly order: FieldRef<"TestimonialItem", 'Int'>
    readonly sectionId: FieldRef<"TestimonialItem", 'String'>
    readonly createdAt: FieldRef<"TestimonialItem", 'DateTime'>
    readonly updatedAt: FieldRef<"TestimonialItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TestimonialItem findUnique
   */
  export type TestimonialItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialItem
     */
    select?: TestimonialItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialItem
     */
    omit?: TestimonialItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialItemInclude<ExtArgs> | null
    /**
     * Filter, which TestimonialItem to fetch.
     */
    where: TestimonialItemWhereUniqueInput
  }

  /**
   * TestimonialItem findUniqueOrThrow
   */
  export type TestimonialItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialItem
     */
    select?: TestimonialItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialItem
     */
    omit?: TestimonialItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialItemInclude<ExtArgs> | null
    /**
     * Filter, which TestimonialItem to fetch.
     */
    where: TestimonialItemWhereUniqueInput
  }

  /**
   * TestimonialItem findFirst
   */
  export type TestimonialItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialItem
     */
    select?: TestimonialItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialItem
     */
    omit?: TestimonialItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialItemInclude<ExtArgs> | null
    /**
     * Filter, which TestimonialItem to fetch.
     */
    where?: TestimonialItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestimonialItems to fetch.
     */
    orderBy?: TestimonialItemOrderByWithRelationInput | TestimonialItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestimonialItems.
     */
    cursor?: TestimonialItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestimonialItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestimonialItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestimonialItems.
     */
    distinct?: TestimonialItemScalarFieldEnum | TestimonialItemScalarFieldEnum[]
  }

  /**
   * TestimonialItem findFirstOrThrow
   */
  export type TestimonialItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialItem
     */
    select?: TestimonialItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialItem
     */
    omit?: TestimonialItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialItemInclude<ExtArgs> | null
    /**
     * Filter, which TestimonialItem to fetch.
     */
    where?: TestimonialItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestimonialItems to fetch.
     */
    orderBy?: TestimonialItemOrderByWithRelationInput | TestimonialItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestimonialItems.
     */
    cursor?: TestimonialItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestimonialItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestimonialItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestimonialItems.
     */
    distinct?: TestimonialItemScalarFieldEnum | TestimonialItemScalarFieldEnum[]
  }

  /**
   * TestimonialItem findMany
   */
  export type TestimonialItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialItem
     */
    select?: TestimonialItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialItem
     */
    omit?: TestimonialItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialItemInclude<ExtArgs> | null
    /**
     * Filter, which TestimonialItems to fetch.
     */
    where?: TestimonialItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestimonialItems to fetch.
     */
    orderBy?: TestimonialItemOrderByWithRelationInput | TestimonialItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestimonialItems.
     */
    cursor?: TestimonialItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestimonialItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestimonialItems.
     */
    skip?: number
    distinct?: TestimonialItemScalarFieldEnum | TestimonialItemScalarFieldEnum[]
  }

  /**
   * TestimonialItem create
   */
  export type TestimonialItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialItem
     */
    select?: TestimonialItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialItem
     */
    omit?: TestimonialItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialItemInclude<ExtArgs> | null
    /**
     * The data needed to create a TestimonialItem.
     */
    data: XOR<TestimonialItemCreateInput, TestimonialItemUncheckedCreateInput>
  }

  /**
   * TestimonialItem createMany
   */
  export type TestimonialItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestimonialItems.
     */
    data: TestimonialItemCreateManyInput | TestimonialItemCreateManyInput[]
  }

  /**
   * TestimonialItem update
   */
  export type TestimonialItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialItem
     */
    select?: TestimonialItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialItem
     */
    omit?: TestimonialItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialItemInclude<ExtArgs> | null
    /**
     * The data needed to update a TestimonialItem.
     */
    data: XOR<TestimonialItemUpdateInput, TestimonialItemUncheckedUpdateInput>
    /**
     * Choose, which TestimonialItem to update.
     */
    where: TestimonialItemWhereUniqueInput
  }

  /**
   * TestimonialItem updateMany
   */
  export type TestimonialItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestimonialItems.
     */
    data: XOR<TestimonialItemUpdateManyMutationInput, TestimonialItemUncheckedUpdateManyInput>
    /**
     * Filter which TestimonialItems to update
     */
    where?: TestimonialItemWhereInput
    /**
     * Limit how many TestimonialItems to update.
     */
    limit?: number
  }

  /**
   * TestimonialItem upsert
   */
  export type TestimonialItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialItem
     */
    select?: TestimonialItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialItem
     */
    omit?: TestimonialItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialItemInclude<ExtArgs> | null
    /**
     * The filter to search for the TestimonialItem to update in case it exists.
     */
    where: TestimonialItemWhereUniqueInput
    /**
     * In case the TestimonialItem found by the `where` argument doesn't exist, create a new TestimonialItem with this data.
     */
    create: XOR<TestimonialItemCreateInput, TestimonialItemUncheckedCreateInput>
    /**
     * In case the TestimonialItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestimonialItemUpdateInput, TestimonialItemUncheckedUpdateInput>
  }

  /**
   * TestimonialItem delete
   */
  export type TestimonialItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialItem
     */
    select?: TestimonialItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialItem
     */
    omit?: TestimonialItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialItemInclude<ExtArgs> | null
    /**
     * Filter which TestimonialItem to delete.
     */
    where: TestimonialItemWhereUniqueInput
  }

  /**
   * TestimonialItem deleteMany
   */
  export type TestimonialItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestimonialItems to delete
     */
    where?: TestimonialItemWhereInput
    /**
     * Limit how many TestimonialItems to delete.
     */
    limit?: number
  }

  /**
   * TestimonialItem findRaw
   */
  export type TestimonialItemFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TestimonialItem aggregateRaw
   */
  export type TestimonialItemAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TestimonialItem without action
   */
  export type TestimonialItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialItem
     */
    select?: TestimonialItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialItem
     */
    omit?: TestimonialItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialItemInclude<ExtArgs> | null
  }


  /**
   * Model ContactInfoItem
   */

  export type AggregateContactInfoItem = {
    _count: ContactInfoItemCountAggregateOutputType | null
    _avg: ContactInfoItemAvgAggregateOutputType | null
    _sum: ContactInfoItemSumAggregateOutputType | null
    _min: ContactInfoItemMinAggregateOutputType | null
    _max: ContactInfoItemMaxAggregateOutputType | null
  }

  export type ContactInfoItemAvgAggregateOutputType = {
    order: number | null
  }

  export type ContactInfoItemSumAggregateOutputType = {
    order: number | null
  }

  export type ContactInfoItemMinAggregateOutputType = {
    id: string | null
    type: string | null
    value: string | null
    label: string | null
    icon: string | null
    order: number | null
    sectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactInfoItemMaxAggregateOutputType = {
    id: string | null
    type: string | null
    value: string | null
    label: string | null
    icon: string | null
    order: number | null
    sectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactInfoItemCountAggregateOutputType = {
    id: number
    type: number
    value: number
    label: number
    icon: number
    order: number
    sectionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactInfoItemAvgAggregateInputType = {
    order?: true
  }

  export type ContactInfoItemSumAggregateInputType = {
    order?: true
  }

  export type ContactInfoItemMinAggregateInputType = {
    id?: true
    type?: true
    value?: true
    label?: true
    icon?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactInfoItemMaxAggregateInputType = {
    id?: true
    type?: true
    value?: true
    label?: true
    icon?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactInfoItemCountAggregateInputType = {
    id?: true
    type?: true
    value?: true
    label?: true
    icon?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactInfoItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactInfoItem to aggregate.
     */
    where?: ContactInfoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInfoItems to fetch.
     */
    orderBy?: ContactInfoItemOrderByWithRelationInput | ContactInfoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactInfoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInfoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInfoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactInfoItems
    **/
    _count?: true | ContactInfoItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactInfoItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactInfoItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactInfoItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactInfoItemMaxAggregateInputType
  }

  export type GetContactInfoItemAggregateType<T extends ContactInfoItemAggregateArgs> = {
        [P in keyof T & keyof AggregateContactInfoItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactInfoItem[P]>
      : GetScalarType<T[P], AggregateContactInfoItem[P]>
  }




  export type ContactInfoItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactInfoItemWhereInput
    orderBy?: ContactInfoItemOrderByWithAggregationInput | ContactInfoItemOrderByWithAggregationInput[]
    by: ContactInfoItemScalarFieldEnum[] | ContactInfoItemScalarFieldEnum
    having?: ContactInfoItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactInfoItemCountAggregateInputType | true
    _avg?: ContactInfoItemAvgAggregateInputType
    _sum?: ContactInfoItemSumAggregateInputType
    _min?: ContactInfoItemMinAggregateInputType
    _max?: ContactInfoItemMaxAggregateInputType
  }

  export type ContactInfoItemGroupByOutputType = {
    id: string
    type: string
    value: string
    label: string | null
    icon: string | null
    order: number
    sectionId: string
    createdAt: Date
    updatedAt: Date
    _count: ContactInfoItemCountAggregateOutputType | null
    _avg: ContactInfoItemAvgAggregateOutputType | null
    _sum: ContactInfoItemSumAggregateOutputType | null
    _min: ContactInfoItemMinAggregateOutputType | null
    _max: ContactInfoItemMaxAggregateOutputType | null
  }

  type GetContactInfoItemGroupByPayload<T extends ContactInfoItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactInfoItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactInfoItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactInfoItemGroupByOutputType[P]>
            : GetScalarType<T[P], ContactInfoItemGroupByOutputType[P]>
        }
      >
    >


  export type ContactInfoItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    value?: boolean
    label?: boolean
    icon?: boolean
    order?: boolean
    sectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactInfoItem"]>



  export type ContactInfoItemSelectScalar = {
    id?: boolean
    type?: boolean
    value?: boolean
    label?: boolean
    icon?: boolean
    order?: boolean
    sectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactInfoItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "value" | "label" | "icon" | "order" | "sectionId" | "createdAt" | "updatedAt", ExtArgs["result"]["contactInfoItem"]>
  export type ContactInfoItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }

  export type $ContactInfoItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactInfoItem"
    objects: {
      section: Prisma.$SectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      value: string
      label: string | null
      icon: string | null
      order: number
      sectionId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactInfoItem"]>
    composites: {}
  }

  type ContactInfoItemGetPayload<S extends boolean | null | undefined | ContactInfoItemDefaultArgs> = $Result.GetResult<Prisma.$ContactInfoItemPayload, S>

  type ContactInfoItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactInfoItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactInfoItemCountAggregateInputType | true
    }

  export interface ContactInfoItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactInfoItem'], meta: { name: 'ContactInfoItem' } }
    /**
     * Find zero or one ContactInfoItem that matches the filter.
     * @param {ContactInfoItemFindUniqueArgs} args - Arguments to find a ContactInfoItem
     * @example
     * // Get one ContactInfoItem
     * const contactInfoItem = await prisma.contactInfoItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactInfoItemFindUniqueArgs>(args: SelectSubset<T, ContactInfoItemFindUniqueArgs<ExtArgs>>): Prisma__ContactInfoItemClient<$Result.GetResult<Prisma.$ContactInfoItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactInfoItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactInfoItemFindUniqueOrThrowArgs} args - Arguments to find a ContactInfoItem
     * @example
     * // Get one ContactInfoItem
     * const contactInfoItem = await prisma.contactInfoItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactInfoItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactInfoItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactInfoItemClient<$Result.GetResult<Prisma.$ContactInfoItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactInfoItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoItemFindFirstArgs} args - Arguments to find a ContactInfoItem
     * @example
     * // Get one ContactInfoItem
     * const contactInfoItem = await prisma.contactInfoItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactInfoItemFindFirstArgs>(args?: SelectSubset<T, ContactInfoItemFindFirstArgs<ExtArgs>>): Prisma__ContactInfoItemClient<$Result.GetResult<Prisma.$ContactInfoItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactInfoItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoItemFindFirstOrThrowArgs} args - Arguments to find a ContactInfoItem
     * @example
     * // Get one ContactInfoItem
     * const contactInfoItem = await prisma.contactInfoItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactInfoItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactInfoItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactInfoItemClient<$Result.GetResult<Prisma.$ContactInfoItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactInfoItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactInfoItems
     * const contactInfoItems = await prisma.contactInfoItem.findMany()
     * 
     * // Get first 10 ContactInfoItems
     * const contactInfoItems = await prisma.contactInfoItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactInfoItemWithIdOnly = await prisma.contactInfoItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactInfoItemFindManyArgs>(args?: SelectSubset<T, ContactInfoItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactInfoItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactInfoItem.
     * @param {ContactInfoItemCreateArgs} args - Arguments to create a ContactInfoItem.
     * @example
     * // Create one ContactInfoItem
     * const ContactInfoItem = await prisma.contactInfoItem.create({
     *   data: {
     *     // ... data to create a ContactInfoItem
     *   }
     * })
     * 
     */
    create<T extends ContactInfoItemCreateArgs>(args: SelectSubset<T, ContactInfoItemCreateArgs<ExtArgs>>): Prisma__ContactInfoItemClient<$Result.GetResult<Prisma.$ContactInfoItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactInfoItems.
     * @param {ContactInfoItemCreateManyArgs} args - Arguments to create many ContactInfoItems.
     * @example
     * // Create many ContactInfoItems
     * const contactInfoItem = await prisma.contactInfoItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactInfoItemCreateManyArgs>(args?: SelectSubset<T, ContactInfoItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContactInfoItem.
     * @param {ContactInfoItemDeleteArgs} args - Arguments to delete one ContactInfoItem.
     * @example
     * // Delete one ContactInfoItem
     * const ContactInfoItem = await prisma.contactInfoItem.delete({
     *   where: {
     *     // ... filter to delete one ContactInfoItem
     *   }
     * })
     * 
     */
    delete<T extends ContactInfoItemDeleteArgs>(args: SelectSubset<T, ContactInfoItemDeleteArgs<ExtArgs>>): Prisma__ContactInfoItemClient<$Result.GetResult<Prisma.$ContactInfoItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactInfoItem.
     * @param {ContactInfoItemUpdateArgs} args - Arguments to update one ContactInfoItem.
     * @example
     * // Update one ContactInfoItem
     * const contactInfoItem = await prisma.contactInfoItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactInfoItemUpdateArgs>(args: SelectSubset<T, ContactInfoItemUpdateArgs<ExtArgs>>): Prisma__ContactInfoItemClient<$Result.GetResult<Prisma.$ContactInfoItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactInfoItems.
     * @param {ContactInfoItemDeleteManyArgs} args - Arguments to filter ContactInfoItems to delete.
     * @example
     * // Delete a few ContactInfoItems
     * const { count } = await prisma.contactInfoItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactInfoItemDeleteManyArgs>(args?: SelectSubset<T, ContactInfoItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactInfoItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactInfoItems
     * const contactInfoItem = await prisma.contactInfoItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactInfoItemUpdateManyArgs>(args: SelectSubset<T, ContactInfoItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactInfoItem.
     * @param {ContactInfoItemUpsertArgs} args - Arguments to update or create a ContactInfoItem.
     * @example
     * // Update or create a ContactInfoItem
     * const contactInfoItem = await prisma.contactInfoItem.upsert({
     *   create: {
     *     // ... data to create a ContactInfoItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactInfoItem we want to update
     *   }
     * })
     */
    upsert<T extends ContactInfoItemUpsertArgs>(args: SelectSubset<T, ContactInfoItemUpsertArgs<ExtArgs>>): Prisma__ContactInfoItemClient<$Result.GetResult<Prisma.$ContactInfoItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactInfoItems that matches the filter.
     * @param {ContactInfoItemFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contactInfoItem = await prisma.contactInfoItem.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ContactInfoItemFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ContactInfoItem.
     * @param {ContactInfoItemAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contactInfoItem = await prisma.contactInfoItem.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ContactInfoItemAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ContactInfoItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoItemCountArgs} args - Arguments to filter ContactInfoItems to count.
     * @example
     * // Count the number of ContactInfoItems
     * const count = await prisma.contactInfoItem.count({
     *   where: {
     *     // ... the filter for the ContactInfoItems we want to count
     *   }
     * })
    **/
    count<T extends ContactInfoItemCountArgs>(
      args?: Subset<T, ContactInfoItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactInfoItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactInfoItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactInfoItemAggregateArgs>(args: Subset<T, ContactInfoItemAggregateArgs>): Prisma.PrismaPromise<GetContactInfoItemAggregateType<T>>

    /**
     * Group by ContactInfoItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactInfoItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactInfoItemGroupByArgs['orderBy'] }
        : { orderBy?: ContactInfoItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactInfoItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactInfoItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactInfoItem model
   */
  readonly fields: ContactInfoItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactInfoItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactInfoItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactInfoItem model
   */
  interface ContactInfoItemFieldRefs {
    readonly id: FieldRef<"ContactInfoItem", 'String'>
    readonly type: FieldRef<"ContactInfoItem", 'String'>
    readonly value: FieldRef<"ContactInfoItem", 'String'>
    readonly label: FieldRef<"ContactInfoItem", 'String'>
    readonly icon: FieldRef<"ContactInfoItem", 'String'>
    readonly order: FieldRef<"ContactInfoItem", 'Int'>
    readonly sectionId: FieldRef<"ContactInfoItem", 'String'>
    readonly createdAt: FieldRef<"ContactInfoItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactInfoItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactInfoItem findUnique
   */
  export type ContactInfoItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfoItem
     */
    select?: ContactInfoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfoItem
     */
    omit?: ContactInfoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInfoItemInclude<ExtArgs> | null
    /**
     * Filter, which ContactInfoItem to fetch.
     */
    where: ContactInfoItemWhereUniqueInput
  }

  /**
   * ContactInfoItem findUniqueOrThrow
   */
  export type ContactInfoItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfoItem
     */
    select?: ContactInfoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfoItem
     */
    omit?: ContactInfoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInfoItemInclude<ExtArgs> | null
    /**
     * Filter, which ContactInfoItem to fetch.
     */
    where: ContactInfoItemWhereUniqueInput
  }

  /**
   * ContactInfoItem findFirst
   */
  export type ContactInfoItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfoItem
     */
    select?: ContactInfoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfoItem
     */
    omit?: ContactInfoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInfoItemInclude<ExtArgs> | null
    /**
     * Filter, which ContactInfoItem to fetch.
     */
    where?: ContactInfoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInfoItems to fetch.
     */
    orderBy?: ContactInfoItemOrderByWithRelationInput | ContactInfoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactInfoItems.
     */
    cursor?: ContactInfoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInfoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInfoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactInfoItems.
     */
    distinct?: ContactInfoItemScalarFieldEnum | ContactInfoItemScalarFieldEnum[]
  }

  /**
   * ContactInfoItem findFirstOrThrow
   */
  export type ContactInfoItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfoItem
     */
    select?: ContactInfoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfoItem
     */
    omit?: ContactInfoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInfoItemInclude<ExtArgs> | null
    /**
     * Filter, which ContactInfoItem to fetch.
     */
    where?: ContactInfoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInfoItems to fetch.
     */
    orderBy?: ContactInfoItemOrderByWithRelationInput | ContactInfoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactInfoItems.
     */
    cursor?: ContactInfoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInfoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInfoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactInfoItems.
     */
    distinct?: ContactInfoItemScalarFieldEnum | ContactInfoItemScalarFieldEnum[]
  }

  /**
   * ContactInfoItem findMany
   */
  export type ContactInfoItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfoItem
     */
    select?: ContactInfoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfoItem
     */
    omit?: ContactInfoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInfoItemInclude<ExtArgs> | null
    /**
     * Filter, which ContactInfoItems to fetch.
     */
    where?: ContactInfoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInfoItems to fetch.
     */
    orderBy?: ContactInfoItemOrderByWithRelationInput | ContactInfoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactInfoItems.
     */
    cursor?: ContactInfoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInfoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInfoItems.
     */
    skip?: number
    distinct?: ContactInfoItemScalarFieldEnum | ContactInfoItemScalarFieldEnum[]
  }

  /**
   * ContactInfoItem create
   */
  export type ContactInfoItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfoItem
     */
    select?: ContactInfoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfoItem
     */
    omit?: ContactInfoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInfoItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactInfoItem.
     */
    data: XOR<ContactInfoItemCreateInput, ContactInfoItemUncheckedCreateInput>
  }

  /**
   * ContactInfoItem createMany
   */
  export type ContactInfoItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactInfoItems.
     */
    data: ContactInfoItemCreateManyInput | ContactInfoItemCreateManyInput[]
  }

  /**
   * ContactInfoItem update
   */
  export type ContactInfoItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfoItem
     */
    select?: ContactInfoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfoItem
     */
    omit?: ContactInfoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInfoItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactInfoItem.
     */
    data: XOR<ContactInfoItemUpdateInput, ContactInfoItemUncheckedUpdateInput>
    /**
     * Choose, which ContactInfoItem to update.
     */
    where: ContactInfoItemWhereUniqueInput
  }

  /**
   * ContactInfoItem updateMany
   */
  export type ContactInfoItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactInfoItems.
     */
    data: XOR<ContactInfoItemUpdateManyMutationInput, ContactInfoItemUncheckedUpdateManyInput>
    /**
     * Filter which ContactInfoItems to update
     */
    where?: ContactInfoItemWhereInput
    /**
     * Limit how many ContactInfoItems to update.
     */
    limit?: number
  }

  /**
   * ContactInfoItem upsert
   */
  export type ContactInfoItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfoItem
     */
    select?: ContactInfoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfoItem
     */
    omit?: ContactInfoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInfoItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactInfoItem to update in case it exists.
     */
    where: ContactInfoItemWhereUniqueInput
    /**
     * In case the ContactInfoItem found by the `where` argument doesn't exist, create a new ContactInfoItem with this data.
     */
    create: XOR<ContactInfoItemCreateInput, ContactInfoItemUncheckedCreateInput>
    /**
     * In case the ContactInfoItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactInfoItemUpdateInput, ContactInfoItemUncheckedUpdateInput>
  }

  /**
   * ContactInfoItem delete
   */
  export type ContactInfoItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfoItem
     */
    select?: ContactInfoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfoItem
     */
    omit?: ContactInfoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInfoItemInclude<ExtArgs> | null
    /**
     * Filter which ContactInfoItem to delete.
     */
    where: ContactInfoItemWhereUniqueInput
  }

  /**
   * ContactInfoItem deleteMany
   */
  export type ContactInfoItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactInfoItems to delete
     */
    where?: ContactInfoItemWhereInput
    /**
     * Limit how many ContactInfoItems to delete.
     */
    limit?: number
  }

  /**
   * ContactInfoItem findRaw
   */
  export type ContactInfoItemFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContactInfoItem aggregateRaw
   */
  export type ContactInfoItemAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContactInfoItem without action
   */
  export type ContactInfoItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfoItem
     */
    select?: ContactInfoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfoItem
     */
    omit?: ContactInfoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInfoItemInclude<ExtArgs> | null
  }


  /**
   * Model CustomSectionContentBlock
   */

  export type AggregateCustomSectionContentBlock = {
    _count: CustomSectionContentBlockCountAggregateOutputType | null
    _avg: CustomSectionContentBlockAvgAggregateOutputType | null
    _sum: CustomSectionContentBlockSumAggregateOutputType | null
    _min: CustomSectionContentBlockMinAggregateOutputType | null
    _max: CustomSectionContentBlockMaxAggregateOutputType | null
  }

  export type CustomSectionContentBlockAvgAggregateOutputType = {
    order: number | null
  }

  export type CustomSectionContentBlockSumAggregateOutputType = {
    order: number | null
  }

  export type CustomSectionContentBlockMinAggregateOutputType = {
    id: string | null
    type: string | null
    content: string | null
    imageSrc: string | null
    imageAlt: string | null
    linkUrl: string | null
    imagePublicId: string | null
    order: number | null
    sectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomSectionContentBlockMaxAggregateOutputType = {
    id: string | null
    type: string | null
    content: string | null
    imageSrc: string | null
    imageAlt: string | null
    linkUrl: string | null
    imagePublicId: string | null
    order: number | null
    sectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomSectionContentBlockCountAggregateOutputType = {
    id: number
    type: number
    content: number
    imageSrc: number
    imageAlt: number
    linkUrl: number
    imagePublicId: number
    order: number
    sectionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomSectionContentBlockAvgAggregateInputType = {
    order?: true
  }

  export type CustomSectionContentBlockSumAggregateInputType = {
    order?: true
  }

  export type CustomSectionContentBlockMinAggregateInputType = {
    id?: true
    type?: true
    content?: true
    imageSrc?: true
    imageAlt?: true
    linkUrl?: true
    imagePublicId?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomSectionContentBlockMaxAggregateInputType = {
    id?: true
    type?: true
    content?: true
    imageSrc?: true
    imageAlt?: true
    linkUrl?: true
    imagePublicId?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomSectionContentBlockCountAggregateInputType = {
    id?: true
    type?: true
    content?: true
    imageSrc?: true
    imageAlt?: true
    linkUrl?: true
    imagePublicId?: true
    order?: true
    sectionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomSectionContentBlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomSectionContentBlock to aggregate.
     */
    where?: CustomSectionContentBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomSectionContentBlocks to fetch.
     */
    orderBy?: CustomSectionContentBlockOrderByWithRelationInput | CustomSectionContentBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomSectionContentBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomSectionContentBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomSectionContentBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomSectionContentBlocks
    **/
    _count?: true | CustomSectionContentBlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomSectionContentBlockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomSectionContentBlockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomSectionContentBlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomSectionContentBlockMaxAggregateInputType
  }

  export type GetCustomSectionContentBlockAggregateType<T extends CustomSectionContentBlockAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomSectionContentBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomSectionContentBlock[P]>
      : GetScalarType<T[P], AggregateCustomSectionContentBlock[P]>
  }




  export type CustomSectionContentBlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomSectionContentBlockWhereInput
    orderBy?: CustomSectionContentBlockOrderByWithAggregationInput | CustomSectionContentBlockOrderByWithAggregationInput[]
    by: CustomSectionContentBlockScalarFieldEnum[] | CustomSectionContentBlockScalarFieldEnum
    having?: CustomSectionContentBlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomSectionContentBlockCountAggregateInputType | true
    _avg?: CustomSectionContentBlockAvgAggregateInputType
    _sum?: CustomSectionContentBlockSumAggregateInputType
    _min?: CustomSectionContentBlockMinAggregateInputType
    _max?: CustomSectionContentBlockMaxAggregateInputType
  }

  export type CustomSectionContentBlockGroupByOutputType = {
    id: string
    type: string
    content: string | null
    imageSrc: string | null
    imageAlt: string | null
    linkUrl: string | null
    imagePublicId: string | null
    order: number
    sectionId: string
    createdAt: Date
    updatedAt: Date
    _count: CustomSectionContentBlockCountAggregateOutputType | null
    _avg: CustomSectionContentBlockAvgAggregateOutputType | null
    _sum: CustomSectionContentBlockSumAggregateOutputType | null
    _min: CustomSectionContentBlockMinAggregateOutputType | null
    _max: CustomSectionContentBlockMaxAggregateOutputType | null
  }

  type GetCustomSectionContentBlockGroupByPayload<T extends CustomSectionContentBlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomSectionContentBlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomSectionContentBlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomSectionContentBlockGroupByOutputType[P]>
            : GetScalarType<T[P], CustomSectionContentBlockGroupByOutputType[P]>
        }
      >
    >


  export type CustomSectionContentBlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    content?: boolean
    imageSrc?: boolean
    imageAlt?: boolean
    linkUrl?: boolean
    imagePublicId?: boolean
    order?: boolean
    sectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customSectionContentBlock"]>



  export type CustomSectionContentBlockSelectScalar = {
    id?: boolean
    type?: boolean
    content?: boolean
    imageSrc?: boolean
    imageAlt?: boolean
    linkUrl?: boolean
    imagePublicId?: boolean
    order?: boolean
    sectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomSectionContentBlockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "content" | "imageSrc" | "imageAlt" | "linkUrl" | "imagePublicId" | "order" | "sectionId" | "createdAt" | "updatedAt", ExtArgs["result"]["customSectionContentBlock"]>
  export type CustomSectionContentBlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }

  export type $CustomSectionContentBlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomSectionContentBlock"
    objects: {
      section: Prisma.$SectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      content: string | null
      imageSrc: string | null
      imageAlt: string | null
      linkUrl: string | null
      imagePublicId: string | null
      order: number
      sectionId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customSectionContentBlock"]>
    composites: {}
  }

  type CustomSectionContentBlockGetPayload<S extends boolean | null | undefined | CustomSectionContentBlockDefaultArgs> = $Result.GetResult<Prisma.$CustomSectionContentBlockPayload, S>

  type CustomSectionContentBlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomSectionContentBlockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomSectionContentBlockCountAggregateInputType | true
    }

  export interface CustomSectionContentBlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomSectionContentBlock'], meta: { name: 'CustomSectionContentBlock' } }
    /**
     * Find zero or one CustomSectionContentBlock that matches the filter.
     * @param {CustomSectionContentBlockFindUniqueArgs} args - Arguments to find a CustomSectionContentBlock
     * @example
     * // Get one CustomSectionContentBlock
     * const customSectionContentBlock = await prisma.customSectionContentBlock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomSectionContentBlockFindUniqueArgs>(args: SelectSubset<T, CustomSectionContentBlockFindUniqueArgs<ExtArgs>>): Prisma__CustomSectionContentBlockClient<$Result.GetResult<Prisma.$CustomSectionContentBlockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomSectionContentBlock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomSectionContentBlockFindUniqueOrThrowArgs} args - Arguments to find a CustomSectionContentBlock
     * @example
     * // Get one CustomSectionContentBlock
     * const customSectionContentBlock = await prisma.customSectionContentBlock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomSectionContentBlockFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomSectionContentBlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomSectionContentBlockClient<$Result.GetResult<Prisma.$CustomSectionContentBlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomSectionContentBlock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomSectionContentBlockFindFirstArgs} args - Arguments to find a CustomSectionContentBlock
     * @example
     * // Get one CustomSectionContentBlock
     * const customSectionContentBlock = await prisma.customSectionContentBlock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomSectionContentBlockFindFirstArgs>(args?: SelectSubset<T, CustomSectionContentBlockFindFirstArgs<ExtArgs>>): Prisma__CustomSectionContentBlockClient<$Result.GetResult<Prisma.$CustomSectionContentBlockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomSectionContentBlock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomSectionContentBlockFindFirstOrThrowArgs} args - Arguments to find a CustomSectionContentBlock
     * @example
     * // Get one CustomSectionContentBlock
     * const customSectionContentBlock = await prisma.customSectionContentBlock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomSectionContentBlockFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomSectionContentBlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomSectionContentBlockClient<$Result.GetResult<Prisma.$CustomSectionContentBlockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomSectionContentBlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomSectionContentBlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomSectionContentBlocks
     * const customSectionContentBlocks = await prisma.customSectionContentBlock.findMany()
     * 
     * // Get first 10 CustomSectionContentBlocks
     * const customSectionContentBlocks = await prisma.customSectionContentBlock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customSectionContentBlockWithIdOnly = await prisma.customSectionContentBlock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomSectionContentBlockFindManyArgs>(args?: SelectSubset<T, CustomSectionContentBlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomSectionContentBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomSectionContentBlock.
     * @param {CustomSectionContentBlockCreateArgs} args - Arguments to create a CustomSectionContentBlock.
     * @example
     * // Create one CustomSectionContentBlock
     * const CustomSectionContentBlock = await prisma.customSectionContentBlock.create({
     *   data: {
     *     // ... data to create a CustomSectionContentBlock
     *   }
     * })
     * 
     */
    create<T extends CustomSectionContentBlockCreateArgs>(args: SelectSubset<T, CustomSectionContentBlockCreateArgs<ExtArgs>>): Prisma__CustomSectionContentBlockClient<$Result.GetResult<Prisma.$CustomSectionContentBlockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomSectionContentBlocks.
     * @param {CustomSectionContentBlockCreateManyArgs} args - Arguments to create many CustomSectionContentBlocks.
     * @example
     * // Create many CustomSectionContentBlocks
     * const customSectionContentBlock = await prisma.customSectionContentBlock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomSectionContentBlockCreateManyArgs>(args?: SelectSubset<T, CustomSectionContentBlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomSectionContentBlock.
     * @param {CustomSectionContentBlockDeleteArgs} args - Arguments to delete one CustomSectionContentBlock.
     * @example
     * // Delete one CustomSectionContentBlock
     * const CustomSectionContentBlock = await prisma.customSectionContentBlock.delete({
     *   where: {
     *     // ... filter to delete one CustomSectionContentBlock
     *   }
     * })
     * 
     */
    delete<T extends CustomSectionContentBlockDeleteArgs>(args: SelectSubset<T, CustomSectionContentBlockDeleteArgs<ExtArgs>>): Prisma__CustomSectionContentBlockClient<$Result.GetResult<Prisma.$CustomSectionContentBlockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomSectionContentBlock.
     * @param {CustomSectionContentBlockUpdateArgs} args - Arguments to update one CustomSectionContentBlock.
     * @example
     * // Update one CustomSectionContentBlock
     * const customSectionContentBlock = await prisma.customSectionContentBlock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomSectionContentBlockUpdateArgs>(args: SelectSubset<T, CustomSectionContentBlockUpdateArgs<ExtArgs>>): Prisma__CustomSectionContentBlockClient<$Result.GetResult<Prisma.$CustomSectionContentBlockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomSectionContentBlocks.
     * @param {CustomSectionContentBlockDeleteManyArgs} args - Arguments to filter CustomSectionContentBlocks to delete.
     * @example
     * // Delete a few CustomSectionContentBlocks
     * const { count } = await prisma.customSectionContentBlock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomSectionContentBlockDeleteManyArgs>(args?: SelectSubset<T, CustomSectionContentBlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomSectionContentBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomSectionContentBlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomSectionContentBlocks
     * const customSectionContentBlock = await prisma.customSectionContentBlock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomSectionContentBlockUpdateManyArgs>(args: SelectSubset<T, CustomSectionContentBlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomSectionContentBlock.
     * @param {CustomSectionContentBlockUpsertArgs} args - Arguments to update or create a CustomSectionContentBlock.
     * @example
     * // Update or create a CustomSectionContentBlock
     * const customSectionContentBlock = await prisma.customSectionContentBlock.upsert({
     *   create: {
     *     // ... data to create a CustomSectionContentBlock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomSectionContentBlock we want to update
     *   }
     * })
     */
    upsert<T extends CustomSectionContentBlockUpsertArgs>(args: SelectSubset<T, CustomSectionContentBlockUpsertArgs<ExtArgs>>): Prisma__CustomSectionContentBlockClient<$Result.GetResult<Prisma.$CustomSectionContentBlockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomSectionContentBlocks that matches the filter.
     * @param {CustomSectionContentBlockFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const customSectionContentBlock = await prisma.customSectionContentBlock.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CustomSectionContentBlockFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CustomSectionContentBlock.
     * @param {CustomSectionContentBlockAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const customSectionContentBlock = await prisma.customSectionContentBlock.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CustomSectionContentBlockAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of CustomSectionContentBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomSectionContentBlockCountArgs} args - Arguments to filter CustomSectionContentBlocks to count.
     * @example
     * // Count the number of CustomSectionContentBlocks
     * const count = await prisma.customSectionContentBlock.count({
     *   where: {
     *     // ... the filter for the CustomSectionContentBlocks we want to count
     *   }
     * })
    **/
    count<T extends CustomSectionContentBlockCountArgs>(
      args?: Subset<T, CustomSectionContentBlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomSectionContentBlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomSectionContentBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomSectionContentBlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomSectionContentBlockAggregateArgs>(args: Subset<T, CustomSectionContentBlockAggregateArgs>): Prisma.PrismaPromise<GetCustomSectionContentBlockAggregateType<T>>

    /**
     * Group by CustomSectionContentBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomSectionContentBlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomSectionContentBlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomSectionContentBlockGroupByArgs['orderBy'] }
        : { orderBy?: CustomSectionContentBlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomSectionContentBlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomSectionContentBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomSectionContentBlock model
   */
  readonly fields: CustomSectionContentBlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomSectionContentBlock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomSectionContentBlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomSectionContentBlock model
   */
  interface CustomSectionContentBlockFieldRefs {
    readonly id: FieldRef<"CustomSectionContentBlock", 'String'>
    readonly type: FieldRef<"CustomSectionContentBlock", 'String'>
    readonly content: FieldRef<"CustomSectionContentBlock", 'String'>
    readonly imageSrc: FieldRef<"CustomSectionContentBlock", 'String'>
    readonly imageAlt: FieldRef<"CustomSectionContentBlock", 'String'>
    readonly linkUrl: FieldRef<"CustomSectionContentBlock", 'String'>
    readonly imagePublicId: FieldRef<"CustomSectionContentBlock", 'String'>
    readonly order: FieldRef<"CustomSectionContentBlock", 'Int'>
    readonly sectionId: FieldRef<"CustomSectionContentBlock", 'String'>
    readonly createdAt: FieldRef<"CustomSectionContentBlock", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomSectionContentBlock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomSectionContentBlock findUnique
   */
  export type CustomSectionContentBlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomSectionContentBlock
     */
    select?: CustomSectionContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomSectionContentBlock
     */
    omit?: CustomSectionContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomSectionContentBlockInclude<ExtArgs> | null
    /**
     * Filter, which CustomSectionContentBlock to fetch.
     */
    where: CustomSectionContentBlockWhereUniqueInput
  }

  /**
   * CustomSectionContentBlock findUniqueOrThrow
   */
  export type CustomSectionContentBlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomSectionContentBlock
     */
    select?: CustomSectionContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomSectionContentBlock
     */
    omit?: CustomSectionContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomSectionContentBlockInclude<ExtArgs> | null
    /**
     * Filter, which CustomSectionContentBlock to fetch.
     */
    where: CustomSectionContentBlockWhereUniqueInput
  }

  /**
   * CustomSectionContentBlock findFirst
   */
  export type CustomSectionContentBlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomSectionContentBlock
     */
    select?: CustomSectionContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomSectionContentBlock
     */
    omit?: CustomSectionContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomSectionContentBlockInclude<ExtArgs> | null
    /**
     * Filter, which CustomSectionContentBlock to fetch.
     */
    where?: CustomSectionContentBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomSectionContentBlocks to fetch.
     */
    orderBy?: CustomSectionContentBlockOrderByWithRelationInput | CustomSectionContentBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomSectionContentBlocks.
     */
    cursor?: CustomSectionContentBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomSectionContentBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomSectionContentBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomSectionContentBlocks.
     */
    distinct?: CustomSectionContentBlockScalarFieldEnum | CustomSectionContentBlockScalarFieldEnum[]
  }

  /**
   * CustomSectionContentBlock findFirstOrThrow
   */
  export type CustomSectionContentBlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomSectionContentBlock
     */
    select?: CustomSectionContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomSectionContentBlock
     */
    omit?: CustomSectionContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomSectionContentBlockInclude<ExtArgs> | null
    /**
     * Filter, which CustomSectionContentBlock to fetch.
     */
    where?: CustomSectionContentBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomSectionContentBlocks to fetch.
     */
    orderBy?: CustomSectionContentBlockOrderByWithRelationInput | CustomSectionContentBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomSectionContentBlocks.
     */
    cursor?: CustomSectionContentBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomSectionContentBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomSectionContentBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomSectionContentBlocks.
     */
    distinct?: CustomSectionContentBlockScalarFieldEnum | CustomSectionContentBlockScalarFieldEnum[]
  }

  /**
   * CustomSectionContentBlock findMany
   */
  export type CustomSectionContentBlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomSectionContentBlock
     */
    select?: CustomSectionContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomSectionContentBlock
     */
    omit?: CustomSectionContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomSectionContentBlockInclude<ExtArgs> | null
    /**
     * Filter, which CustomSectionContentBlocks to fetch.
     */
    where?: CustomSectionContentBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomSectionContentBlocks to fetch.
     */
    orderBy?: CustomSectionContentBlockOrderByWithRelationInput | CustomSectionContentBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomSectionContentBlocks.
     */
    cursor?: CustomSectionContentBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomSectionContentBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomSectionContentBlocks.
     */
    skip?: number
    distinct?: CustomSectionContentBlockScalarFieldEnum | CustomSectionContentBlockScalarFieldEnum[]
  }

  /**
   * CustomSectionContentBlock create
   */
  export type CustomSectionContentBlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomSectionContentBlock
     */
    select?: CustomSectionContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomSectionContentBlock
     */
    omit?: CustomSectionContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomSectionContentBlockInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomSectionContentBlock.
     */
    data: XOR<CustomSectionContentBlockCreateInput, CustomSectionContentBlockUncheckedCreateInput>
  }

  /**
   * CustomSectionContentBlock createMany
   */
  export type CustomSectionContentBlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomSectionContentBlocks.
     */
    data: CustomSectionContentBlockCreateManyInput | CustomSectionContentBlockCreateManyInput[]
  }

  /**
   * CustomSectionContentBlock update
   */
  export type CustomSectionContentBlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomSectionContentBlock
     */
    select?: CustomSectionContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomSectionContentBlock
     */
    omit?: CustomSectionContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomSectionContentBlockInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomSectionContentBlock.
     */
    data: XOR<CustomSectionContentBlockUpdateInput, CustomSectionContentBlockUncheckedUpdateInput>
    /**
     * Choose, which CustomSectionContentBlock to update.
     */
    where: CustomSectionContentBlockWhereUniqueInput
  }

  /**
   * CustomSectionContentBlock updateMany
   */
  export type CustomSectionContentBlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomSectionContentBlocks.
     */
    data: XOR<CustomSectionContentBlockUpdateManyMutationInput, CustomSectionContentBlockUncheckedUpdateManyInput>
    /**
     * Filter which CustomSectionContentBlocks to update
     */
    where?: CustomSectionContentBlockWhereInput
    /**
     * Limit how many CustomSectionContentBlocks to update.
     */
    limit?: number
  }

  /**
   * CustomSectionContentBlock upsert
   */
  export type CustomSectionContentBlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomSectionContentBlock
     */
    select?: CustomSectionContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomSectionContentBlock
     */
    omit?: CustomSectionContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomSectionContentBlockInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomSectionContentBlock to update in case it exists.
     */
    where: CustomSectionContentBlockWhereUniqueInput
    /**
     * In case the CustomSectionContentBlock found by the `where` argument doesn't exist, create a new CustomSectionContentBlock with this data.
     */
    create: XOR<CustomSectionContentBlockCreateInput, CustomSectionContentBlockUncheckedCreateInput>
    /**
     * In case the CustomSectionContentBlock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomSectionContentBlockUpdateInput, CustomSectionContentBlockUncheckedUpdateInput>
  }

  /**
   * CustomSectionContentBlock delete
   */
  export type CustomSectionContentBlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomSectionContentBlock
     */
    select?: CustomSectionContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomSectionContentBlock
     */
    omit?: CustomSectionContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomSectionContentBlockInclude<ExtArgs> | null
    /**
     * Filter which CustomSectionContentBlock to delete.
     */
    where: CustomSectionContentBlockWhereUniqueInput
  }

  /**
   * CustomSectionContentBlock deleteMany
   */
  export type CustomSectionContentBlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomSectionContentBlocks to delete
     */
    where?: CustomSectionContentBlockWhereInput
    /**
     * Limit how many CustomSectionContentBlocks to delete.
     */
    limit?: number
  }

  /**
   * CustomSectionContentBlock findRaw
   */
  export type CustomSectionContentBlockFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CustomSectionContentBlock aggregateRaw
   */
  export type CustomSectionContentBlockAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CustomSectionContentBlock without action
   */
  export type CustomSectionContentBlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomSectionContentBlock
     */
    select?: CustomSectionContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomSectionContentBlock
     */
    omit?: CustomSectionContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomSectionContentBlockInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    isAdmin: 'isAdmin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SectionScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    type: 'type',
    visible: 'visible',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SectionScalarFieldEnum = (typeof SectionScalarFieldEnum)[keyof typeof SectionScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectIds: 'projectIds'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    id: 'id',
    siteTitle: 'siteTitle',
    theme: 'theme',
    showPortrait: 'showPortrait',
    resumeUrl: 'resumeUrl',
    globalFontFamily: 'globalFontFamily',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const TextBlockScalarFieldEnum: {
    id: 'id',
    content: 'content',
    order: 'order',
    sectionId: 'sectionId',
    fontSize: 'fontSize',
    fontFamily: 'fontFamily',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TextBlockScalarFieldEnum = (typeof TextBlockScalarFieldEnum)[keyof typeof TextBlockScalarFieldEnum]


  export const ImageBlockScalarFieldEnum: {
    id: 'id',
    src: 'src',
    alt: 'alt',
    caption: 'caption',
    imagePublicId: 'imagePublicId',
    order: 'order',
    sectionId: 'sectionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ImageBlockScalarFieldEnum = (typeof ImageBlockScalarFieldEnum)[keyof typeof ImageBlockScalarFieldEnum]


  export const HeroSectionContentScalarFieldEnum: {
    id: 'id',
    portraitImageSrc: 'portraitImageSrc',
    portraitImagePublicId: 'portraitImagePublicId',
    portraitAlt: 'portraitAlt',
    sectionId: 'sectionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HeroSectionContentScalarFieldEnum = (typeof HeroSectionContentScalarFieldEnum)[keyof typeof HeroSectionContentScalarFieldEnum]


  export const EducationItemScalarFieldEnum: {
    id: 'id',
    institution: 'institution',
    degree: 'degree',
    period: 'period',
    description: 'description',
    order: 'order',
    sectionId: 'sectionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EducationItemScalarFieldEnum = (typeof EducationItemScalarFieldEnum)[keyof typeof EducationItemScalarFieldEnum]


  export const EducationImageScalarFieldEnum: {
    id: 'id',
    src: 'src',
    imagePublicId: 'imagePublicId',
    alt: 'alt',
    caption: 'caption',
    order: 'order',
    educationItemId: 'educationItemId',
    createdAt: 'createdAt'
  };

  export type EducationImageScalarFieldEnum = (typeof EducationImageScalarFieldEnum)[keyof typeof EducationImageScalarFieldEnum]


  export const SkillItemScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    level: 'level',
    order: 'order',
    sectionId: 'sectionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SkillItemScalarFieldEnum = (typeof SkillItemScalarFieldEnum)[keyof typeof SkillItemScalarFieldEnum]


  export const SkillImageScalarFieldEnum: {
    id: 'id',
    src: 'src',
    imagePublicId: 'imagePublicId',
    alt: 'alt',
    caption: 'caption',
    order: 'order',
    sectionId: 'sectionId',
    createdAt: 'createdAt'
  };

  export type SkillImageScalarFieldEnum = (typeof SkillImageScalarFieldEnum)[keyof typeof SkillImageScalarFieldEnum]


  export const ExperienceItemScalarFieldEnum: {
    id: 'id',
    positionTitle: 'positionTitle',
    companyName: 'companyName',
    period: 'period',
    summary: 'summary',
    description: 'description',
    imageSrc: 'imageSrc',
    imagePublicId: 'imagePublicId',
    order: 'order',
    sectionId: 'sectionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExperienceItemScalarFieldEnum = (typeof ExperienceItemScalarFieldEnum)[keyof typeof ExperienceItemScalarFieldEnum]


  export const ExperienceDetailImageScalarFieldEnum: {
    id: 'id',
    src: 'src',
    imagePublicId: 'imagePublicId',
    alt: 'alt',
    caption: 'caption',
    order: 'order',
    experienceItemId: 'experienceItemId',
    createdAt: 'createdAt'
  };

  export type ExperienceDetailImageScalarFieldEnum = (typeof ExperienceDetailImageScalarFieldEnum)[keyof typeof ExperienceDetailImageScalarFieldEnum]


  export const ProjectItemScalarFieldEnum: {
    id: 'id',
    projectNumber: 'projectNumber',
    title: 'title',
    companyName: 'companyName',
    description1: 'description1',
    description2: 'description2',
    imageSrc: 'imageSrc',
    imagePublicId: 'imagePublicId',
    liveLink: 'liveLink',
    sourceLink: 'sourceLink',
    layout: 'layout',
    order: 'order',
    sectionId: 'sectionId',
    categoryIds: 'categoryIds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectItemScalarFieldEnum = (typeof ProjectItemScalarFieldEnum)[keyof typeof ProjectItemScalarFieldEnum]


  export const TestimonialItemScalarFieldEnum: {
    id: 'id',
    clientName: 'clientName',
    role: 'role',
    company: 'company',
    content: 'content',
    rating: 'rating',
    imageSrc: 'imageSrc',
    imagePublicId: 'imagePublicId',
    order: 'order',
    sectionId: 'sectionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestimonialItemScalarFieldEnum = (typeof TestimonialItemScalarFieldEnum)[keyof typeof TestimonialItemScalarFieldEnum]


  export const ContactInfoItemScalarFieldEnum: {
    id: 'id',
    type: 'type',
    value: 'value',
    label: 'label',
    icon: 'icon',
    order: 'order',
    sectionId: 'sectionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactInfoItemScalarFieldEnum = (typeof ContactInfoItemScalarFieldEnum)[keyof typeof ContactInfoItemScalarFieldEnum]


  export const CustomSectionContentBlockScalarFieldEnum: {
    id: 'id',
    type: 'type',
    content: 'content',
    imageSrc: 'imageSrc',
    imageAlt: 'imageAlt',
    linkUrl: 'linkUrl',
    imagePublicId: 'imagePublicId',
    order: 'order',
    sectionId: 'sectionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomSectionContentBlockScalarFieldEnum = (typeof CustomSectionContentBlockScalarFieldEnum)[keyof typeof CustomSectionContentBlockScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    isAdmin?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    isAdmin?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    isAdmin?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SectionWhereInput = {
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    id?: StringFilter<"Section"> | string
    slug?: StringFilter<"Section"> | string
    title?: StringFilter<"Section"> | string
    type?: StringFilter<"Section"> | string
    visible?: BoolFilter<"Section"> | boolean
    order?: IntFilter<"Section"> | number
    createdAt?: DateTimeFilter<"Section"> | Date | string
    updatedAt?: DateTimeFilter<"Section"> | Date | string
    textBlocks?: TextBlockListRelationFilter
    imageBlocks?: ImageBlockListRelationFilter
    heroContent?: XOR<HeroSectionContentNullableScalarRelationFilter, HeroSectionContentWhereInput> | null
    educationItems?: EducationItemListRelationFilter
    skillItems?: SkillItemListRelationFilter
    skillImages?: SkillImageListRelationFilter
    experienceItems?: ExperienceItemListRelationFilter
    projectItems?: ProjectItemListRelationFilter
    testimonialItems?: TestimonialItemListRelationFilter
    contactInfoItems?: ContactInfoItemListRelationFilter
    customSectionContentBlocks?: CustomSectionContentBlockListRelationFilter
  }

  export type SectionOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    type?: SortOrder
    visible?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    textBlocks?: TextBlockOrderByRelationAggregateInput
    imageBlocks?: ImageBlockOrderByRelationAggregateInput
    heroContent?: HeroSectionContentOrderByWithRelationInput
    educationItems?: EducationItemOrderByRelationAggregateInput
    skillItems?: SkillItemOrderByRelationAggregateInput
    skillImages?: SkillImageOrderByRelationAggregateInput
    experienceItems?: ExperienceItemOrderByRelationAggregateInput
    projectItems?: ProjectItemOrderByRelationAggregateInput
    testimonialItems?: TestimonialItemOrderByRelationAggregateInput
    contactInfoItems?: ContactInfoItemOrderByRelationAggregateInput
    customSectionContentBlocks?: CustomSectionContentBlockOrderByRelationAggregateInput
  }

  export type SectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    title?: StringFilter<"Section"> | string
    type?: StringFilter<"Section"> | string
    visible?: BoolFilter<"Section"> | boolean
    order?: IntFilter<"Section"> | number
    createdAt?: DateTimeFilter<"Section"> | Date | string
    updatedAt?: DateTimeFilter<"Section"> | Date | string
    textBlocks?: TextBlockListRelationFilter
    imageBlocks?: ImageBlockListRelationFilter
    heroContent?: XOR<HeroSectionContentNullableScalarRelationFilter, HeroSectionContentWhereInput> | null
    educationItems?: EducationItemListRelationFilter
    skillItems?: SkillItemListRelationFilter
    skillImages?: SkillImageListRelationFilter
    experienceItems?: ExperienceItemListRelationFilter
    projectItems?: ProjectItemListRelationFilter
    testimonialItems?: TestimonialItemListRelationFilter
    contactInfoItems?: ContactInfoItemListRelationFilter
    customSectionContentBlocks?: CustomSectionContentBlockListRelationFilter
  }, "id" | "slug">

  export type SectionOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    type?: SortOrder
    visible?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SectionCountOrderByAggregateInput
    _avg?: SectionAvgOrderByAggregateInput
    _max?: SectionMaxOrderByAggregateInput
    _min?: SectionMinOrderByAggregateInput
    _sum?: SectionSumOrderByAggregateInput
  }

  export type SectionScalarWhereWithAggregatesInput = {
    AND?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    OR?: SectionScalarWhereWithAggregatesInput[]
    NOT?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Section"> | string
    slug?: StringWithAggregatesFilter<"Section"> | string
    title?: StringWithAggregatesFilter<"Section"> | string
    type?: StringWithAggregatesFilter<"Section"> | string
    visible?: BoolWithAggregatesFilter<"Section"> | boolean
    order?: IntWithAggregatesFilter<"Section"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Section"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Section"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    order?: IntFilter<"Category"> | number
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    projectIds?: StringNullableListFilter<"Category">
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectIds?: SortOrder
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    order?: IntFilter<"Category"> | number
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    projectIds?: StringNullableListFilter<"Category">
  }, "id" | "name">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectIds?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    order?: IntWithAggregatesFilter<"Category"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    projectIds?: StringNullableListFilter<"Category">
  }

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    id?: StringFilter<"Setting"> | string
    siteTitle?: StringFilter<"Setting"> | string
    theme?: StringFilter<"Setting"> | string
    showPortrait?: BoolFilter<"Setting"> | boolean
    resumeUrl?: StringFilter<"Setting"> | string
    globalFontFamily?: StringFilter<"Setting"> | string
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }

  export type SettingOrderByWithRelationInput = {
    id?: SortOrder
    siteTitle?: SortOrder
    theme?: SortOrder
    showPortrait?: SortOrder
    resumeUrl?: SortOrder
    globalFontFamily?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    siteTitle?: StringFilter<"Setting"> | string
    theme?: StringFilter<"Setting"> | string
    showPortrait?: BoolFilter<"Setting"> | boolean
    resumeUrl?: StringFilter<"Setting"> | string
    globalFontFamily?: StringFilter<"Setting"> | string
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }, "id">

  export type SettingOrderByWithAggregationInput = {
    id?: SortOrder
    siteTitle?: SortOrder
    theme?: SortOrder
    showPortrait?: SortOrder
    resumeUrl?: SortOrder
    globalFontFamily?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SettingCountOrderByAggregateInput
    _max?: SettingMaxOrderByAggregateInput
    _min?: SettingMinOrderByAggregateInput
  }

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    OR?: SettingScalarWhereWithAggregatesInput[]
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Setting"> | string
    siteTitle?: StringWithAggregatesFilter<"Setting"> | string
    theme?: StringWithAggregatesFilter<"Setting"> | string
    showPortrait?: BoolWithAggregatesFilter<"Setting"> | boolean
    resumeUrl?: StringWithAggregatesFilter<"Setting"> | string
    globalFontFamily?: StringWithAggregatesFilter<"Setting"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
  }

  export type TextBlockWhereInput = {
    AND?: TextBlockWhereInput | TextBlockWhereInput[]
    OR?: TextBlockWhereInput[]
    NOT?: TextBlockWhereInput | TextBlockWhereInput[]
    id?: StringFilter<"TextBlock"> | string
    content?: StringFilter<"TextBlock"> | string
    order?: IntFilter<"TextBlock"> | number
    sectionId?: StringFilter<"TextBlock"> | string
    fontSize?: IntNullableFilter<"TextBlock"> | number | null
    fontFamily?: StringNullableFilter<"TextBlock"> | string | null
    createdAt?: DateTimeFilter<"TextBlock"> | Date | string
    updatedAt?: DateTimeFilter<"TextBlock"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
  }

  export type TextBlockOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    fontSize?: SortOrder
    fontFamily?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    section?: SectionOrderByWithRelationInput
  }

  export type TextBlockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TextBlockWhereInput | TextBlockWhereInput[]
    OR?: TextBlockWhereInput[]
    NOT?: TextBlockWhereInput | TextBlockWhereInput[]
    content?: StringFilter<"TextBlock"> | string
    order?: IntFilter<"TextBlock"> | number
    sectionId?: StringFilter<"TextBlock"> | string
    fontSize?: IntNullableFilter<"TextBlock"> | number | null
    fontFamily?: StringNullableFilter<"TextBlock"> | string | null
    createdAt?: DateTimeFilter<"TextBlock"> | Date | string
    updatedAt?: DateTimeFilter<"TextBlock"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
  }, "id">

  export type TextBlockOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    fontSize?: SortOrder
    fontFamily?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TextBlockCountOrderByAggregateInput
    _avg?: TextBlockAvgOrderByAggregateInput
    _max?: TextBlockMaxOrderByAggregateInput
    _min?: TextBlockMinOrderByAggregateInput
    _sum?: TextBlockSumOrderByAggregateInput
  }

  export type TextBlockScalarWhereWithAggregatesInput = {
    AND?: TextBlockScalarWhereWithAggregatesInput | TextBlockScalarWhereWithAggregatesInput[]
    OR?: TextBlockScalarWhereWithAggregatesInput[]
    NOT?: TextBlockScalarWhereWithAggregatesInput | TextBlockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TextBlock"> | string
    content?: StringWithAggregatesFilter<"TextBlock"> | string
    order?: IntWithAggregatesFilter<"TextBlock"> | number
    sectionId?: StringWithAggregatesFilter<"TextBlock"> | string
    fontSize?: IntNullableWithAggregatesFilter<"TextBlock"> | number | null
    fontFamily?: StringNullableWithAggregatesFilter<"TextBlock"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TextBlock"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TextBlock"> | Date | string
  }

  export type ImageBlockWhereInput = {
    AND?: ImageBlockWhereInput | ImageBlockWhereInput[]
    OR?: ImageBlockWhereInput[]
    NOT?: ImageBlockWhereInput | ImageBlockWhereInput[]
    id?: StringFilter<"ImageBlock"> | string
    src?: StringFilter<"ImageBlock"> | string
    alt?: StringNullableFilter<"ImageBlock"> | string | null
    caption?: StringNullableFilter<"ImageBlock"> | string | null
    imagePublicId?: StringNullableFilter<"ImageBlock"> | string | null
    order?: IntFilter<"ImageBlock"> | number
    sectionId?: StringFilter<"ImageBlock"> | string
    createdAt?: DateTimeFilter<"ImageBlock"> | Date | string
    updatedAt?: DateTimeFilter<"ImageBlock"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
  }

  export type ImageBlockOrderByWithRelationInput = {
    id?: SortOrder
    src?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    imagePublicId?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    section?: SectionOrderByWithRelationInput
  }

  export type ImageBlockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImageBlockWhereInput | ImageBlockWhereInput[]
    OR?: ImageBlockWhereInput[]
    NOT?: ImageBlockWhereInput | ImageBlockWhereInput[]
    src?: StringFilter<"ImageBlock"> | string
    alt?: StringNullableFilter<"ImageBlock"> | string | null
    caption?: StringNullableFilter<"ImageBlock"> | string | null
    imagePublicId?: StringNullableFilter<"ImageBlock"> | string | null
    order?: IntFilter<"ImageBlock"> | number
    sectionId?: StringFilter<"ImageBlock"> | string
    createdAt?: DateTimeFilter<"ImageBlock"> | Date | string
    updatedAt?: DateTimeFilter<"ImageBlock"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
  }, "id">

  export type ImageBlockOrderByWithAggregationInput = {
    id?: SortOrder
    src?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    imagePublicId?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ImageBlockCountOrderByAggregateInput
    _avg?: ImageBlockAvgOrderByAggregateInput
    _max?: ImageBlockMaxOrderByAggregateInput
    _min?: ImageBlockMinOrderByAggregateInput
    _sum?: ImageBlockSumOrderByAggregateInput
  }

  export type ImageBlockScalarWhereWithAggregatesInput = {
    AND?: ImageBlockScalarWhereWithAggregatesInput | ImageBlockScalarWhereWithAggregatesInput[]
    OR?: ImageBlockScalarWhereWithAggregatesInput[]
    NOT?: ImageBlockScalarWhereWithAggregatesInput | ImageBlockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImageBlock"> | string
    src?: StringWithAggregatesFilter<"ImageBlock"> | string
    alt?: StringNullableWithAggregatesFilter<"ImageBlock"> | string | null
    caption?: StringNullableWithAggregatesFilter<"ImageBlock"> | string | null
    imagePublicId?: StringNullableWithAggregatesFilter<"ImageBlock"> | string | null
    order?: IntWithAggregatesFilter<"ImageBlock"> | number
    sectionId?: StringWithAggregatesFilter<"ImageBlock"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ImageBlock"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ImageBlock"> | Date | string
  }

  export type HeroSectionContentWhereInput = {
    AND?: HeroSectionContentWhereInput | HeroSectionContentWhereInput[]
    OR?: HeroSectionContentWhereInput[]
    NOT?: HeroSectionContentWhereInput | HeroSectionContentWhereInput[]
    id?: StringFilter<"HeroSectionContent"> | string
    portraitImageSrc?: StringNullableFilter<"HeroSectionContent"> | string | null
    portraitImagePublicId?: StringNullableFilter<"HeroSectionContent"> | string | null
    portraitAlt?: StringNullableFilter<"HeroSectionContent"> | string | null
    sectionId?: StringFilter<"HeroSectionContent"> | string
    createdAt?: DateTimeFilter<"HeroSectionContent"> | Date | string
    updatedAt?: DateTimeFilter<"HeroSectionContent"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
  }

  export type HeroSectionContentOrderByWithRelationInput = {
    id?: SortOrder
    portraitImageSrc?: SortOrder
    portraitImagePublicId?: SortOrder
    portraitAlt?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    section?: SectionOrderByWithRelationInput
  }

  export type HeroSectionContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sectionId?: string
    AND?: HeroSectionContentWhereInput | HeroSectionContentWhereInput[]
    OR?: HeroSectionContentWhereInput[]
    NOT?: HeroSectionContentWhereInput | HeroSectionContentWhereInput[]
    portraitImageSrc?: StringNullableFilter<"HeroSectionContent"> | string | null
    portraitImagePublicId?: StringNullableFilter<"HeroSectionContent"> | string | null
    portraitAlt?: StringNullableFilter<"HeroSectionContent"> | string | null
    createdAt?: DateTimeFilter<"HeroSectionContent"> | Date | string
    updatedAt?: DateTimeFilter<"HeroSectionContent"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
  }, "id" | "sectionId">

  export type HeroSectionContentOrderByWithAggregationInput = {
    id?: SortOrder
    portraitImageSrc?: SortOrder
    portraitImagePublicId?: SortOrder
    portraitAlt?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HeroSectionContentCountOrderByAggregateInput
    _max?: HeroSectionContentMaxOrderByAggregateInput
    _min?: HeroSectionContentMinOrderByAggregateInput
  }

  export type HeroSectionContentScalarWhereWithAggregatesInput = {
    AND?: HeroSectionContentScalarWhereWithAggregatesInput | HeroSectionContentScalarWhereWithAggregatesInput[]
    OR?: HeroSectionContentScalarWhereWithAggregatesInput[]
    NOT?: HeroSectionContentScalarWhereWithAggregatesInput | HeroSectionContentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HeroSectionContent"> | string
    portraitImageSrc?: StringNullableWithAggregatesFilter<"HeroSectionContent"> | string | null
    portraitImagePublicId?: StringNullableWithAggregatesFilter<"HeroSectionContent"> | string | null
    portraitAlt?: StringNullableWithAggregatesFilter<"HeroSectionContent"> | string | null
    sectionId?: StringWithAggregatesFilter<"HeroSectionContent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HeroSectionContent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HeroSectionContent"> | Date | string
  }

  export type EducationItemWhereInput = {
    AND?: EducationItemWhereInput | EducationItemWhereInput[]
    OR?: EducationItemWhereInput[]
    NOT?: EducationItemWhereInput | EducationItemWhereInput[]
    id?: StringFilter<"EducationItem"> | string
    institution?: StringFilter<"EducationItem"> | string
    degree?: StringNullableFilter<"EducationItem"> | string | null
    period?: StringFilter<"EducationItem"> | string
    description?: StringNullableFilter<"EducationItem"> | string | null
    order?: IntFilter<"EducationItem"> | number
    sectionId?: StringFilter<"EducationItem"> | string
    createdAt?: DateTimeFilter<"EducationItem"> | Date | string
    updatedAt?: DateTimeFilter<"EducationItem"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
    images?: EducationImageListRelationFilter
  }

  export type EducationItemOrderByWithRelationInput = {
    id?: SortOrder
    institution?: SortOrder
    degree?: SortOrder
    period?: SortOrder
    description?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    section?: SectionOrderByWithRelationInput
    images?: EducationImageOrderByRelationAggregateInput
  }

  export type EducationItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EducationItemWhereInput | EducationItemWhereInput[]
    OR?: EducationItemWhereInput[]
    NOT?: EducationItemWhereInput | EducationItemWhereInput[]
    institution?: StringFilter<"EducationItem"> | string
    degree?: StringNullableFilter<"EducationItem"> | string | null
    period?: StringFilter<"EducationItem"> | string
    description?: StringNullableFilter<"EducationItem"> | string | null
    order?: IntFilter<"EducationItem"> | number
    sectionId?: StringFilter<"EducationItem"> | string
    createdAt?: DateTimeFilter<"EducationItem"> | Date | string
    updatedAt?: DateTimeFilter<"EducationItem"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
    images?: EducationImageListRelationFilter
  }, "id">

  export type EducationItemOrderByWithAggregationInput = {
    id?: SortOrder
    institution?: SortOrder
    degree?: SortOrder
    period?: SortOrder
    description?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EducationItemCountOrderByAggregateInput
    _avg?: EducationItemAvgOrderByAggregateInput
    _max?: EducationItemMaxOrderByAggregateInput
    _min?: EducationItemMinOrderByAggregateInput
    _sum?: EducationItemSumOrderByAggregateInput
  }

  export type EducationItemScalarWhereWithAggregatesInput = {
    AND?: EducationItemScalarWhereWithAggregatesInput | EducationItemScalarWhereWithAggregatesInput[]
    OR?: EducationItemScalarWhereWithAggregatesInput[]
    NOT?: EducationItemScalarWhereWithAggregatesInput | EducationItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EducationItem"> | string
    institution?: StringWithAggregatesFilter<"EducationItem"> | string
    degree?: StringNullableWithAggregatesFilter<"EducationItem"> | string | null
    period?: StringWithAggregatesFilter<"EducationItem"> | string
    description?: StringNullableWithAggregatesFilter<"EducationItem"> | string | null
    order?: IntWithAggregatesFilter<"EducationItem"> | number
    sectionId?: StringWithAggregatesFilter<"EducationItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EducationItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EducationItem"> | Date | string
  }

  export type EducationImageWhereInput = {
    AND?: EducationImageWhereInput | EducationImageWhereInput[]
    OR?: EducationImageWhereInput[]
    NOT?: EducationImageWhereInput | EducationImageWhereInput[]
    id?: StringFilter<"EducationImage"> | string
    src?: StringFilter<"EducationImage"> | string
    imagePublicId?: StringNullableFilter<"EducationImage"> | string | null
    alt?: StringNullableFilter<"EducationImage"> | string | null
    caption?: StringNullableFilter<"EducationImage"> | string | null
    order?: IntFilter<"EducationImage"> | number
    educationItemId?: StringFilter<"EducationImage"> | string
    createdAt?: DateTimeFilter<"EducationImage"> | Date | string
    educationItem?: XOR<EducationItemScalarRelationFilter, EducationItemWhereInput>
  }

  export type EducationImageOrderByWithRelationInput = {
    id?: SortOrder
    src?: SortOrder
    imagePublicId?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    order?: SortOrder
    educationItemId?: SortOrder
    createdAt?: SortOrder
    educationItem?: EducationItemOrderByWithRelationInput
  }

  export type EducationImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EducationImageWhereInput | EducationImageWhereInput[]
    OR?: EducationImageWhereInput[]
    NOT?: EducationImageWhereInput | EducationImageWhereInput[]
    src?: StringFilter<"EducationImage"> | string
    imagePublicId?: StringNullableFilter<"EducationImage"> | string | null
    alt?: StringNullableFilter<"EducationImage"> | string | null
    caption?: StringNullableFilter<"EducationImage"> | string | null
    order?: IntFilter<"EducationImage"> | number
    educationItemId?: StringFilter<"EducationImage"> | string
    createdAt?: DateTimeFilter<"EducationImage"> | Date | string
    educationItem?: XOR<EducationItemScalarRelationFilter, EducationItemWhereInput>
  }, "id">

  export type EducationImageOrderByWithAggregationInput = {
    id?: SortOrder
    src?: SortOrder
    imagePublicId?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    order?: SortOrder
    educationItemId?: SortOrder
    createdAt?: SortOrder
    _count?: EducationImageCountOrderByAggregateInput
    _avg?: EducationImageAvgOrderByAggregateInput
    _max?: EducationImageMaxOrderByAggregateInput
    _min?: EducationImageMinOrderByAggregateInput
    _sum?: EducationImageSumOrderByAggregateInput
  }

  export type EducationImageScalarWhereWithAggregatesInput = {
    AND?: EducationImageScalarWhereWithAggregatesInput | EducationImageScalarWhereWithAggregatesInput[]
    OR?: EducationImageScalarWhereWithAggregatesInput[]
    NOT?: EducationImageScalarWhereWithAggregatesInput | EducationImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EducationImage"> | string
    src?: StringWithAggregatesFilter<"EducationImage"> | string
    imagePublicId?: StringNullableWithAggregatesFilter<"EducationImage"> | string | null
    alt?: StringNullableWithAggregatesFilter<"EducationImage"> | string | null
    caption?: StringNullableWithAggregatesFilter<"EducationImage"> | string | null
    order?: IntWithAggregatesFilter<"EducationImage"> | number
    educationItemId?: StringWithAggregatesFilter<"EducationImage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EducationImage"> | Date | string
  }

  export type SkillItemWhereInput = {
    AND?: SkillItemWhereInput | SkillItemWhereInput[]
    OR?: SkillItemWhereInput[]
    NOT?: SkillItemWhereInput | SkillItemWhereInput[]
    id?: StringFilter<"SkillItem"> | string
    title?: StringFilter<"SkillItem"> | string
    description?: StringNullableFilter<"SkillItem"> | string | null
    level?: IntNullableFilter<"SkillItem"> | number | null
    order?: IntFilter<"SkillItem"> | number
    sectionId?: StringFilter<"SkillItem"> | string
    createdAt?: DateTimeFilter<"SkillItem"> | Date | string
    updatedAt?: DateTimeFilter<"SkillItem"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
  }

  export type SkillItemOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    level?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    section?: SectionOrderByWithRelationInput
  }

  export type SkillItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SkillItemWhereInput | SkillItemWhereInput[]
    OR?: SkillItemWhereInput[]
    NOT?: SkillItemWhereInput | SkillItemWhereInput[]
    title?: StringFilter<"SkillItem"> | string
    description?: StringNullableFilter<"SkillItem"> | string | null
    level?: IntNullableFilter<"SkillItem"> | number | null
    order?: IntFilter<"SkillItem"> | number
    sectionId?: StringFilter<"SkillItem"> | string
    createdAt?: DateTimeFilter<"SkillItem"> | Date | string
    updatedAt?: DateTimeFilter<"SkillItem"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
  }, "id">

  export type SkillItemOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    level?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SkillItemCountOrderByAggregateInput
    _avg?: SkillItemAvgOrderByAggregateInput
    _max?: SkillItemMaxOrderByAggregateInput
    _min?: SkillItemMinOrderByAggregateInput
    _sum?: SkillItemSumOrderByAggregateInput
  }

  export type SkillItemScalarWhereWithAggregatesInput = {
    AND?: SkillItemScalarWhereWithAggregatesInput | SkillItemScalarWhereWithAggregatesInput[]
    OR?: SkillItemScalarWhereWithAggregatesInput[]
    NOT?: SkillItemScalarWhereWithAggregatesInput | SkillItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SkillItem"> | string
    title?: StringWithAggregatesFilter<"SkillItem"> | string
    description?: StringNullableWithAggregatesFilter<"SkillItem"> | string | null
    level?: IntNullableWithAggregatesFilter<"SkillItem"> | number | null
    order?: IntWithAggregatesFilter<"SkillItem"> | number
    sectionId?: StringWithAggregatesFilter<"SkillItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SkillItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SkillItem"> | Date | string
  }

  export type SkillImageWhereInput = {
    AND?: SkillImageWhereInput | SkillImageWhereInput[]
    OR?: SkillImageWhereInput[]
    NOT?: SkillImageWhereInput | SkillImageWhereInput[]
    id?: StringFilter<"SkillImage"> | string
    src?: StringFilter<"SkillImage"> | string
    imagePublicId?: StringNullableFilter<"SkillImage"> | string | null
    alt?: StringNullableFilter<"SkillImage"> | string | null
    caption?: StringNullableFilter<"SkillImage"> | string | null
    order?: IntFilter<"SkillImage"> | number
    sectionId?: StringFilter<"SkillImage"> | string
    createdAt?: DateTimeFilter<"SkillImage"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
  }

  export type SkillImageOrderByWithRelationInput = {
    id?: SortOrder
    src?: SortOrder
    imagePublicId?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    section?: SectionOrderByWithRelationInput
  }

  export type SkillImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SkillImageWhereInput | SkillImageWhereInput[]
    OR?: SkillImageWhereInput[]
    NOT?: SkillImageWhereInput | SkillImageWhereInput[]
    src?: StringFilter<"SkillImage"> | string
    imagePublicId?: StringNullableFilter<"SkillImage"> | string | null
    alt?: StringNullableFilter<"SkillImage"> | string | null
    caption?: StringNullableFilter<"SkillImage"> | string | null
    order?: IntFilter<"SkillImage"> | number
    sectionId?: StringFilter<"SkillImage"> | string
    createdAt?: DateTimeFilter<"SkillImage"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
  }, "id">

  export type SkillImageOrderByWithAggregationInput = {
    id?: SortOrder
    src?: SortOrder
    imagePublicId?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    _count?: SkillImageCountOrderByAggregateInput
    _avg?: SkillImageAvgOrderByAggregateInput
    _max?: SkillImageMaxOrderByAggregateInput
    _min?: SkillImageMinOrderByAggregateInput
    _sum?: SkillImageSumOrderByAggregateInput
  }

  export type SkillImageScalarWhereWithAggregatesInput = {
    AND?: SkillImageScalarWhereWithAggregatesInput | SkillImageScalarWhereWithAggregatesInput[]
    OR?: SkillImageScalarWhereWithAggregatesInput[]
    NOT?: SkillImageScalarWhereWithAggregatesInput | SkillImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SkillImage"> | string
    src?: StringWithAggregatesFilter<"SkillImage"> | string
    imagePublicId?: StringNullableWithAggregatesFilter<"SkillImage"> | string | null
    alt?: StringNullableWithAggregatesFilter<"SkillImage"> | string | null
    caption?: StringNullableWithAggregatesFilter<"SkillImage"> | string | null
    order?: IntWithAggregatesFilter<"SkillImage"> | number
    sectionId?: StringWithAggregatesFilter<"SkillImage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SkillImage"> | Date | string
  }

  export type ExperienceItemWhereInput = {
    AND?: ExperienceItemWhereInput | ExperienceItemWhereInput[]
    OR?: ExperienceItemWhereInput[]
    NOT?: ExperienceItemWhereInput | ExperienceItemWhereInput[]
    id?: StringFilter<"ExperienceItem"> | string
    positionTitle?: StringFilter<"ExperienceItem"> | string
    companyName?: StringFilter<"ExperienceItem"> | string
    period?: StringFilter<"ExperienceItem"> | string
    summary?: StringNullableFilter<"ExperienceItem"> | string | null
    description?: StringNullableFilter<"ExperienceItem"> | string | null
    imageSrc?: StringFilter<"ExperienceItem"> | string
    imagePublicId?: StringNullableFilter<"ExperienceItem"> | string | null
    order?: IntFilter<"ExperienceItem"> | number
    sectionId?: StringFilter<"ExperienceItem"> | string
    createdAt?: DateTimeFilter<"ExperienceItem"> | Date | string
    updatedAt?: DateTimeFilter<"ExperienceItem"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
    detailImages?: ExperienceDetailImageListRelationFilter
  }

  export type ExperienceItemOrderByWithRelationInput = {
    id?: SortOrder
    positionTitle?: SortOrder
    companyName?: SortOrder
    period?: SortOrder
    summary?: SortOrder
    description?: SortOrder
    imageSrc?: SortOrder
    imagePublicId?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    section?: SectionOrderByWithRelationInput
    detailImages?: ExperienceDetailImageOrderByRelationAggregateInput
  }

  export type ExperienceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExperienceItemWhereInput | ExperienceItemWhereInput[]
    OR?: ExperienceItemWhereInput[]
    NOT?: ExperienceItemWhereInput | ExperienceItemWhereInput[]
    positionTitle?: StringFilter<"ExperienceItem"> | string
    companyName?: StringFilter<"ExperienceItem"> | string
    period?: StringFilter<"ExperienceItem"> | string
    summary?: StringNullableFilter<"ExperienceItem"> | string | null
    description?: StringNullableFilter<"ExperienceItem"> | string | null
    imageSrc?: StringFilter<"ExperienceItem"> | string
    imagePublicId?: StringNullableFilter<"ExperienceItem"> | string | null
    order?: IntFilter<"ExperienceItem"> | number
    sectionId?: StringFilter<"ExperienceItem"> | string
    createdAt?: DateTimeFilter<"ExperienceItem"> | Date | string
    updatedAt?: DateTimeFilter<"ExperienceItem"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
    detailImages?: ExperienceDetailImageListRelationFilter
  }, "id">

  export type ExperienceItemOrderByWithAggregationInput = {
    id?: SortOrder
    positionTitle?: SortOrder
    companyName?: SortOrder
    period?: SortOrder
    summary?: SortOrder
    description?: SortOrder
    imageSrc?: SortOrder
    imagePublicId?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExperienceItemCountOrderByAggregateInput
    _avg?: ExperienceItemAvgOrderByAggregateInput
    _max?: ExperienceItemMaxOrderByAggregateInput
    _min?: ExperienceItemMinOrderByAggregateInput
    _sum?: ExperienceItemSumOrderByAggregateInput
  }

  export type ExperienceItemScalarWhereWithAggregatesInput = {
    AND?: ExperienceItemScalarWhereWithAggregatesInput | ExperienceItemScalarWhereWithAggregatesInput[]
    OR?: ExperienceItemScalarWhereWithAggregatesInput[]
    NOT?: ExperienceItemScalarWhereWithAggregatesInput | ExperienceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExperienceItem"> | string
    positionTitle?: StringWithAggregatesFilter<"ExperienceItem"> | string
    companyName?: StringWithAggregatesFilter<"ExperienceItem"> | string
    period?: StringWithAggregatesFilter<"ExperienceItem"> | string
    summary?: StringNullableWithAggregatesFilter<"ExperienceItem"> | string | null
    description?: StringNullableWithAggregatesFilter<"ExperienceItem"> | string | null
    imageSrc?: StringWithAggregatesFilter<"ExperienceItem"> | string
    imagePublicId?: StringNullableWithAggregatesFilter<"ExperienceItem"> | string | null
    order?: IntWithAggregatesFilter<"ExperienceItem"> | number
    sectionId?: StringWithAggregatesFilter<"ExperienceItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ExperienceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExperienceItem"> | Date | string
  }

  export type ExperienceDetailImageWhereInput = {
    AND?: ExperienceDetailImageWhereInput | ExperienceDetailImageWhereInput[]
    OR?: ExperienceDetailImageWhereInput[]
    NOT?: ExperienceDetailImageWhereInput | ExperienceDetailImageWhereInput[]
    id?: StringFilter<"ExperienceDetailImage"> | string
    src?: StringFilter<"ExperienceDetailImage"> | string
    imagePublicId?: StringNullableFilter<"ExperienceDetailImage"> | string | null
    alt?: StringNullableFilter<"ExperienceDetailImage"> | string | null
    caption?: StringNullableFilter<"ExperienceDetailImage"> | string | null
    order?: IntFilter<"ExperienceDetailImage"> | number
    experienceItemId?: StringFilter<"ExperienceDetailImage"> | string
    createdAt?: DateTimeFilter<"ExperienceDetailImage"> | Date | string
    experienceItem?: XOR<ExperienceItemScalarRelationFilter, ExperienceItemWhereInput>
  }

  export type ExperienceDetailImageOrderByWithRelationInput = {
    id?: SortOrder
    src?: SortOrder
    imagePublicId?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    order?: SortOrder
    experienceItemId?: SortOrder
    createdAt?: SortOrder
    experienceItem?: ExperienceItemOrderByWithRelationInput
  }

  export type ExperienceDetailImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExperienceDetailImageWhereInput | ExperienceDetailImageWhereInput[]
    OR?: ExperienceDetailImageWhereInput[]
    NOT?: ExperienceDetailImageWhereInput | ExperienceDetailImageWhereInput[]
    src?: StringFilter<"ExperienceDetailImage"> | string
    imagePublicId?: StringNullableFilter<"ExperienceDetailImage"> | string | null
    alt?: StringNullableFilter<"ExperienceDetailImage"> | string | null
    caption?: StringNullableFilter<"ExperienceDetailImage"> | string | null
    order?: IntFilter<"ExperienceDetailImage"> | number
    experienceItemId?: StringFilter<"ExperienceDetailImage"> | string
    createdAt?: DateTimeFilter<"ExperienceDetailImage"> | Date | string
    experienceItem?: XOR<ExperienceItemScalarRelationFilter, ExperienceItemWhereInput>
  }, "id">

  export type ExperienceDetailImageOrderByWithAggregationInput = {
    id?: SortOrder
    src?: SortOrder
    imagePublicId?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    order?: SortOrder
    experienceItemId?: SortOrder
    createdAt?: SortOrder
    _count?: ExperienceDetailImageCountOrderByAggregateInput
    _avg?: ExperienceDetailImageAvgOrderByAggregateInput
    _max?: ExperienceDetailImageMaxOrderByAggregateInput
    _min?: ExperienceDetailImageMinOrderByAggregateInput
    _sum?: ExperienceDetailImageSumOrderByAggregateInput
  }

  export type ExperienceDetailImageScalarWhereWithAggregatesInput = {
    AND?: ExperienceDetailImageScalarWhereWithAggregatesInput | ExperienceDetailImageScalarWhereWithAggregatesInput[]
    OR?: ExperienceDetailImageScalarWhereWithAggregatesInput[]
    NOT?: ExperienceDetailImageScalarWhereWithAggregatesInput | ExperienceDetailImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExperienceDetailImage"> | string
    src?: StringWithAggregatesFilter<"ExperienceDetailImage"> | string
    imagePublicId?: StringNullableWithAggregatesFilter<"ExperienceDetailImage"> | string | null
    alt?: StringNullableWithAggregatesFilter<"ExperienceDetailImage"> | string | null
    caption?: StringNullableWithAggregatesFilter<"ExperienceDetailImage"> | string | null
    order?: IntWithAggregatesFilter<"ExperienceDetailImage"> | number
    experienceItemId?: StringWithAggregatesFilter<"ExperienceDetailImage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ExperienceDetailImage"> | Date | string
  }

  export type ProjectItemWhereInput = {
    AND?: ProjectItemWhereInput | ProjectItemWhereInput[]
    OR?: ProjectItemWhereInput[]
    NOT?: ProjectItemWhereInput | ProjectItemWhereInput[]
    id?: StringFilter<"ProjectItem"> | string
    projectNumber?: StringNullableFilter<"ProjectItem"> | string | null
    title?: StringFilter<"ProjectItem"> | string
    companyName?: StringNullableFilter<"ProjectItem"> | string | null
    description1?: StringFilter<"ProjectItem"> | string
    description2?: StringNullableFilter<"ProjectItem"> | string | null
    imageSrc?: StringFilter<"ProjectItem"> | string
    imagePublicId?: StringNullableFilter<"ProjectItem"> | string | null
    liveLink?: StringNullableFilter<"ProjectItem"> | string | null
    sourceLink?: StringNullableFilter<"ProjectItem"> | string | null
    layout?: StringFilter<"ProjectItem"> | string
    order?: IntFilter<"ProjectItem"> | number
    sectionId?: StringFilter<"ProjectItem"> | string
    categoryIds?: StringNullableListFilter<"ProjectItem">
    createdAt?: DateTimeFilter<"ProjectItem"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectItem"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
  }

  export type ProjectItemOrderByWithRelationInput = {
    id?: SortOrder
    projectNumber?: SortOrder
    title?: SortOrder
    companyName?: SortOrder
    description1?: SortOrder
    description2?: SortOrder
    imageSrc?: SortOrder
    imagePublicId?: SortOrder
    liveLink?: SortOrder
    sourceLink?: SortOrder
    layout?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    categoryIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    section?: SectionOrderByWithRelationInput
  }

  export type ProjectItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectItemWhereInput | ProjectItemWhereInput[]
    OR?: ProjectItemWhereInput[]
    NOT?: ProjectItemWhereInput | ProjectItemWhereInput[]
    projectNumber?: StringNullableFilter<"ProjectItem"> | string | null
    title?: StringFilter<"ProjectItem"> | string
    companyName?: StringNullableFilter<"ProjectItem"> | string | null
    description1?: StringFilter<"ProjectItem"> | string
    description2?: StringNullableFilter<"ProjectItem"> | string | null
    imageSrc?: StringFilter<"ProjectItem"> | string
    imagePublicId?: StringNullableFilter<"ProjectItem"> | string | null
    liveLink?: StringNullableFilter<"ProjectItem"> | string | null
    sourceLink?: StringNullableFilter<"ProjectItem"> | string | null
    layout?: StringFilter<"ProjectItem"> | string
    order?: IntFilter<"ProjectItem"> | number
    sectionId?: StringFilter<"ProjectItem"> | string
    categoryIds?: StringNullableListFilter<"ProjectItem">
    createdAt?: DateTimeFilter<"ProjectItem"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectItem"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
  }, "id">

  export type ProjectItemOrderByWithAggregationInput = {
    id?: SortOrder
    projectNumber?: SortOrder
    title?: SortOrder
    companyName?: SortOrder
    description1?: SortOrder
    description2?: SortOrder
    imageSrc?: SortOrder
    imagePublicId?: SortOrder
    liveLink?: SortOrder
    sourceLink?: SortOrder
    layout?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    categoryIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectItemCountOrderByAggregateInput
    _avg?: ProjectItemAvgOrderByAggregateInput
    _max?: ProjectItemMaxOrderByAggregateInput
    _min?: ProjectItemMinOrderByAggregateInput
    _sum?: ProjectItemSumOrderByAggregateInput
  }

  export type ProjectItemScalarWhereWithAggregatesInput = {
    AND?: ProjectItemScalarWhereWithAggregatesInput | ProjectItemScalarWhereWithAggregatesInput[]
    OR?: ProjectItemScalarWhereWithAggregatesInput[]
    NOT?: ProjectItemScalarWhereWithAggregatesInput | ProjectItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectItem"> | string
    projectNumber?: StringNullableWithAggregatesFilter<"ProjectItem"> | string | null
    title?: StringWithAggregatesFilter<"ProjectItem"> | string
    companyName?: StringNullableWithAggregatesFilter<"ProjectItem"> | string | null
    description1?: StringWithAggregatesFilter<"ProjectItem"> | string
    description2?: StringNullableWithAggregatesFilter<"ProjectItem"> | string | null
    imageSrc?: StringWithAggregatesFilter<"ProjectItem"> | string
    imagePublicId?: StringNullableWithAggregatesFilter<"ProjectItem"> | string | null
    liveLink?: StringNullableWithAggregatesFilter<"ProjectItem"> | string | null
    sourceLink?: StringNullableWithAggregatesFilter<"ProjectItem"> | string | null
    layout?: StringWithAggregatesFilter<"ProjectItem"> | string
    order?: IntWithAggregatesFilter<"ProjectItem"> | number
    sectionId?: StringWithAggregatesFilter<"ProjectItem"> | string
    categoryIds?: StringNullableListFilter<"ProjectItem">
    createdAt?: DateTimeWithAggregatesFilter<"ProjectItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectItem"> | Date | string
  }

  export type TestimonialItemWhereInput = {
    AND?: TestimonialItemWhereInput | TestimonialItemWhereInput[]
    OR?: TestimonialItemWhereInput[]
    NOT?: TestimonialItemWhereInput | TestimonialItemWhereInput[]
    id?: StringFilter<"TestimonialItem"> | string
    clientName?: StringFilter<"TestimonialItem"> | string
    role?: StringNullableFilter<"TestimonialItem"> | string | null
    company?: StringNullableFilter<"TestimonialItem"> | string | null
    content?: StringFilter<"TestimonialItem"> | string
    rating?: FloatFilter<"TestimonialItem"> | number
    imageSrc?: StringNullableFilter<"TestimonialItem"> | string | null
    imagePublicId?: StringNullableFilter<"TestimonialItem"> | string | null
    order?: IntFilter<"TestimonialItem"> | number
    sectionId?: StringFilter<"TestimonialItem"> | string
    createdAt?: DateTimeFilter<"TestimonialItem"> | Date | string
    updatedAt?: DateTimeFilter<"TestimonialItem"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
  }

  export type TestimonialItemOrderByWithRelationInput = {
    id?: SortOrder
    clientName?: SortOrder
    role?: SortOrder
    company?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    imageSrc?: SortOrder
    imagePublicId?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    section?: SectionOrderByWithRelationInput
  }

  export type TestimonialItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestimonialItemWhereInput | TestimonialItemWhereInput[]
    OR?: TestimonialItemWhereInput[]
    NOT?: TestimonialItemWhereInput | TestimonialItemWhereInput[]
    clientName?: StringFilter<"TestimonialItem"> | string
    role?: StringNullableFilter<"TestimonialItem"> | string | null
    company?: StringNullableFilter<"TestimonialItem"> | string | null
    content?: StringFilter<"TestimonialItem"> | string
    rating?: FloatFilter<"TestimonialItem"> | number
    imageSrc?: StringNullableFilter<"TestimonialItem"> | string | null
    imagePublicId?: StringNullableFilter<"TestimonialItem"> | string | null
    order?: IntFilter<"TestimonialItem"> | number
    sectionId?: StringFilter<"TestimonialItem"> | string
    createdAt?: DateTimeFilter<"TestimonialItem"> | Date | string
    updatedAt?: DateTimeFilter<"TestimonialItem"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
  }, "id">

  export type TestimonialItemOrderByWithAggregationInput = {
    id?: SortOrder
    clientName?: SortOrder
    role?: SortOrder
    company?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    imageSrc?: SortOrder
    imagePublicId?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestimonialItemCountOrderByAggregateInput
    _avg?: TestimonialItemAvgOrderByAggregateInput
    _max?: TestimonialItemMaxOrderByAggregateInput
    _min?: TestimonialItemMinOrderByAggregateInput
    _sum?: TestimonialItemSumOrderByAggregateInput
  }

  export type TestimonialItemScalarWhereWithAggregatesInput = {
    AND?: TestimonialItemScalarWhereWithAggregatesInput | TestimonialItemScalarWhereWithAggregatesInput[]
    OR?: TestimonialItemScalarWhereWithAggregatesInput[]
    NOT?: TestimonialItemScalarWhereWithAggregatesInput | TestimonialItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestimonialItem"> | string
    clientName?: StringWithAggregatesFilter<"TestimonialItem"> | string
    role?: StringNullableWithAggregatesFilter<"TestimonialItem"> | string | null
    company?: StringNullableWithAggregatesFilter<"TestimonialItem"> | string | null
    content?: StringWithAggregatesFilter<"TestimonialItem"> | string
    rating?: FloatWithAggregatesFilter<"TestimonialItem"> | number
    imageSrc?: StringNullableWithAggregatesFilter<"TestimonialItem"> | string | null
    imagePublicId?: StringNullableWithAggregatesFilter<"TestimonialItem"> | string | null
    order?: IntWithAggregatesFilter<"TestimonialItem"> | number
    sectionId?: StringWithAggregatesFilter<"TestimonialItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TestimonialItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestimonialItem"> | Date | string
  }

  export type ContactInfoItemWhereInput = {
    AND?: ContactInfoItemWhereInput | ContactInfoItemWhereInput[]
    OR?: ContactInfoItemWhereInput[]
    NOT?: ContactInfoItemWhereInput | ContactInfoItemWhereInput[]
    id?: StringFilter<"ContactInfoItem"> | string
    type?: StringFilter<"ContactInfoItem"> | string
    value?: StringFilter<"ContactInfoItem"> | string
    label?: StringNullableFilter<"ContactInfoItem"> | string | null
    icon?: StringNullableFilter<"ContactInfoItem"> | string | null
    order?: IntFilter<"ContactInfoItem"> | number
    sectionId?: StringFilter<"ContactInfoItem"> | string
    createdAt?: DateTimeFilter<"ContactInfoItem"> | Date | string
    updatedAt?: DateTimeFilter<"ContactInfoItem"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
  }

  export type ContactInfoItemOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    label?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    section?: SectionOrderByWithRelationInput
  }

  export type ContactInfoItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactInfoItemWhereInput | ContactInfoItemWhereInput[]
    OR?: ContactInfoItemWhereInput[]
    NOT?: ContactInfoItemWhereInput | ContactInfoItemWhereInput[]
    type?: StringFilter<"ContactInfoItem"> | string
    value?: StringFilter<"ContactInfoItem"> | string
    label?: StringNullableFilter<"ContactInfoItem"> | string | null
    icon?: StringNullableFilter<"ContactInfoItem"> | string | null
    order?: IntFilter<"ContactInfoItem"> | number
    sectionId?: StringFilter<"ContactInfoItem"> | string
    createdAt?: DateTimeFilter<"ContactInfoItem"> | Date | string
    updatedAt?: DateTimeFilter<"ContactInfoItem"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
  }, "id">

  export type ContactInfoItemOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    label?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactInfoItemCountOrderByAggregateInput
    _avg?: ContactInfoItemAvgOrderByAggregateInput
    _max?: ContactInfoItemMaxOrderByAggregateInput
    _min?: ContactInfoItemMinOrderByAggregateInput
    _sum?: ContactInfoItemSumOrderByAggregateInput
  }

  export type ContactInfoItemScalarWhereWithAggregatesInput = {
    AND?: ContactInfoItemScalarWhereWithAggregatesInput | ContactInfoItemScalarWhereWithAggregatesInput[]
    OR?: ContactInfoItemScalarWhereWithAggregatesInput[]
    NOT?: ContactInfoItemScalarWhereWithAggregatesInput | ContactInfoItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactInfoItem"> | string
    type?: StringWithAggregatesFilter<"ContactInfoItem"> | string
    value?: StringWithAggregatesFilter<"ContactInfoItem"> | string
    label?: StringNullableWithAggregatesFilter<"ContactInfoItem"> | string | null
    icon?: StringNullableWithAggregatesFilter<"ContactInfoItem"> | string | null
    order?: IntWithAggregatesFilter<"ContactInfoItem"> | number
    sectionId?: StringWithAggregatesFilter<"ContactInfoItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContactInfoItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactInfoItem"> | Date | string
  }

  export type CustomSectionContentBlockWhereInput = {
    AND?: CustomSectionContentBlockWhereInput | CustomSectionContentBlockWhereInput[]
    OR?: CustomSectionContentBlockWhereInput[]
    NOT?: CustomSectionContentBlockWhereInput | CustomSectionContentBlockWhereInput[]
    id?: StringFilter<"CustomSectionContentBlock"> | string
    type?: StringFilter<"CustomSectionContentBlock"> | string
    content?: StringNullableFilter<"CustomSectionContentBlock"> | string | null
    imageSrc?: StringNullableFilter<"CustomSectionContentBlock"> | string | null
    imageAlt?: StringNullableFilter<"CustomSectionContentBlock"> | string | null
    linkUrl?: StringNullableFilter<"CustomSectionContentBlock"> | string | null
    imagePublicId?: StringNullableFilter<"CustomSectionContentBlock"> | string | null
    order?: IntFilter<"CustomSectionContentBlock"> | number
    sectionId?: StringFilter<"CustomSectionContentBlock"> | string
    createdAt?: DateTimeFilter<"CustomSectionContentBlock"> | Date | string
    updatedAt?: DateTimeFilter<"CustomSectionContentBlock"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
  }

  export type CustomSectionContentBlockOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    imageSrc?: SortOrder
    imageAlt?: SortOrder
    linkUrl?: SortOrder
    imagePublicId?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    section?: SectionOrderByWithRelationInput
  }

  export type CustomSectionContentBlockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomSectionContentBlockWhereInput | CustomSectionContentBlockWhereInput[]
    OR?: CustomSectionContentBlockWhereInput[]
    NOT?: CustomSectionContentBlockWhereInput | CustomSectionContentBlockWhereInput[]
    type?: StringFilter<"CustomSectionContentBlock"> | string
    content?: StringNullableFilter<"CustomSectionContentBlock"> | string | null
    imageSrc?: StringNullableFilter<"CustomSectionContentBlock"> | string | null
    imageAlt?: StringNullableFilter<"CustomSectionContentBlock"> | string | null
    linkUrl?: StringNullableFilter<"CustomSectionContentBlock"> | string | null
    imagePublicId?: StringNullableFilter<"CustomSectionContentBlock"> | string | null
    order?: IntFilter<"CustomSectionContentBlock"> | number
    sectionId?: StringFilter<"CustomSectionContentBlock"> | string
    createdAt?: DateTimeFilter<"CustomSectionContentBlock"> | Date | string
    updatedAt?: DateTimeFilter<"CustomSectionContentBlock"> | Date | string
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
  }, "id">

  export type CustomSectionContentBlockOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    imageSrc?: SortOrder
    imageAlt?: SortOrder
    linkUrl?: SortOrder
    imagePublicId?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomSectionContentBlockCountOrderByAggregateInput
    _avg?: CustomSectionContentBlockAvgOrderByAggregateInput
    _max?: CustomSectionContentBlockMaxOrderByAggregateInput
    _min?: CustomSectionContentBlockMinOrderByAggregateInput
    _sum?: CustomSectionContentBlockSumOrderByAggregateInput
  }

  export type CustomSectionContentBlockScalarWhereWithAggregatesInput = {
    AND?: CustomSectionContentBlockScalarWhereWithAggregatesInput | CustomSectionContentBlockScalarWhereWithAggregatesInput[]
    OR?: CustomSectionContentBlockScalarWhereWithAggregatesInput[]
    NOT?: CustomSectionContentBlockScalarWhereWithAggregatesInput | CustomSectionContentBlockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomSectionContentBlock"> | string
    type?: StringWithAggregatesFilter<"CustomSectionContentBlock"> | string
    content?: StringNullableWithAggregatesFilter<"CustomSectionContentBlock"> | string | null
    imageSrc?: StringNullableWithAggregatesFilter<"CustomSectionContentBlock"> | string | null
    imageAlt?: StringNullableWithAggregatesFilter<"CustomSectionContentBlock"> | string | null
    linkUrl?: StringNullableWithAggregatesFilter<"CustomSectionContentBlock"> | string | null
    imagePublicId?: StringNullableWithAggregatesFilter<"CustomSectionContentBlock"> | string | null
    order?: IntWithAggregatesFilter<"CustomSectionContentBlock"> | number
    sectionId?: StringWithAggregatesFilter<"CustomSectionContentBlock"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CustomSectionContentBlock"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomSectionContentBlock"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    password: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionCreateInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockCreateNestedManyWithoutSectionInput
    imageBlocks?: ImageBlockCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentCreateNestedOneWithoutSectionInput
    educationItems?: EducationItemCreateNestedManyWithoutSectionInput
    skillItems?: SkillItemCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockUncheckedCreateNestedManyWithoutSectionInput
    imageBlocks?: ImageBlockUncheckedCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentUncheckedCreateNestedOneWithoutSectionInput
    educationItems?: EducationItemUncheckedCreateNestedManyWithoutSectionInput
    skillItems?: SkillItemUncheckedCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageUncheckedCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemUncheckedCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemUncheckedCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemUncheckedCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemUncheckedCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUpdateManyWithoutSectionNestedInput
    imageBlocks?: ImageBlockUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUpdateOneWithoutSectionNestedInput
    educationItems?: EducationItemUpdateManyWithoutSectionNestedInput
    skillItems?: SkillItemUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUncheckedUpdateManyWithoutSectionNestedInput
    imageBlocks?: ImageBlockUncheckedUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUncheckedUpdateOneWithoutSectionNestedInput
    educationItems?: EducationItemUncheckedUpdateManyWithoutSectionNestedInput
    skillItems?: SkillItemUncheckedUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUncheckedUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUncheckedUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUncheckedUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUncheckedUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUncheckedUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionCreateManyInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionUncheckedUpdateManyInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectIds?: CategoryCreateprojectIdsInput | string[]
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectIds?: CategoryCreateprojectIdsInput | string[]
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectIds?: CategoryUpdateprojectIdsInput | string[]
  }

  export type CategoryUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectIds?: CategoryUpdateprojectIdsInput | string[]
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectIds?: CategoryCreateprojectIdsInput | string[]
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectIds?: CategoryUpdateprojectIdsInput | string[]
  }

  export type CategoryUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectIds?: CategoryUpdateprojectIdsInput | string[]
  }

  export type SettingCreateInput = {
    id?: string
    siteTitle?: string
    theme?: string
    showPortrait?: boolean
    resumeUrl?: string
    globalFontFamily?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUncheckedCreateInput = {
    id?: string
    siteTitle?: string
    theme?: string
    showPortrait?: boolean
    resumeUrl?: string
    globalFontFamily?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUpdateInput = {
    siteTitle?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    showPortrait?: BoolFieldUpdateOperationsInput | boolean
    resumeUrl?: StringFieldUpdateOperationsInput | string
    globalFontFamily?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateInput = {
    siteTitle?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    showPortrait?: BoolFieldUpdateOperationsInput | boolean
    resumeUrl?: StringFieldUpdateOperationsInput | string
    globalFontFamily?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateManyInput = {
    id?: string
    siteTitle?: string
    theme?: string
    showPortrait?: boolean
    resumeUrl?: string
    globalFontFamily?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUpdateManyMutationInput = {
    siteTitle?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    showPortrait?: BoolFieldUpdateOperationsInput | boolean
    resumeUrl?: StringFieldUpdateOperationsInput | string
    globalFontFamily?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateManyInput = {
    siteTitle?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    showPortrait?: BoolFieldUpdateOperationsInput | boolean
    resumeUrl?: StringFieldUpdateOperationsInput | string
    globalFontFamily?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextBlockCreateInput = {
    id?: string
    content: string
    order?: number
    fontSize?: number | null
    fontFamily?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    section: SectionCreateNestedOneWithoutTextBlocksInput
  }

  export type TextBlockUncheckedCreateInput = {
    id?: string
    content: string
    order?: number
    sectionId: string
    fontSize?: number | null
    fontFamily?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TextBlockUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    fontSize?: NullableIntFieldUpdateOperationsInput | number | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneRequiredWithoutTextBlocksNestedInput
  }

  export type TextBlockUncheckedUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    fontSize?: NullableIntFieldUpdateOperationsInput | number | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextBlockCreateManyInput = {
    id?: string
    content: string
    order?: number
    sectionId: string
    fontSize?: number | null
    fontFamily?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TextBlockUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    fontSize?: NullableIntFieldUpdateOperationsInput | number | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextBlockUncheckedUpdateManyInput = {
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    fontSize?: NullableIntFieldUpdateOperationsInput | number | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageBlockCreateInput = {
    id?: string
    src: string
    alt?: string | null
    caption?: string | null
    imagePublicId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    section: SectionCreateNestedOneWithoutImageBlocksInput
  }

  export type ImageBlockUncheckedCreateInput = {
    id?: string
    src: string
    alt?: string | null
    caption?: string | null
    imagePublicId?: string | null
    order?: number
    sectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageBlockUpdateInput = {
    src?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneRequiredWithoutImageBlocksNestedInput
  }

  export type ImageBlockUncheckedUpdateInput = {
    src?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageBlockCreateManyInput = {
    id?: string
    src: string
    alt?: string | null
    caption?: string | null
    imagePublicId?: string | null
    order?: number
    sectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageBlockUpdateManyMutationInput = {
    src?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageBlockUncheckedUpdateManyInput = {
    src?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroSectionContentCreateInput = {
    id?: string
    portraitImageSrc?: string | null
    portraitImagePublicId?: string | null
    portraitAlt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    section: SectionCreateNestedOneWithoutHeroContentInput
  }

  export type HeroSectionContentUncheckedCreateInput = {
    id?: string
    portraitImageSrc?: string | null
    portraitImagePublicId?: string | null
    portraitAlt?: string | null
    sectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HeroSectionContentUpdateInput = {
    portraitImageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    portraitImagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    portraitAlt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneRequiredWithoutHeroContentNestedInput
  }

  export type HeroSectionContentUncheckedUpdateInput = {
    portraitImageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    portraitImagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    portraitAlt?: NullableStringFieldUpdateOperationsInput | string | null
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroSectionContentCreateManyInput = {
    id?: string
    portraitImageSrc?: string | null
    portraitImagePublicId?: string | null
    portraitAlt?: string | null
    sectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HeroSectionContentUpdateManyMutationInput = {
    portraitImageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    portraitImagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    portraitAlt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroSectionContentUncheckedUpdateManyInput = {
    portraitImageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    portraitImagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    portraitAlt?: NullableStringFieldUpdateOperationsInput | string | null
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationItemCreateInput = {
    id?: string
    institution: string
    degree?: string | null
    period: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    section: SectionCreateNestedOneWithoutEducationItemsInput
    images?: EducationImageCreateNestedManyWithoutEducationItemInput
  }

  export type EducationItemUncheckedCreateInput = {
    id?: string
    institution: string
    degree?: string | null
    period: string
    description?: string | null
    order?: number
    sectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: EducationImageUncheckedCreateNestedManyWithoutEducationItemInput
  }

  export type EducationItemUpdateInput = {
    institution?: StringFieldUpdateOperationsInput | string
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneRequiredWithoutEducationItemsNestedInput
    images?: EducationImageUpdateManyWithoutEducationItemNestedInput
  }

  export type EducationItemUncheckedUpdateInput = {
    institution?: StringFieldUpdateOperationsInput | string
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: EducationImageUncheckedUpdateManyWithoutEducationItemNestedInput
  }

  export type EducationItemCreateManyInput = {
    id?: string
    institution: string
    degree?: string | null
    period: string
    description?: string | null
    order?: number
    sectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EducationItemUpdateManyMutationInput = {
    institution?: StringFieldUpdateOperationsInput | string
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationItemUncheckedUpdateManyInput = {
    institution?: StringFieldUpdateOperationsInput | string
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationImageCreateInput = {
    id?: string
    src: string
    imagePublicId?: string | null
    alt?: string | null
    caption?: string | null
    order?: number
    createdAt?: Date | string
    educationItem: EducationItemCreateNestedOneWithoutImagesInput
  }

  export type EducationImageUncheckedCreateInput = {
    id?: string
    src: string
    imagePublicId?: string | null
    alt?: string | null
    caption?: string | null
    order?: number
    educationItemId: string
    createdAt?: Date | string
  }

  export type EducationImageUpdateInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    educationItem?: EducationItemUpdateOneRequiredWithoutImagesNestedInput
  }

  export type EducationImageUncheckedUpdateInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    educationItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationImageCreateManyInput = {
    id?: string
    src: string
    imagePublicId?: string | null
    alt?: string | null
    caption?: string | null
    order?: number
    educationItemId: string
    createdAt?: Date | string
  }

  export type EducationImageUpdateManyMutationInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationImageUncheckedUpdateManyInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    educationItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillItemCreateInput = {
    id?: string
    title: string
    description?: string | null
    level?: number | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    section: SectionCreateNestedOneWithoutSkillItemsInput
  }

  export type SkillItemUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    level?: number | null
    order?: number
    sectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillItemUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneRequiredWithoutSkillItemsNestedInput
  }

  export type SkillItemUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillItemCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    level?: number | null
    order?: number
    sectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillItemUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillItemUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillImageCreateInput = {
    id?: string
    src: string
    imagePublicId?: string | null
    alt?: string | null
    caption?: string | null
    order?: number
    createdAt?: Date | string
    section: SectionCreateNestedOneWithoutSkillImagesInput
  }

  export type SkillImageUncheckedCreateInput = {
    id?: string
    src: string
    imagePublicId?: string | null
    alt?: string | null
    caption?: string | null
    order?: number
    sectionId: string
    createdAt?: Date | string
  }

  export type SkillImageUpdateInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneRequiredWithoutSkillImagesNestedInput
  }

  export type SkillImageUncheckedUpdateInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillImageCreateManyInput = {
    id?: string
    src: string
    imagePublicId?: string | null
    alt?: string | null
    caption?: string | null
    order?: number
    sectionId: string
    createdAt?: Date | string
  }

  export type SkillImageUpdateManyMutationInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillImageUncheckedUpdateManyInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperienceItemCreateInput = {
    id?: string
    positionTitle: string
    companyName: string
    period: string
    summary?: string | null
    description?: string | null
    imageSrc: string
    imagePublicId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    section: SectionCreateNestedOneWithoutExperienceItemsInput
    detailImages?: ExperienceDetailImageCreateNestedManyWithoutExperienceItemInput
  }

  export type ExperienceItemUncheckedCreateInput = {
    id?: string
    positionTitle: string
    companyName: string
    period: string
    summary?: string | null
    description?: string | null
    imageSrc: string
    imagePublicId?: string | null
    order?: number
    sectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    detailImages?: ExperienceDetailImageUncheckedCreateNestedManyWithoutExperienceItemInput
  }

  export type ExperienceItemUpdateInput = {
    positionTitle?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneRequiredWithoutExperienceItemsNestedInput
    detailImages?: ExperienceDetailImageUpdateManyWithoutExperienceItemNestedInput
  }

  export type ExperienceItemUncheckedUpdateInput = {
    positionTitle?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailImages?: ExperienceDetailImageUncheckedUpdateManyWithoutExperienceItemNestedInput
  }

  export type ExperienceItemCreateManyInput = {
    id?: string
    positionTitle: string
    companyName: string
    period: string
    summary?: string | null
    description?: string | null
    imageSrc: string
    imagePublicId?: string | null
    order?: number
    sectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExperienceItemUpdateManyMutationInput = {
    positionTitle?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperienceItemUncheckedUpdateManyInput = {
    positionTitle?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperienceDetailImageCreateInput = {
    id?: string
    src: string
    imagePublicId?: string | null
    alt?: string | null
    caption?: string | null
    order?: number
    createdAt?: Date | string
    experienceItem: ExperienceItemCreateNestedOneWithoutDetailImagesInput
  }

  export type ExperienceDetailImageUncheckedCreateInput = {
    id?: string
    src: string
    imagePublicId?: string | null
    alt?: string | null
    caption?: string | null
    order?: number
    experienceItemId: string
    createdAt?: Date | string
  }

  export type ExperienceDetailImageUpdateInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experienceItem?: ExperienceItemUpdateOneRequiredWithoutDetailImagesNestedInput
  }

  export type ExperienceDetailImageUncheckedUpdateInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    experienceItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperienceDetailImageCreateManyInput = {
    id?: string
    src: string
    imagePublicId?: string | null
    alt?: string | null
    caption?: string | null
    order?: number
    experienceItemId: string
    createdAt?: Date | string
  }

  export type ExperienceDetailImageUpdateManyMutationInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperienceDetailImageUncheckedUpdateManyInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    experienceItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectItemCreateInput = {
    id?: string
    projectNumber?: string | null
    title: string
    companyName?: string | null
    description1: string
    description2?: string | null
    imageSrc: string
    imagePublicId?: string | null
    liveLink?: string | null
    sourceLink?: string | null
    layout?: string
    order?: number
    categoryIds?: ProjectItemCreatecategoryIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    section: SectionCreateNestedOneWithoutProjectItemsInput
  }

  export type ProjectItemUncheckedCreateInput = {
    id?: string
    projectNumber?: string | null
    title: string
    companyName?: string | null
    description1: string
    description2?: string | null
    imageSrc: string
    imagePublicId?: string | null
    liveLink?: string | null
    sourceLink?: string | null
    layout?: string
    order?: number
    sectionId: string
    categoryIds?: ProjectItemCreatecategoryIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectItemUpdateInput = {
    projectNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    description1?: StringFieldUpdateOperationsInput | string
    description2?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    liveLink?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    layout?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    categoryIds?: ProjectItemUpdatecategoryIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneRequiredWithoutProjectItemsNestedInput
  }

  export type ProjectItemUncheckedUpdateInput = {
    projectNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    description1?: StringFieldUpdateOperationsInput | string
    description2?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    liveLink?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    layout?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    categoryIds?: ProjectItemUpdatecategoryIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectItemCreateManyInput = {
    id?: string
    projectNumber?: string | null
    title: string
    companyName?: string | null
    description1: string
    description2?: string | null
    imageSrc: string
    imagePublicId?: string | null
    liveLink?: string | null
    sourceLink?: string | null
    layout?: string
    order?: number
    sectionId: string
    categoryIds?: ProjectItemCreatecategoryIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectItemUpdateManyMutationInput = {
    projectNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    description1?: StringFieldUpdateOperationsInput | string
    description2?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    liveLink?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    layout?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    categoryIds?: ProjectItemUpdatecategoryIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectItemUncheckedUpdateManyInput = {
    projectNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    description1?: StringFieldUpdateOperationsInput | string
    description2?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    liveLink?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    layout?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    categoryIds?: ProjectItemUpdatecategoryIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialItemCreateInput = {
    id?: string
    clientName: string
    role?: string | null
    company?: string | null
    content: string
    rating: number
    imageSrc?: string | null
    imagePublicId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    section: SectionCreateNestedOneWithoutTestimonialItemsInput
  }

  export type TestimonialItemUncheckedCreateInput = {
    id?: string
    clientName: string
    role?: string | null
    company?: string | null
    content: string
    rating: number
    imageSrc?: string | null
    imagePublicId?: string | null
    order?: number
    sectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialItemUpdateInput = {
    clientName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneRequiredWithoutTestimonialItemsNestedInput
  }

  export type TestimonialItemUncheckedUpdateInput = {
    clientName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialItemCreateManyInput = {
    id?: string
    clientName: string
    role?: string | null
    company?: string | null
    content: string
    rating: number
    imageSrc?: string | null
    imagePublicId?: string | null
    order?: number
    sectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialItemUpdateManyMutationInput = {
    clientName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialItemUncheckedUpdateManyInput = {
    clientName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInfoItemCreateInput = {
    id?: string
    type: string
    value: string
    label?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    section: SectionCreateNestedOneWithoutContactInfoItemsInput
  }

  export type ContactInfoItemUncheckedCreateInput = {
    id?: string
    type: string
    value: string
    label?: string | null
    icon?: string | null
    order?: number
    sectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactInfoItemUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneRequiredWithoutContactInfoItemsNestedInput
  }

  export type ContactInfoItemUncheckedUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInfoItemCreateManyInput = {
    id?: string
    type: string
    value: string
    label?: string | null
    icon?: string | null
    order?: number
    sectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactInfoItemUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInfoItemUncheckedUpdateManyInput = {
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomSectionContentBlockCreateInput = {
    id?: string
    type: string
    content?: string | null
    imageSrc?: string | null
    imageAlt?: string | null
    linkUrl?: string | null
    imagePublicId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    section: SectionCreateNestedOneWithoutCustomSectionContentBlocksInput
  }

  export type CustomSectionContentBlockUncheckedCreateInput = {
    id?: string
    type: string
    content?: string | null
    imageSrc?: string | null
    imageAlt?: string | null
    linkUrl?: string | null
    imagePublicId?: string | null
    order?: number
    sectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomSectionContentBlockUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneRequiredWithoutCustomSectionContentBlocksNestedInput
  }

  export type CustomSectionContentBlockUncheckedUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomSectionContentBlockCreateManyInput = {
    id?: string
    type: string
    content?: string | null
    imageSrc?: string | null
    imageAlt?: string | null
    linkUrl?: string | null
    imagePublicId?: string | null
    order?: number
    sectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomSectionContentBlockUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomSectionContentBlockUncheckedUpdateManyInput = {
    type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TextBlockListRelationFilter = {
    every?: TextBlockWhereInput
    some?: TextBlockWhereInput
    none?: TextBlockWhereInput
  }

  export type ImageBlockListRelationFilter = {
    every?: ImageBlockWhereInput
    some?: ImageBlockWhereInput
    none?: ImageBlockWhereInput
  }

  export type HeroSectionContentNullableScalarRelationFilter = {
    is?: HeroSectionContentWhereInput | null
    isNot?: HeroSectionContentWhereInput | null
  }

  export type EducationItemListRelationFilter = {
    every?: EducationItemWhereInput
    some?: EducationItemWhereInput
    none?: EducationItemWhereInput
  }

  export type SkillItemListRelationFilter = {
    every?: SkillItemWhereInput
    some?: SkillItemWhereInput
    none?: SkillItemWhereInput
  }

  export type SkillImageListRelationFilter = {
    every?: SkillImageWhereInput
    some?: SkillImageWhereInput
    none?: SkillImageWhereInput
  }

  export type ExperienceItemListRelationFilter = {
    every?: ExperienceItemWhereInput
    some?: ExperienceItemWhereInput
    none?: ExperienceItemWhereInput
  }

  export type ProjectItemListRelationFilter = {
    every?: ProjectItemWhereInput
    some?: ProjectItemWhereInput
    none?: ProjectItemWhereInput
  }

  export type TestimonialItemListRelationFilter = {
    every?: TestimonialItemWhereInput
    some?: TestimonialItemWhereInput
    none?: TestimonialItemWhereInput
  }

  export type ContactInfoItemListRelationFilter = {
    every?: ContactInfoItemWhereInput
    some?: ContactInfoItemWhereInput
    none?: ContactInfoItemWhereInput
  }

  export type CustomSectionContentBlockListRelationFilter = {
    every?: CustomSectionContentBlockWhereInput
    some?: CustomSectionContentBlockWhereInput
    none?: CustomSectionContentBlockWhereInput
  }

  export type TextBlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImageBlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EducationItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkillItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkillImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExperienceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestimonialItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactInfoItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomSectionContentBlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SectionCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    type?: SortOrder
    visible?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SectionMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    type?: SortOrder
    visible?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    type?: SortOrder
    visible?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectIds?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SettingCountOrderByAggregateInput = {
    id?: SortOrder
    siteTitle?: SortOrder
    theme?: SortOrder
    showPortrait?: SortOrder
    resumeUrl?: SortOrder
    globalFontFamily?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMaxOrderByAggregateInput = {
    id?: SortOrder
    siteTitle?: SortOrder
    theme?: SortOrder
    showPortrait?: SortOrder
    resumeUrl?: SortOrder
    globalFontFamily?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMinOrderByAggregateInput = {
    id?: SortOrder
    siteTitle?: SortOrder
    theme?: SortOrder
    showPortrait?: SortOrder
    resumeUrl?: SortOrder
    globalFontFamily?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type SectionScalarRelationFilter = {
    is?: SectionWhereInput
    isNot?: SectionWhereInput
  }

  export type TextBlockCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    fontSize?: SortOrder
    fontFamily?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TextBlockAvgOrderByAggregateInput = {
    order?: SortOrder
    fontSize?: SortOrder
  }

  export type TextBlockMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    fontSize?: SortOrder
    fontFamily?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TextBlockMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    fontSize?: SortOrder
    fontFamily?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TextBlockSumOrderByAggregateInput = {
    order?: SortOrder
    fontSize?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type ImageBlockCountOrderByAggregateInput = {
    id?: SortOrder
    src?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    imagePublicId?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageBlockAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ImageBlockMaxOrderByAggregateInput = {
    id?: SortOrder
    src?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    imagePublicId?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageBlockMinOrderByAggregateInput = {
    id?: SortOrder
    src?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    imagePublicId?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageBlockSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HeroSectionContentCountOrderByAggregateInput = {
    id?: SortOrder
    portraitImageSrc?: SortOrder
    portraitImagePublicId?: SortOrder
    portraitAlt?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HeroSectionContentMaxOrderByAggregateInput = {
    id?: SortOrder
    portraitImageSrc?: SortOrder
    portraitImagePublicId?: SortOrder
    portraitAlt?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HeroSectionContentMinOrderByAggregateInput = {
    id?: SortOrder
    portraitImageSrc?: SortOrder
    portraitImagePublicId?: SortOrder
    portraitAlt?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EducationImageListRelationFilter = {
    every?: EducationImageWhereInput
    some?: EducationImageWhereInput
    none?: EducationImageWhereInput
  }

  export type EducationImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EducationItemCountOrderByAggregateInput = {
    id?: SortOrder
    institution?: SortOrder
    degree?: SortOrder
    period?: SortOrder
    description?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EducationItemAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EducationItemMaxOrderByAggregateInput = {
    id?: SortOrder
    institution?: SortOrder
    degree?: SortOrder
    period?: SortOrder
    description?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EducationItemMinOrderByAggregateInput = {
    id?: SortOrder
    institution?: SortOrder
    degree?: SortOrder
    period?: SortOrder
    description?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EducationItemSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EducationItemScalarRelationFilter = {
    is?: EducationItemWhereInput
    isNot?: EducationItemWhereInput
  }

  export type EducationImageCountOrderByAggregateInput = {
    id?: SortOrder
    src?: SortOrder
    imagePublicId?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    order?: SortOrder
    educationItemId?: SortOrder
    createdAt?: SortOrder
  }

  export type EducationImageAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EducationImageMaxOrderByAggregateInput = {
    id?: SortOrder
    src?: SortOrder
    imagePublicId?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    order?: SortOrder
    educationItemId?: SortOrder
    createdAt?: SortOrder
  }

  export type EducationImageMinOrderByAggregateInput = {
    id?: SortOrder
    src?: SortOrder
    imagePublicId?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    order?: SortOrder
    educationItemId?: SortOrder
    createdAt?: SortOrder
  }

  export type EducationImageSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SkillItemCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    level?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillItemAvgOrderByAggregateInput = {
    level?: SortOrder
    order?: SortOrder
  }

  export type SkillItemMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    level?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillItemMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    level?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillItemSumOrderByAggregateInput = {
    level?: SortOrder
    order?: SortOrder
  }

  export type SkillImageCountOrderByAggregateInput = {
    id?: SortOrder
    src?: SortOrder
    imagePublicId?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
  }

  export type SkillImageAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SkillImageMaxOrderByAggregateInput = {
    id?: SortOrder
    src?: SortOrder
    imagePublicId?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
  }

  export type SkillImageMinOrderByAggregateInput = {
    id?: SortOrder
    src?: SortOrder
    imagePublicId?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
  }

  export type SkillImageSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ExperienceDetailImageListRelationFilter = {
    every?: ExperienceDetailImageWhereInput
    some?: ExperienceDetailImageWhereInput
    none?: ExperienceDetailImageWhereInput
  }

  export type ExperienceDetailImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExperienceItemCountOrderByAggregateInput = {
    id?: SortOrder
    positionTitle?: SortOrder
    companyName?: SortOrder
    period?: SortOrder
    summary?: SortOrder
    description?: SortOrder
    imageSrc?: SortOrder
    imagePublicId?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExperienceItemAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ExperienceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    positionTitle?: SortOrder
    companyName?: SortOrder
    period?: SortOrder
    summary?: SortOrder
    description?: SortOrder
    imageSrc?: SortOrder
    imagePublicId?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExperienceItemMinOrderByAggregateInput = {
    id?: SortOrder
    positionTitle?: SortOrder
    companyName?: SortOrder
    period?: SortOrder
    summary?: SortOrder
    description?: SortOrder
    imageSrc?: SortOrder
    imagePublicId?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExperienceItemSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ExperienceItemScalarRelationFilter = {
    is?: ExperienceItemWhereInput
    isNot?: ExperienceItemWhereInput
  }

  export type ExperienceDetailImageCountOrderByAggregateInput = {
    id?: SortOrder
    src?: SortOrder
    imagePublicId?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    order?: SortOrder
    experienceItemId?: SortOrder
    createdAt?: SortOrder
  }

  export type ExperienceDetailImageAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ExperienceDetailImageMaxOrderByAggregateInput = {
    id?: SortOrder
    src?: SortOrder
    imagePublicId?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    order?: SortOrder
    experienceItemId?: SortOrder
    createdAt?: SortOrder
  }

  export type ExperienceDetailImageMinOrderByAggregateInput = {
    id?: SortOrder
    src?: SortOrder
    imagePublicId?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    order?: SortOrder
    experienceItemId?: SortOrder
    createdAt?: SortOrder
  }

  export type ExperienceDetailImageSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ProjectItemCountOrderByAggregateInput = {
    id?: SortOrder
    projectNumber?: SortOrder
    title?: SortOrder
    companyName?: SortOrder
    description1?: SortOrder
    description2?: SortOrder
    imageSrc?: SortOrder
    imagePublicId?: SortOrder
    liveLink?: SortOrder
    sourceLink?: SortOrder
    layout?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    categoryIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectItemAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ProjectItemMaxOrderByAggregateInput = {
    id?: SortOrder
    projectNumber?: SortOrder
    title?: SortOrder
    companyName?: SortOrder
    description1?: SortOrder
    description2?: SortOrder
    imageSrc?: SortOrder
    imagePublicId?: SortOrder
    liveLink?: SortOrder
    sourceLink?: SortOrder
    layout?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectItemMinOrderByAggregateInput = {
    id?: SortOrder
    projectNumber?: SortOrder
    title?: SortOrder
    companyName?: SortOrder
    description1?: SortOrder
    description2?: SortOrder
    imageSrc?: SortOrder
    imagePublicId?: SortOrder
    liveLink?: SortOrder
    sourceLink?: SortOrder
    layout?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectItemSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type TestimonialItemCountOrderByAggregateInput = {
    id?: SortOrder
    clientName?: SortOrder
    role?: SortOrder
    company?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    imageSrc?: SortOrder
    imagePublicId?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialItemAvgOrderByAggregateInput = {
    rating?: SortOrder
    order?: SortOrder
  }

  export type TestimonialItemMaxOrderByAggregateInput = {
    id?: SortOrder
    clientName?: SortOrder
    role?: SortOrder
    company?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    imageSrc?: SortOrder
    imagePublicId?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialItemMinOrderByAggregateInput = {
    id?: SortOrder
    clientName?: SortOrder
    role?: SortOrder
    company?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    imageSrc?: SortOrder
    imagePublicId?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialItemSumOrderByAggregateInput = {
    rating?: SortOrder
    order?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ContactInfoItemCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    label?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactInfoItemAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ContactInfoItemMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    label?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactInfoItemMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    label?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactInfoItemSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CustomSectionContentBlockCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    imageSrc?: SortOrder
    imageAlt?: SortOrder
    linkUrl?: SortOrder
    imagePublicId?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomSectionContentBlockAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CustomSectionContentBlockMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    imageSrc?: SortOrder
    imageAlt?: SortOrder
    linkUrl?: SortOrder
    imagePublicId?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomSectionContentBlockMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    imageSrc?: SortOrder
    imageAlt?: SortOrder
    linkUrl?: SortOrder
    imagePublicId?: SortOrder
    order?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomSectionContentBlockSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TextBlockCreateNestedManyWithoutSectionInput = {
    create?: XOR<TextBlockCreateWithoutSectionInput, TextBlockUncheckedCreateWithoutSectionInput> | TextBlockCreateWithoutSectionInput[] | TextBlockUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: TextBlockCreateOrConnectWithoutSectionInput | TextBlockCreateOrConnectWithoutSectionInput[]
    createMany?: TextBlockCreateManySectionInputEnvelope
    connect?: TextBlockWhereUniqueInput | TextBlockWhereUniqueInput[]
  }

  export type ImageBlockCreateNestedManyWithoutSectionInput = {
    create?: XOR<ImageBlockCreateWithoutSectionInput, ImageBlockUncheckedCreateWithoutSectionInput> | ImageBlockCreateWithoutSectionInput[] | ImageBlockUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ImageBlockCreateOrConnectWithoutSectionInput | ImageBlockCreateOrConnectWithoutSectionInput[]
    createMany?: ImageBlockCreateManySectionInputEnvelope
    connect?: ImageBlockWhereUniqueInput | ImageBlockWhereUniqueInput[]
  }

  export type HeroSectionContentCreateNestedOneWithoutSectionInput = {
    create?: XOR<HeroSectionContentCreateWithoutSectionInput, HeroSectionContentUncheckedCreateWithoutSectionInput>
    connectOrCreate?: HeroSectionContentCreateOrConnectWithoutSectionInput
    connect?: HeroSectionContentWhereUniqueInput
  }

  export type EducationItemCreateNestedManyWithoutSectionInput = {
    create?: XOR<EducationItemCreateWithoutSectionInput, EducationItemUncheckedCreateWithoutSectionInput> | EducationItemCreateWithoutSectionInput[] | EducationItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: EducationItemCreateOrConnectWithoutSectionInput | EducationItemCreateOrConnectWithoutSectionInput[]
    createMany?: EducationItemCreateManySectionInputEnvelope
    connect?: EducationItemWhereUniqueInput | EducationItemWhereUniqueInput[]
  }

  export type SkillItemCreateNestedManyWithoutSectionInput = {
    create?: XOR<SkillItemCreateWithoutSectionInput, SkillItemUncheckedCreateWithoutSectionInput> | SkillItemCreateWithoutSectionInput[] | SkillItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: SkillItemCreateOrConnectWithoutSectionInput | SkillItemCreateOrConnectWithoutSectionInput[]
    createMany?: SkillItemCreateManySectionInputEnvelope
    connect?: SkillItemWhereUniqueInput | SkillItemWhereUniqueInput[]
  }

  export type SkillImageCreateNestedManyWithoutSectionInput = {
    create?: XOR<SkillImageCreateWithoutSectionInput, SkillImageUncheckedCreateWithoutSectionInput> | SkillImageCreateWithoutSectionInput[] | SkillImageUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: SkillImageCreateOrConnectWithoutSectionInput | SkillImageCreateOrConnectWithoutSectionInput[]
    createMany?: SkillImageCreateManySectionInputEnvelope
    connect?: SkillImageWhereUniqueInput | SkillImageWhereUniqueInput[]
  }

  export type ExperienceItemCreateNestedManyWithoutSectionInput = {
    create?: XOR<ExperienceItemCreateWithoutSectionInput, ExperienceItemUncheckedCreateWithoutSectionInput> | ExperienceItemCreateWithoutSectionInput[] | ExperienceItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ExperienceItemCreateOrConnectWithoutSectionInput | ExperienceItemCreateOrConnectWithoutSectionInput[]
    createMany?: ExperienceItemCreateManySectionInputEnvelope
    connect?: ExperienceItemWhereUniqueInput | ExperienceItemWhereUniqueInput[]
  }

  export type ProjectItemCreateNestedManyWithoutSectionInput = {
    create?: XOR<ProjectItemCreateWithoutSectionInput, ProjectItemUncheckedCreateWithoutSectionInput> | ProjectItemCreateWithoutSectionInput[] | ProjectItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ProjectItemCreateOrConnectWithoutSectionInput | ProjectItemCreateOrConnectWithoutSectionInput[]
    createMany?: ProjectItemCreateManySectionInputEnvelope
    connect?: ProjectItemWhereUniqueInput | ProjectItemWhereUniqueInput[]
  }

  export type TestimonialItemCreateNestedManyWithoutSectionInput = {
    create?: XOR<TestimonialItemCreateWithoutSectionInput, TestimonialItemUncheckedCreateWithoutSectionInput> | TestimonialItemCreateWithoutSectionInput[] | TestimonialItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: TestimonialItemCreateOrConnectWithoutSectionInput | TestimonialItemCreateOrConnectWithoutSectionInput[]
    createMany?: TestimonialItemCreateManySectionInputEnvelope
    connect?: TestimonialItemWhereUniqueInput | TestimonialItemWhereUniqueInput[]
  }

  export type ContactInfoItemCreateNestedManyWithoutSectionInput = {
    create?: XOR<ContactInfoItemCreateWithoutSectionInput, ContactInfoItemUncheckedCreateWithoutSectionInput> | ContactInfoItemCreateWithoutSectionInput[] | ContactInfoItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ContactInfoItemCreateOrConnectWithoutSectionInput | ContactInfoItemCreateOrConnectWithoutSectionInput[]
    createMany?: ContactInfoItemCreateManySectionInputEnvelope
    connect?: ContactInfoItemWhereUniqueInput | ContactInfoItemWhereUniqueInput[]
  }

  export type CustomSectionContentBlockCreateNestedManyWithoutSectionInput = {
    create?: XOR<CustomSectionContentBlockCreateWithoutSectionInput, CustomSectionContentBlockUncheckedCreateWithoutSectionInput> | CustomSectionContentBlockCreateWithoutSectionInput[] | CustomSectionContentBlockUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: CustomSectionContentBlockCreateOrConnectWithoutSectionInput | CustomSectionContentBlockCreateOrConnectWithoutSectionInput[]
    createMany?: CustomSectionContentBlockCreateManySectionInputEnvelope
    connect?: CustomSectionContentBlockWhereUniqueInput | CustomSectionContentBlockWhereUniqueInput[]
  }

  export type TextBlockUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<TextBlockCreateWithoutSectionInput, TextBlockUncheckedCreateWithoutSectionInput> | TextBlockCreateWithoutSectionInput[] | TextBlockUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: TextBlockCreateOrConnectWithoutSectionInput | TextBlockCreateOrConnectWithoutSectionInput[]
    createMany?: TextBlockCreateManySectionInputEnvelope
    connect?: TextBlockWhereUniqueInput | TextBlockWhereUniqueInput[]
  }

  export type ImageBlockUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<ImageBlockCreateWithoutSectionInput, ImageBlockUncheckedCreateWithoutSectionInput> | ImageBlockCreateWithoutSectionInput[] | ImageBlockUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ImageBlockCreateOrConnectWithoutSectionInput | ImageBlockCreateOrConnectWithoutSectionInput[]
    createMany?: ImageBlockCreateManySectionInputEnvelope
    connect?: ImageBlockWhereUniqueInput | ImageBlockWhereUniqueInput[]
  }

  export type HeroSectionContentUncheckedCreateNestedOneWithoutSectionInput = {
    create?: XOR<HeroSectionContentCreateWithoutSectionInput, HeroSectionContentUncheckedCreateWithoutSectionInput>
    connectOrCreate?: HeroSectionContentCreateOrConnectWithoutSectionInput
    connect?: HeroSectionContentWhereUniqueInput
  }

  export type EducationItemUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<EducationItemCreateWithoutSectionInput, EducationItemUncheckedCreateWithoutSectionInput> | EducationItemCreateWithoutSectionInput[] | EducationItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: EducationItemCreateOrConnectWithoutSectionInput | EducationItemCreateOrConnectWithoutSectionInput[]
    createMany?: EducationItemCreateManySectionInputEnvelope
    connect?: EducationItemWhereUniqueInput | EducationItemWhereUniqueInput[]
  }

  export type SkillItemUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<SkillItemCreateWithoutSectionInput, SkillItemUncheckedCreateWithoutSectionInput> | SkillItemCreateWithoutSectionInput[] | SkillItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: SkillItemCreateOrConnectWithoutSectionInput | SkillItemCreateOrConnectWithoutSectionInput[]
    createMany?: SkillItemCreateManySectionInputEnvelope
    connect?: SkillItemWhereUniqueInput | SkillItemWhereUniqueInput[]
  }

  export type SkillImageUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<SkillImageCreateWithoutSectionInput, SkillImageUncheckedCreateWithoutSectionInput> | SkillImageCreateWithoutSectionInput[] | SkillImageUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: SkillImageCreateOrConnectWithoutSectionInput | SkillImageCreateOrConnectWithoutSectionInput[]
    createMany?: SkillImageCreateManySectionInputEnvelope
    connect?: SkillImageWhereUniqueInput | SkillImageWhereUniqueInput[]
  }

  export type ExperienceItemUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<ExperienceItemCreateWithoutSectionInput, ExperienceItemUncheckedCreateWithoutSectionInput> | ExperienceItemCreateWithoutSectionInput[] | ExperienceItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ExperienceItemCreateOrConnectWithoutSectionInput | ExperienceItemCreateOrConnectWithoutSectionInput[]
    createMany?: ExperienceItemCreateManySectionInputEnvelope
    connect?: ExperienceItemWhereUniqueInput | ExperienceItemWhereUniqueInput[]
  }

  export type ProjectItemUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<ProjectItemCreateWithoutSectionInput, ProjectItemUncheckedCreateWithoutSectionInput> | ProjectItemCreateWithoutSectionInput[] | ProjectItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ProjectItemCreateOrConnectWithoutSectionInput | ProjectItemCreateOrConnectWithoutSectionInput[]
    createMany?: ProjectItemCreateManySectionInputEnvelope
    connect?: ProjectItemWhereUniqueInput | ProjectItemWhereUniqueInput[]
  }

  export type TestimonialItemUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<TestimonialItemCreateWithoutSectionInput, TestimonialItemUncheckedCreateWithoutSectionInput> | TestimonialItemCreateWithoutSectionInput[] | TestimonialItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: TestimonialItemCreateOrConnectWithoutSectionInput | TestimonialItemCreateOrConnectWithoutSectionInput[]
    createMany?: TestimonialItemCreateManySectionInputEnvelope
    connect?: TestimonialItemWhereUniqueInput | TestimonialItemWhereUniqueInput[]
  }

  export type ContactInfoItemUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<ContactInfoItemCreateWithoutSectionInput, ContactInfoItemUncheckedCreateWithoutSectionInput> | ContactInfoItemCreateWithoutSectionInput[] | ContactInfoItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ContactInfoItemCreateOrConnectWithoutSectionInput | ContactInfoItemCreateOrConnectWithoutSectionInput[]
    createMany?: ContactInfoItemCreateManySectionInputEnvelope
    connect?: ContactInfoItemWhereUniqueInput | ContactInfoItemWhereUniqueInput[]
  }

  export type CustomSectionContentBlockUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<CustomSectionContentBlockCreateWithoutSectionInput, CustomSectionContentBlockUncheckedCreateWithoutSectionInput> | CustomSectionContentBlockCreateWithoutSectionInput[] | CustomSectionContentBlockUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: CustomSectionContentBlockCreateOrConnectWithoutSectionInput | CustomSectionContentBlockCreateOrConnectWithoutSectionInput[]
    createMany?: CustomSectionContentBlockCreateManySectionInputEnvelope
    connect?: CustomSectionContentBlockWhereUniqueInput | CustomSectionContentBlockWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TextBlockUpdateManyWithoutSectionNestedInput = {
    create?: XOR<TextBlockCreateWithoutSectionInput, TextBlockUncheckedCreateWithoutSectionInput> | TextBlockCreateWithoutSectionInput[] | TextBlockUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: TextBlockCreateOrConnectWithoutSectionInput | TextBlockCreateOrConnectWithoutSectionInput[]
    upsert?: TextBlockUpsertWithWhereUniqueWithoutSectionInput | TextBlockUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: TextBlockCreateManySectionInputEnvelope
    set?: TextBlockWhereUniqueInput | TextBlockWhereUniqueInput[]
    disconnect?: TextBlockWhereUniqueInput | TextBlockWhereUniqueInput[]
    delete?: TextBlockWhereUniqueInput | TextBlockWhereUniqueInput[]
    connect?: TextBlockWhereUniqueInput | TextBlockWhereUniqueInput[]
    update?: TextBlockUpdateWithWhereUniqueWithoutSectionInput | TextBlockUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: TextBlockUpdateManyWithWhereWithoutSectionInput | TextBlockUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: TextBlockScalarWhereInput | TextBlockScalarWhereInput[]
  }

  export type ImageBlockUpdateManyWithoutSectionNestedInput = {
    create?: XOR<ImageBlockCreateWithoutSectionInput, ImageBlockUncheckedCreateWithoutSectionInput> | ImageBlockCreateWithoutSectionInput[] | ImageBlockUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ImageBlockCreateOrConnectWithoutSectionInput | ImageBlockCreateOrConnectWithoutSectionInput[]
    upsert?: ImageBlockUpsertWithWhereUniqueWithoutSectionInput | ImageBlockUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: ImageBlockCreateManySectionInputEnvelope
    set?: ImageBlockWhereUniqueInput | ImageBlockWhereUniqueInput[]
    disconnect?: ImageBlockWhereUniqueInput | ImageBlockWhereUniqueInput[]
    delete?: ImageBlockWhereUniqueInput | ImageBlockWhereUniqueInput[]
    connect?: ImageBlockWhereUniqueInput | ImageBlockWhereUniqueInput[]
    update?: ImageBlockUpdateWithWhereUniqueWithoutSectionInput | ImageBlockUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: ImageBlockUpdateManyWithWhereWithoutSectionInput | ImageBlockUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: ImageBlockScalarWhereInput | ImageBlockScalarWhereInput[]
  }

  export type HeroSectionContentUpdateOneWithoutSectionNestedInput = {
    create?: XOR<HeroSectionContentCreateWithoutSectionInput, HeroSectionContentUncheckedCreateWithoutSectionInput>
    connectOrCreate?: HeroSectionContentCreateOrConnectWithoutSectionInput
    upsert?: HeroSectionContentUpsertWithoutSectionInput
    disconnect?: HeroSectionContentWhereInput | boolean
    delete?: HeroSectionContentWhereInput | boolean
    connect?: HeroSectionContentWhereUniqueInput
    update?: XOR<XOR<HeroSectionContentUpdateToOneWithWhereWithoutSectionInput, HeroSectionContentUpdateWithoutSectionInput>, HeroSectionContentUncheckedUpdateWithoutSectionInput>
  }

  export type EducationItemUpdateManyWithoutSectionNestedInput = {
    create?: XOR<EducationItemCreateWithoutSectionInput, EducationItemUncheckedCreateWithoutSectionInput> | EducationItemCreateWithoutSectionInput[] | EducationItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: EducationItemCreateOrConnectWithoutSectionInput | EducationItemCreateOrConnectWithoutSectionInput[]
    upsert?: EducationItemUpsertWithWhereUniqueWithoutSectionInput | EducationItemUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: EducationItemCreateManySectionInputEnvelope
    set?: EducationItemWhereUniqueInput | EducationItemWhereUniqueInput[]
    disconnect?: EducationItemWhereUniqueInput | EducationItemWhereUniqueInput[]
    delete?: EducationItemWhereUniqueInput | EducationItemWhereUniqueInput[]
    connect?: EducationItemWhereUniqueInput | EducationItemWhereUniqueInput[]
    update?: EducationItemUpdateWithWhereUniqueWithoutSectionInput | EducationItemUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: EducationItemUpdateManyWithWhereWithoutSectionInput | EducationItemUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: EducationItemScalarWhereInput | EducationItemScalarWhereInput[]
  }

  export type SkillItemUpdateManyWithoutSectionNestedInput = {
    create?: XOR<SkillItemCreateWithoutSectionInput, SkillItemUncheckedCreateWithoutSectionInput> | SkillItemCreateWithoutSectionInput[] | SkillItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: SkillItemCreateOrConnectWithoutSectionInput | SkillItemCreateOrConnectWithoutSectionInput[]
    upsert?: SkillItemUpsertWithWhereUniqueWithoutSectionInput | SkillItemUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: SkillItemCreateManySectionInputEnvelope
    set?: SkillItemWhereUniqueInput | SkillItemWhereUniqueInput[]
    disconnect?: SkillItemWhereUniqueInput | SkillItemWhereUniqueInput[]
    delete?: SkillItemWhereUniqueInput | SkillItemWhereUniqueInput[]
    connect?: SkillItemWhereUniqueInput | SkillItemWhereUniqueInput[]
    update?: SkillItemUpdateWithWhereUniqueWithoutSectionInput | SkillItemUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: SkillItemUpdateManyWithWhereWithoutSectionInput | SkillItemUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: SkillItemScalarWhereInput | SkillItemScalarWhereInput[]
  }

  export type SkillImageUpdateManyWithoutSectionNestedInput = {
    create?: XOR<SkillImageCreateWithoutSectionInput, SkillImageUncheckedCreateWithoutSectionInput> | SkillImageCreateWithoutSectionInput[] | SkillImageUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: SkillImageCreateOrConnectWithoutSectionInput | SkillImageCreateOrConnectWithoutSectionInput[]
    upsert?: SkillImageUpsertWithWhereUniqueWithoutSectionInput | SkillImageUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: SkillImageCreateManySectionInputEnvelope
    set?: SkillImageWhereUniqueInput | SkillImageWhereUniqueInput[]
    disconnect?: SkillImageWhereUniqueInput | SkillImageWhereUniqueInput[]
    delete?: SkillImageWhereUniqueInput | SkillImageWhereUniqueInput[]
    connect?: SkillImageWhereUniqueInput | SkillImageWhereUniqueInput[]
    update?: SkillImageUpdateWithWhereUniqueWithoutSectionInput | SkillImageUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: SkillImageUpdateManyWithWhereWithoutSectionInput | SkillImageUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: SkillImageScalarWhereInput | SkillImageScalarWhereInput[]
  }

  export type ExperienceItemUpdateManyWithoutSectionNestedInput = {
    create?: XOR<ExperienceItemCreateWithoutSectionInput, ExperienceItemUncheckedCreateWithoutSectionInput> | ExperienceItemCreateWithoutSectionInput[] | ExperienceItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ExperienceItemCreateOrConnectWithoutSectionInput | ExperienceItemCreateOrConnectWithoutSectionInput[]
    upsert?: ExperienceItemUpsertWithWhereUniqueWithoutSectionInput | ExperienceItemUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: ExperienceItemCreateManySectionInputEnvelope
    set?: ExperienceItemWhereUniqueInput | ExperienceItemWhereUniqueInput[]
    disconnect?: ExperienceItemWhereUniqueInput | ExperienceItemWhereUniqueInput[]
    delete?: ExperienceItemWhereUniqueInput | ExperienceItemWhereUniqueInput[]
    connect?: ExperienceItemWhereUniqueInput | ExperienceItemWhereUniqueInput[]
    update?: ExperienceItemUpdateWithWhereUniqueWithoutSectionInput | ExperienceItemUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: ExperienceItemUpdateManyWithWhereWithoutSectionInput | ExperienceItemUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: ExperienceItemScalarWhereInput | ExperienceItemScalarWhereInput[]
  }

  export type ProjectItemUpdateManyWithoutSectionNestedInput = {
    create?: XOR<ProjectItemCreateWithoutSectionInput, ProjectItemUncheckedCreateWithoutSectionInput> | ProjectItemCreateWithoutSectionInput[] | ProjectItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ProjectItemCreateOrConnectWithoutSectionInput | ProjectItemCreateOrConnectWithoutSectionInput[]
    upsert?: ProjectItemUpsertWithWhereUniqueWithoutSectionInput | ProjectItemUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: ProjectItemCreateManySectionInputEnvelope
    set?: ProjectItemWhereUniqueInput | ProjectItemWhereUniqueInput[]
    disconnect?: ProjectItemWhereUniqueInput | ProjectItemWhereUniqueInput[]
    delete?: ProjectItemWhereUniqueInput | ProjectItemWhereUniqueInput[]
    connect?: ProjectItemWhereUniqueInput | ProjectItemWhereUniqueInput[]
    update?: ProjectItemUpdateWithWhereUniqueWithoutSectionInput | ProjectItemUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: ProjectItemUpdateManyWithWhereWithoutSectionInput | ProjectItemUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: ProjectItemScalarWhereInput | ProjectItemScalarWhereInput[]
  }

  export type TestimonialItemUpdateManyWithoutSectionNestedInput = {
    create?: XOR<TestimonialItemCreateWithoutSectionInput, TestimonialItemUncheckedCreateWithoutSectionInput> | TestimonialItemCreateWithoutSectionInput[] | TestimonialItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: TestimonialItemCreateOrConnectWithoutSectionInput | TestimonialItemCreateOrConnectWithoutSectionInput[]
    upsert?: TestimonialItemUpsertWithWhereUniqueWithoutSectionInput | TestimonialItemUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: TestimonialItemCreateManySectionInputEnvelope
    set?: TestimonialItemWhereUniqueInput | TestimonialItemWhereUniqueInput[]
    disconnect?: TestimonialItemWhereUniqueInput | TestimonialItemWhereUniqueInput[]
    delete?: TestimonialItemWhereUniqueInput | TestimonialItemWhereUniqueInput[]
    connect?: TestimonialItemWhereUniqueInput | TestimonialItemWhereUniqueInput[]
    update?: TestimonialItemUpdateWithWhereUniqueWithoutSectionInput | TestimonialItemUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: TestimonialItemUpdateManyWithWhereWithoutSectionInput | TestimonialItemUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: TestimonialItemScalarWhereInput | TestimonialItemScalarWhereInput[]
  }

  export type ContactInfoItemUpdateManyWithoutSectionNestedInput = {
    create?: XOR<ContactInfoItemCreateWithoutSectionInput, ContactInfoItemUncheckedCreateWithoutSectionInput> | ContactInfoItemCreateWithoutSectionInput[] | ContactInfoItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ContactInfoItemCreateOrConnectWithoutSectionInput | ContactInfoItemCreateOrConnectWithoutSectionInput[]
    upsert?: ContactInfoItemUpsertWithWhereUniqueWithoutSectionInput | ContactInfoItemUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: ContactInfoItemCreateManySectionInputEnvelope
    set?: ContactInfoItemWhereUniqueInput | ContactInfoItemWhereUniqueInput[]
    disconnect?: ContactInfoItemWhereUniqueInput | ContactInfoItemWhereUniqueInput[]
    delete?: ContactInfoItemWhereUniqueInput | ContactInfoItemWhereUniqueInput[]
    connect?: ContactInfoItemWhereUniqueInput | ContactInfoItemWhereUniqueInput[]
    update?: ContactInfoItemUpdateWithWhereUniqueWithoutSectionInput | ContactInfoItemUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: ContactInfoItemUpdateManyWithWhereWithoutSectionInput | ContactInfoItemUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: ContactInfoItemScalarWhereInput | ContactInfoItemScalarWhereInput[]
  }

  export type CustomSectionContentBlockUpdateManyWithoutSectionNestedInput = {
    create?: XOR<CustomSectionContentBlockCreateWithoutSectionInput, CustomSectionContentBlockUncheckedCreateWithoutSectionInput> | CustomSectionContentBlockCreateWithoutSectionInput[] | CustomSectionContentBlockUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: CustomSectionContentBlockCreateOrConnectWithoutSectionInput | CustomSectionContentBlockCreateOrConnectWithoutSectionInput[]
    upsert?: CustomSectionContentBlockUpsertWithWhereUniqueWithoutSectionInput | CustomSectionContentBlockUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: CustomSectionContentBlockCreateManySectionInputEnvelope
    set?: CustomSectionContentBlockWhereUniqueInput | CustomSectionContentBlockWhereUniqueInput[]
    disconnect?: CustomSectionContentBlockWhereUniqueInput | CustomSectionContentBlockWhereUniqueInput[]
    delete?: CustomSectionContentBlockWhereUniqueInput | CustomSectionContentBlockWhereUniqueInput[]
    connect?: CustomSectionContentBlockWhereUniqueInput | CustomSectionContentBlockWhereUniqueInput[]
    update?: CustomSectionContentBlockUpdateWithWhereUniqueWithoutSectionInput | CustomSectionContentBlockUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: CustomSectionContentBlockUpdateManyWithWhereWithoutSectionInput | CustomSectionContentBlockUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: CustomSectionContentBlockScalarWhereInput | CustomSectionContentBlockScalarWhereInput[]
  }

  export type TextBlockUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<TextBlockCreateWithoutSectionInput, TextBlockUncheckedCreateWithoutSectionInput> | TextBlockCreateWithoutSectionInput[] | TextBlockUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: TextBlockCreateOrConnectWithoutSectionInput | TextBlockCreateOrConnectWithoutSectionInput[]
    upsert?: TextBlockUpsertWithWhereUniqueWithoutSectionInput | TextBlockUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: TextBlockCreateManySectionInputEnvelope
    set?: TextBlockWhereUniqueInput | TextBlockWhereUniqueInput[]
    disconnect?: TextBlockWhereUniqueInput | TextBlockWhereUniqueInput[]
    delete?: TextBlockWhereUniqueInput | TextBlockWhereUniqueInput[]
    connect?: TextBlockWhereUniqueInput | TextBlockWhereUniqueInput[]
    update?: TextBlockUpdateWithWhereUniqueWithoutSectionInput | TextBlockUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: TextBlockUpdateManyWithWhereWithoutSectionInput | TextBlockUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: TextBlockScalarWhereInput | TextBlockScalarWhereInput[]
  }

  export type ImageBlockUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<ImageBlockCreateWithoutSectionInput, ImageBlockUncheckedCreateWithoutSectionInput> | ImageBlockCreateWithoutSectionInput[] | ImageBlockUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ImageBlockCreateOrConnectWithoutSectionInput | ImageBlockCreateOrConnectWithoutSectionInput[]
    upsert?: ImageBlockUpsertWithWhereUniqueWithoutSectionInput | ImageBlockUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: ImageBlockCreateManySectionInputEnvelope
    set?: ImageBlockWhereUniqueInput | ImageBlockWhereUniqueInput[]
    disconnect?: ImageBlockWhereUniqueInput | ImageBlockWhereUniqueInput[]
    delete?: ImageBlockWhereUniqueInput | ImageBlockWhereUniqueInput[]
    connect?: ImageBlockWhereUniqueInput | ImageBlockWhereUniqueInput[]
    update?: ImageBlockUpdateWithWhereUniqueWithoutSectionInput | ImageBlockUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: ImageBlockUpdateManyWithWhereWithoutSectionInput | ImageBlockUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: ImageBlockScalarWhereInput | ImageBlockScalarWhereInput[]
  }

  export type HeroSectionContentUncheckedUpdateOneWithoutSectionNestedInput = {
    create?: XOR<HeroSectionContentCreateWithoutSectionInput, HeroSectionContentUncheckedCreateWithoutSectionInput>
    connectOrCreate?: HeroSectionContentCreateOrConnectWithoutSectionInput
    upsert?: HeroSectionContentUpsertWithoutSectionInput
    disconnect?: HeroSectionContentWhereInput | boolean
    delete?: HeroSectionContentWhereInput | boolean
    connect?: HeroSectionContentWhereUniqueInput
    update?: XOR<XOR<HeroSectionContentUpdateToOneWithWhereWithoutSectionInput, HeroSectionContentUpdateWithoutSectionInput>, HeroSectionContentUncheckedUpdateWithoutSectionInput>
  }

  export type EducationItemUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<EducationItemCreateWithoutSectionInput, EducationItemUncheckedCreateWithoutSectionInput> | EducationItemCreateWithoutSectionInput[] | EducationItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: EducationItemCreateOrConnectWithoutSectionInput | EducationItemCreateOrConnectWithoutSectionInput[]
    upsert?: EducationItemUpsertWithWhereUniqueWithoutSectionInput | EducationItemUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: EducationItemCreateManySectionInputEnvelope
    set?: EducationItemWhereUniqueInput | EducationItemWhereUniqueInput[]
    disconnect?: EducationItemWhereUniqueInput | EducationItemWhereUniqueInput[]
    delete?: EducationItemWhereUniqueInput | EducationItemWhereUniqueInput[]
    connect?: EducationItemWhereUniqueInput | EducationItemWhereUniqueInput[]
    update?: EducationItemUpdateWithWhereUniqueWithoutSectionInput | EducationItemUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: EducationItemUpdateManyWithWhereWithoutSectionInput | EducationItemUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: EducationItemScalarWhereInput | EducationItemScalarWhereInput[]
  }

  export type SkillItemUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<SkillItemCreateWithoutSectionInput, SkillItemUncheckedCreateWithoutSectionInput> | SkillItemCreateWithoutSectionInput[] | SkillItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: SkillItemCreateOrConnectWithoutSectionInput | SkillItemCreateOrConnectWithoutSectionInput[]
    upsert?: SkillItemUpsertWithWhereUniqueWithoutSectionInput | SkillItemUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: SkillItemCreateManySectionInputEnvelope
    set?: SkillItemWhereUniqueInput | SkillItemWhereUniqueInput[]
    disconnect?: SkillItemWhereUniqueInput | SkillItemWhereUniqueInput[]
    delete?: SkillItemWhereUniqueInput | SkillItemWhereUniqueInput[]
    connect?: SkillItemWhereUniqueInput | SkillItemWhereUniqueInput[]
    update?: SkillItemUpdateWithWhereUniqueWithoutSectionInput | SkillItemUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: SkillItemUpdateManyWithWhereWithoutSectionInput | SkillItemUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: SkillItemScalarWhereInput | SkillItemScalarWhereInput[]
  }

  export type SkillImageUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<SkillImageCreateWithoutSectionInput, SkillImageUncheckedCreateWithoutSectionInput> | SkillImageCreateWithoutSectionInput[] | SkillImageUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: SkillImageCreateOrConnectWithoutSectionInput | SkillImageCreateOrConnectWithoutSectionInput[]
    upsert?: SkillImageUpsertWithWhereUniqueWithoutSectionInput | SkillImageUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: SkillImageCreateManySectionInputEnvelope
    set?: SkillImageWhereUniqueInput | SkillImageWhereUniqueInput[]
    disconnect?: SkillImageWhereUniqueInput | SkillImageWhereUniqueInput[]
    delete?: SkillImageWhereUniqueInput | SkillImageWhereUniqueInput[]
    connect?: SkillImageWhereUniqueInput | SkillImageWhereUniqueInput[]
    update?: SkillImageUpdateWithWhereUniqueWithoutSectionInput | SkillImageUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: SkillImageUpdateManyWithWhereWithoutSectionInput | SkillImageUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: SkillImageScalarWhereInput | SkillImageScalarWhereInput[]
  }

  export type ExperienceItemUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<ExperienceItemCreateWithoutSectionInput, ExperienceItemUncheckedCreateWithoutSectionInput> | ExperienceItemCreateWithoutSectionInput[] | ExperienceItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ExperienceItemCreateOrConnectWithoutSectionInput | ExperienceItemCreateOrConnectWithoutSectionInput[]
    upsert?: ExperienceItemUpsertWithWhereUniqueWithoutSectionInput | ExperienceItemUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: ExperienceItemCreateManySectionInputEnvelope
    set?: ExperienceItemWhereUniqueInput | ExperienceItemWhereUniqueInput[]
    disconnect?: ExperienceItemWhereUniqueInput | ExperienceItemWhereUniqueInput[]
    delete?: ExperienceItemWhereUniqueInput | ExperienceItemWhereUniqueInput[]
    connect?: ExperienceItemWhereUniqueInput | ExperienceItemWhereUniqueInput[]
    update?: ExperienceItemUpdateWithWhereUniqueWithoutSectionInput | ExperienceItemUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: ExperienceItemUpdateManyWithWhereWithoutSectionInput | ExperienceItemUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: ExperienceItemScalarWhereInput | ExperienceItemScalarWhereInput[]
  }

  export type ProjectItemUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<ProjectItemCreateWithoutSectionInput, ProjectItemUncheckedCreateWithoutSectionInput> | ProjectItemCreateWithoutSectionInput[] | ProjectItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ProjectItemCreateOrConnectWithoutSectionInput | ProjectItemCreateOrConnectWithoutSectionInput[]
    upsert?: ProjectItemUpsertWithWhereUniqueWithoutSectionInput | ProjectItemUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: ProjectItemCreateManySectionInputEnvelope
    set?: ProjectItemWhereUniqueInput | ProjectItemWhereUniqueInput[]
    disconnect?: ProjectItemWhereUniqueInput | ProjectItemWhereUniqueInput[]
    delete?: ProjectItemWhereUniqueInput | ProjectItemWhereUniqueInput[]
    connect?: ProjectItemWhereUniqueInput | ProjectItemWhereUniqueInput[]
    update?: ProjectItemUpdateWithWhereUniqueWithoutSectionInput | ProjectItemUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: ProjectItemUpdateManyWithWhereWithoutSectionInput | ProjectItemUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: ProjectItemScalarWhereInput | ProjectItemScalarWhereInput[]
  }

  export type TestimonialItemUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<TestimonialItemCreateWithoutSectionInput, TestimonialItemUncheckedCreateWithoutSectionInput> | TestimonialItemCreateWithoutSectionInput[] | TestimonialItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: TestimonialItemCreateOrConnectWithoutSectionInput | TestimonialItemCreateOrConnectWithoutSectionInput[]
    upsert?: TestimonialItemUpsertWithWhereUniqueWithoutSectionInput | TestimonialItemUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: TestimonialItemCreateManySectionInputEnvelope
    set?: TestimonialItemWhereUniqueInput | TestimonialItemWhereUniqueInput[]
    disconnect?: TestimonialItemWhereUniqueInput | TestimonialItemWhereUniqueInput[]
    delete?: TestimonialItemWhereUniqueInput | TestimonialItemWhereUniqueInput[]
    connect?: TestimonialItemWhereUniqueInput | TestimonialItemWhereUniqueInput[]
    update?: TestimonialItemUpdateWithWhereUniqueWithoutSectionInput | TestimonialItemUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: TestimonialItemUpdateManyWithWhereWithoutSectionInput | TestimonialItemUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: TestimonialItemScalarWhereInput | TestimonialItemScalarWhereInput[]
  }

  export type ContactInfoItemUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<ContactInfoItemCreateWithoutSectionInput, ContactInfoItemUncheckedCreateWithoutSectionInput> | ContactInfoItemCreateWithoutSectionInput[] | ContactInfoItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ContactInfoItemCreateOrConnectWithoutSectionInput | ContactInfoItemCreateOrConnectWithoutSectionInput[]
    upsert?: ContactInfoItemUpsertWithWhereUniqueWithoutSectionInput | ContactInfoItemUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: ContactInfoItemCreateManySectionInputEnvelope
    set?: ContactInfoItemWhereUniqueInput | ContactInfoItemWhereUniqueInput[]
    disconnect?: ContactInfoItemWhereUniqueInput | ContactInfoItemWhereUniqueInput[]
    delete?: ContactInfoItemWhereUniqueInput | ContactInfoItemWhereUniqueInput[]
    connect?: ContactInfoItemWhereUniqueInput | ContactInfoItemWhereUniqueInput[]
    update?: ContactInfoItemUpdateWithWhereUniqueWithoutSectionInput | ContactInfoItemUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: ContactInfoItemUpdateManyWithWhereWithoutSectionInput | ContactInfoItemUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: ContactInfoItemScalarWhereInput | ContactInfoItemScalarWhereInput[]
  }

  export type CustomSectionContentBlockUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<CustomSectionContentBlockCreateWithoutSectionInput, CustomSectionContentBlockUncheckedCreateWithoutSectionInput> | CustomSectionContentBlockCreateWithoutSectionInput[] | CustomSectionContentBlockUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: CustomSectionContentBlockCreateOrConnectWithoutSectionInput | CustomSectionContentBlockCreateOrConnectWithoutSectionInput[]
    upsert?: CustomSectionContentBlockUpsertWithWhereUniqueWithoutSectionInput | CustomSectionContentBlockUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: CustomSectionContentBlockCreateManySectionInputEnvelope
    set?: CustomSectionContentBlockWhereUniqueInput | CustomSectionContentBlockWhereUniqueInput[]
    disconnect?: CustomSectionContentBlockWhereUniqueInput | CustomSectionContentBlockWhereUniqueInput[]
    delete?: CustomSectionContentBlockWhereUniqueInput | CustomSectionContentBlockWhereUniqueInput[]
    connect?: CustomSectionContentBlockWhereUniqueInput | CustomSectionContentBlockWhereUniqueInput[]
    update?: CustomSectionContentBlockUpdateWithWhereUniqueWithoutSectionInput | CustomSectionContentBlockUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: CustomSectionContentBlockUpdateManyWithWhereWithoutSectionInput | CustomSectionContentBlockUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: CustomSectionContentBlockScalarWhereInput | CustomSectionContentBlockScalarWhereInput[]
  }

  export type CategoryCreateprojectIdsInput = {
    set: string[]
  }

  export type CategoryUpdateprojectIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SectionCreateNestedOneWithoutTextBlocksInput = {
    create?: XOR<SectionCreateWithoutTextBlocksInput, SectionUncheckedCreateWithoutTextBlocksInput>
    connectOrCreate?: SectionCreateOrConnectWithoutTextBlocksInput
    connect?: SectionWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type SectionUpdateOneRequiredWithoutTextBlocksNestedInput = {
    create?: XOR<SectionCreateWithoutTextBlocksInput, SectionUncheckedCreateWithoutTextBlocksInput>
    connectOrCreate?: SectionCreateOrConnectWithoutTextBlocksInput
    upsert?: SectionUpsertWithoutTextBlocksInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutTextBlocksInput, SectionUpdateWithoutTextBlocksInput>, SectionUncheckedUpdateWithoutTextBlocksInput>
  }

  export type SectionCreateNestedOneWithoutImageBlocksInput = {
    create?: XOR<SectionCreateWithoutImageBlocksInput, SectionUncheckedCreateWithoutImageBlocksInput>
    connectOrCreate?: SectionCreateOrConnectWithoutImageBlocksInput
    connect?: SectionWhereUniqueInput
  }

  export type SectionUpdateOneRequiredWithoutImageBlocksNestedInput = {
    create?: XOR<SectionCreateWithoutImageBlocksInput, SectionUncheckedCreateWithoutImageBlocksInput>
    connectOrCreate?: SectionCreateOrConnectWithoutImageBlocksInput
    upsert?: SectionUpsertWithoutImageBlocksInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutImageBlocksInput, SectionUpdateWithoutImageBlocksInput>, SectionUncheckedUpdateWithoutImageBlocksInput>
  }

  export type SectionCreateNestedOneWithoutHeroContentInput = {
    create?: XOR<SectionCreateWithoutHeroContentInput, SectionUncheckedCreateWithoutHeroContentInput>
    connectOrCreate?: SectionCreateOrConnectWithoutHeroContentInput
    connect?: SectionWhereUniqueInput
  }

  export type SectionUpdateOneRequiredWithoutHeroContentNestedInput = {
    create?: XOR<SectionCreateWithoutHeroContentInput, SectionUncheckedCreateWithoutHeroContentInput>
    connectOrCreate?: SectionCreateOrConnectWithoutHeroContentInput
    upsert?: SectionUpsertWithoutHeroContentInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutHeroContentInput, SectionUpdateWithoutHeroContentInput>, SectionUncheckedUpdateWithoutHeroContentInput>
  }

  export type SectionCreateNestedOneWithoutEducationItemsInput = {
    create?: XOR<SectionCreateWithoutEducationItemsInput, SectionUncheckedCreateWithoutEducationItemsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutEducationItemsInput
    connect?: SectionWhereUniqueInput
  }

  export type EducationImageCreateNestedManyWithoutEducationItemInput = {
    create?: XOR<EducationImageCreateWithoutEducationItemInput, EducationImageUncheckedCreateWithoutEducationItemInput> | EducationImageCreateWithoutEducationItemInput[] | EducationImageUncheckedCreateWithoutEducationItemInput[]
    connectOrCreate?: EducationImageCreateOrConnectWithoutEducationItemInput | EducationImageCreateOrConnectWithoutEducationItemInput[]
    createMany?: EducationImageCreateManyEducationItemInputEnvelope
    connect?: EducationImageWhereUniqueInput | EducationImageWhereUniqueInput[]
  }

  export type EducationImageUncheckedCreateNestedManyWithoutEducationItemInput = {
    create?: XOR<EducationImageCreateWithoutEducationItemInput, EducationImageUncheckedCreateWithoutEducationItemInput> | EducationImageCreateWithoutEducationItemInput[] | EducationImageUncheckedCreateWithoutEducationItemInput[]
    connectOrCreate?: EducationImageCreateOrConnectWithoutEducationItemInput | EducationImageCreateOrConnectWithoutEducationItemInput[]
    createMany?: EducationImageCreateManyEducationItemInputEnvelope
    connect?: EducationImageWhereUniqueInput | EducationImageWhereUniqueInput[]
  }

  export type SectionUpdateOneRequiredWithoutEducationItemsNestedInput = {
    create?: XOR<SectionCreateWithoutEducationItemsInput, SectionUncheckedCreateWithoutEducationItemsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutEducationItemsInput
    upsert?: SectionUpsertWithoutEducationItemsInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutEducationItemsInput, SectionUpdateWithoutEducationItemsInput>, SectionUncheckedUpdateWithoutEducationItemsInput>
  }

  export type EducationImageUpdateManyWithoutEducationItemNestedInput = {
    create?: XOR<EducationImageCreateWithoutEducationItemInput, EducationImageUncheckedCreateWithoutEducationItemInput> | EducationImageCreateWithoutEducationItemInput[] | EducationImageUncheckedCreateWithoutEducationItemInput[]
    connectOrCreate?: EducationImageCreateOrConnectWithoutEducationItemInput | EducationImageCreateOrConnectWithoutEducationItemInput[]
    upsert?: EducationImageUpsertWithWhereUniqueWithoutEducationItemInput | EducationImageUpsertWithWhereUniqueWithoutEducationItemInput[]
    createMany?: EducationImageCreateManyEducationItemInputEnvelope
    set?: EducationImageWhereUniqueInput | EducationImageWhereUniqueInput[]
    disconnect?: EducationImageWhereUniqueInput | EducationImageWhereUniqueInput[]
    delete?: EducationImageWhereUniqueInput | EducationImageWhereUniqueInput[]
    connect?: EducationImageWhereUniqueInput | EducationImageWhereUniqueInput[]
    update?: EducationImageUpdateWithWhereUniqueWithoutEducationItemInput | EducationImageUpdateWithWhereUniqueWithoutEducationItemInput[]
    updateMany?: EducationImageUpdateManyWithWhereWithoutEducationItemInput | EducationImageUpdateManyWithWhereWithoutEducationItemInput[]
    deleteMany?: EducationImageScalarWhereInput | EducationImageScalarWhereInput[]
  }

  export type EducationImageUncheckedUpdateManyWithoutEducationItemNestedInput = {
    create?: XOR<EducationImageCreateWithoutEducationItemInput, EducationImageUncheckedCreateWithoutEducationItemInput> | EducationImageCreateWithoutEducationItemInput[] | EducationImageUncheckedCreateWithoutEducationItemInput[]
    connectOrCreate?: EducationImageCreateOrConnectWithoutEducationItemInput | EducationImageCreateOrConnectWithoutEducationItemInput[]
    upsert?: EducationImageUpsertWithWhereUniqueWithoutEducationItemInput | EducationImageUpsertWithWhereUniqueWithoutEducationItemInput[]
    createMany?: EducationImageCreateManyEducationItemInputEnvelope
    set?: EducationImageWhereUniqueInput | EducationImageWhereUniqueInput[]
    disconnect?: EducationImageWhereUniqueInput | EducationImageWhereUniqueInput[]
    delete?: EducationImageWhereUniqueInput | EducationImageWhereUniqueInput[]
    connect?: EducationImageWhereUniqueInput | EducationImageWhereUniqueInput[]
    update?: EducationImageUpdateWithWhereUniqueWithoutEducationItemInput | EducationImageUpdateWithWhereUniqueWithoutEducationItemInput[]
    updateMany?: EducationImageUpdateManyWithWhereWithoutEducationItemInput | EducationImageUpdateManyWithWhereWithoutEducationItemInput[]
    deleteMany?: EducationImageScalarWhereInput | EducationImageScalarWhereInput[]
  }

  export type EducationItemCreateNestedOneWithoutImagesInput = {
    create?: XOR<EducationItemCreateWithoutImagesInput, EducationItemUncheckedCreateWithoutImagesInput>
    connectOrCreate?: EducationItemCreateOrConnectWithoutImagesInput
    connect?: EducationItemWhereUniqueInput
  }

  export type EducationItemUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<EducationItemCreateWithoutImagesInput, EducationItemUncheckedCreateWithoutImagesInput>
    connectOrCreate?: EducationItemCreateOrConnectWithoutImagesInput
    upsert?: EducationItemUpsertWithoutImagesInput
    connect?: EducationItemWhereUniqueInput
    update?: XOR<XOR<EducationItemUpdateToOneWithWhereWithoutImagesInput, EducationItemUpdateWithoutImagesInput>, EducationItemUncheckedUpdateWithoutImagesInput>
  }

  export type SectionCreateNestedOneWithoutSkillItemsInput = {
    create?: XOR<SectionCreateWithoutSkillItemsInput, SectionUncheckedCreateWithoutSkillItemsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutSkillItemsInput
    connect?: SectionWhereUniqueInput
  }

  export type SectionUpdateOneRequiredWithoutSkillItemsNestedInput = {
    create?: XOR<SectionCreateWithoutSkillItemsInput, SectionUncheckedCreateWithoutSkillItemsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutSkillItemsInput
    upsert?: SectionUpsertWithoutSkillItemsInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutSkillItemsInput, SectionUpdateWithoutSkillItemsInput>, SectionUncheckedUpdateWithoutSkillItemsInput>
  }

  export type SectionCreateNestedOneWithoutSkillImagesInput = {
    create?: XOR<SectionCreateWithoutSkillImagesInput, SectionUncheckedCreateWithoutSkillImagesInput>
    connectOrCreate?: SectionCreateOrConnectWithoutSkillImagesInput
    connect?: SectionWhereUniqueInput
  }

  export type SectionUpdateOneRequiredWithoutSkillImagesNestedInput = {
    create?: XOR<SectionCreateWithoutSkillImagesInput, SectionUncheckedCreateWithoutSkillImagesInput>
    connectOrCreate?: SectionCreateOrConnectWithoutSkillImagesInput
    upsert?: SectionUpsertWithoutSkillImagesInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutSkillImagesInput, SectionUpdateWithoutSkillImagesInput>, SectionUncheckedUpdateWithoutSkillImagesInput>
  }

  export type SectionCreateNestedOneWithoutExperienceItemsInput = {
    create?: XOR<SectionCreateWithoutExperienceItemsInput, SectionUncheckedCreateWithoutExperienceItemsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutExperienceItemsInput
    connect?: SectionWhereUniqueInput
  }

  export type ExperienceDetailImageCreateNestedManyWithoutExperienceItemInput = {
    create?: XOR<ExperienceDetailImageCreateWithoutExperienceItemInput, ExperienceDetailImageUncheckedCreateWithoutExperienceItemInput> | ExperienceDetailImageCreateWithoutExperienceItemInput[] | ExperienceDetailImageUncheckedCreateWithoutExperienceItemInput[]
    connectOrCreate?: ExperienceDetailImageCreateOrConnectWithoutExperienceItemInput | ExperienceDetailImageCreateOrConnectWithoutExperienceItemInput[]
    createMany?: ExperienceDetailImageCreateManyExperienceItemInputEnvelope
    connect?: ExperienceDetailImageWhereUniqueInput | ExperienceDetailImageWhereUniqueInput[]
  }

  export type ExperienceDetailImageUncheckedCreateNestedManyWithoutExperienceItemInput = {
    create?: XOR<ExperienceDetailImageCreateWithoutExperienceItemInput, ExperienceDetailImageUncheckedCreateWithoutExperienceItemInput> | ExperienceDetailImageCreateWithoutExperienceItemInput[] | ExperienceDetailImageUncheckedCreateWithoutExperienceItemInput[]
    connectOrCreate?: ExperienceDetailImageCreateOrConnectWithoutExperienceItemInput | ExperienceDetailImageCreateOrConnectWithoutExperienceItemInput[]
    createMany?: ExperienceDetailImageCreateManyExperienceItemInputEnvelope
    connect?: ExperienceDetailImageWhereUniqueInput | ExperienceDetailImageWhereUniqueInput[]
  }

  export type SectionUpdateOneRequiredWithoutExperienceItemsNestedInput = {
    create?: XOR<SectionCreateWithoutExperienceItemsInput, SectionUncheckedCreateWithoutExperienceItemsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutExperienceItemsInput
    upsert?: SectionUpsertWithoutExperienceItemsInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutExperienceItemsInput, SectionUpdateWithoutExperienceItemsInput>, SectionUncheckedUpdateWithoutExperienceItemsInput>
  }

  export type ExperienceDetailImageUpdateManyWithoutExperienceItemNestedInput = {
    create?: XOR<ExperienceDetailImageCreateWithoutExperienceItemInput, ExperienceDetailImageUncheckedCreateWithoutExperienceItemInput> | ExperienceDetailImageCreateWithoutExperienceItemInput[] | ExperienceDetailImageUncheckedCreateWithoutExperienceItemInput[]
    connectOrCreate?: ExperienceDetailImageCreateOrConnectWithoutExperienceItemInput | ExperienceDetailImageCreateOrConnectWithoutExperienceItemInput[]
    upsert?: ExperienceDetailImageUpsertWithWhereUniqueWithoutExperienceItemInput | ExperienceDetailImageUpsertWithWhereUniqueWithoutExperienceItemInput[]
    createMany?: ExperienceDetailImageCreateManyExperienceItemInputEnvelope
    set?: ExperienceDetailImageWhereUniqueInput | ExperienceDetailImageWhereUniqueInput[]
    disconnect?: ExperienceDetailImageWhereUniqueInput | ExperienceDetailImageWhereUniqueInput[]
    delete?: ExperienceDetailImageWhereUniqueInput | ExperienceDetailImageWhereUniqueInput[]
    connect?: ExperienceDetailImageWhereUniqueInput | ExperienceDetailImageWhereUniqueInput[]
    update?: ExperienceDetailImageUpdateWithWhereUniqueWithoutExperienceItemInput | ExperienceDetailImageUpdateWithWhereUniqueWithoutExperienceItemInput[]
    updateMany?: ExperienceDetailImageUpdateManyWithWhereWithoutExperienceItemInput | ExperienceDetailImageUpdateManyWithWhereWithoutExperienceItemInput[]
    deleteMany?: ExperienceDetailImageScalarWhereInput | ExperienceDetailImageScalarWhereInput[]
  }

  export type ExperienceDetailImageUncheckedUpdateManyWithoutExperienceItemNestedInput = {
    create?: XOR<ExperienceDetailImageCreateWithoutExperienceItemInput, ExperienceDetailImageUncheckedCreateWithoutExperienceItemInput> | ExperienceDetailImageCreateWithoutExperienceItemInput[] | ExperienceDetailImageUncheckedCreateWithoutExperienceItemInput[]
    connectOrCreate?: ExperienceDetailImageCreateOrConnectWithoutExperienceItemInput | ExperienceDetailImageCreateOrConnectWithoutExperienceItemInput[]
    upsert?: ExperienceDetailImageUpsertWithWhereUniqueWithoutExperienceItemInput | ExperienceDetailImageUpsertWithWhereUniqueWithoutExperienceItemInput[]
    createMany?: ExperienceDetailImageCreateManyExperienceItemInputEnvelope
    set?: ExperienceDetailImageWhereUniqueInput | ExperienceDetailImageWhereUniqueInput[]
    disconnect?: ExperienceDetailImageWhereUniqueInput | ExperienceDetailImageWhereUniqueInput[]
    delete?: ExperienceDetailImageWhereUniqueInput | ExperienceDetailImageWhereUniqueInput[]
    connect?: ExperienceDetailImageWhereUniqueInput | ExperienceDetailImageWhereUniqueInput[]
    update?: ExperienceDetailImageUpdateWithWhereUniqueWithoutExperienceItemInput | ExperienceDetailImageUpdateWithWhereUniqueWithoutExperienceItemInput[]
    updateMany?: ExperienceDetailImageUpdateManyWithWhereWithoutExperienceItemInput | ExperienceDetailImageUpdateManyWithWhereWithoutExperienceItemInput[]
    deleteMany?: ExperienceDetailImageScalarWhereInput | ExperienceDetailImageScalarWhereInput[]
  }

  export type ExperienceItemCreateNestedOneWithoutDetailImagesInput = {
    create?: XOR<ExperienceItemCreateWithoutDetailImagesInput, ExperienceItemUncheckedCreateWithoutDetailImagesInput>
    connectOrCreate?: ExperienceItemCreateOrConnectWithoutDetailImagesInput
    connect?: ExperienceItemWhereUniqueInput
  }

  export type ExperienceItemUpdateOneRequiredWithoutDetailImagesNestedInput = {
    create?: XOR<ExperienceItemCreateWithoutDetailImagesInput, ExperienceItemUncheckedCreateWithoutDetailImagesInput>
    connectOrCreate?: ExperienceItemCreateOrConnectWithoutDetailImagesInput
    upsert?: ExperienceItemUpsertWithoutDetailImagesInput
    connect?: ExperienceItemWhereUniqueInput
    update?: XOR<XOR<ExperienceItemUpdateToOneWithWhereWithoutDetailImagesInput, ExperienceItemUpdateWithoutDetailImagesInput>, ExperienceItemUncheckedUpdateWithoutDetailImagesInput>
  }

  export type ProjectItemCreatecategoryIdsInput = {
    set: string[]
  }

  export type SectionCreateNestedOneWithoutProjectItemsInput = {
    create?: XOR<SectionCreateWithoutProjectItemsInput, SectionUncheckedCreateWithoutProjectItemsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutProjectItemsInput
    connect?: SectionWhereUniqueInput
  }

  export type ProjectItemUpdatecategoryIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SectionUpdateOneRequiredWithoutProjectItemsNestedInput = {
    create?: XOR<SectionCreateWithoutProjectItemsInput, SectionUncheckedCreateWithoutProjectItemsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutProjectItemsInput
    upsert?: SectionUpsertWithoutProjectItemsInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutProjectItemsInput, SectionUpdateWithoutProjectItemsInput>, SectionUncheckedUpdateWithoutProjectItemsInput>
  }

  export type SectionCreateNestedOneWithoutTestimonialItemsInput = {
    create?: XOR<SectionCreateWithoutTestimonialItemsInput, SectionUncheckedCreateWithoutTestimonialItemsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutTestimonialItemsInput
    connect?: SectionWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SectionUpdateOneRequiredWithoutTestimonialItemsNestedInput = {
    create?: XOR<SectionCreateWithoutTestimonialItemsInput, SectionUncheckedCreateWithoutTestimonialItemsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutTestimonialItemsInput
    upsert?: SectionUpsertWithoutTestimonialItemsInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutTestimonialItemsInput, SectionUpdateWithoutTestimonialItemsInput>, SectionUncheckedUpdateWithoutTestimonialItemsInput>
  }

  export type SectionCreateNestedOneWithoutContactInfoItemsInput = {
    create?: XOR<SectionCreateWithoutContactInfoItemsInput, SectionUncheckedCreateWithoutContactInfoItemsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutContactInfoItemsInput
    connect?: SectionWhereUniqueInput
  }

  export type SectionUpdateOneRequiredWithoutContactInfoItemsNestedInput = {
    create?: XOR<SectionCreateWithoutContactInfoItemsInput, SectionUncheckedCreateWithoutContactInfoItemsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutContactInfoItemsInput
    upsert?: SectionUpsertWithoutContactInfoItemsInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutContactInfoItemsInput, SectionUpdateWithoutContactInfoItemsInput>, SectionUncheckedUpdateWithoutContactInfoItemsInput>
  }

  export type SectionCreateNestedOneWithoutCustomSectionContentBlocksInput = {
    create?: XOR<SectionCreateWithoutCustomSectionContentBlocksInput, SectionUncheckedCreateWithoutCustomSectionContentBlocksInput>
    connectOrCreate?: SectionCreateOrConnectWithoutCustomSectionContentBlocksInput
    connect?: SectionWhereUniqueInput
  }

  export type SectionUpdateOneRequiredWithoutCustomSectionContentBlocksNestedInput = {
    create?: XOR<SectionCreateWithoutCustomSectionContentBlocksInput, SectionUncheckedCreateWithoutCustomSectionContentBlocksInput>
    connectOrCreate?: SectionCreateOrConnectWithoutCustomSectionContentBlocksInput
    upsert?: SectionUpsertWithoutCustomSectionContentBlocksInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutCustomSectionContentBlocksInput, SectionUpdateWithoutCustomSectionContentBlocksInput>, SectionUncheckedUpdateWithoutCustomSectionContentBlocksInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type TextBlockCreateWithoutSectionInput = {
    id?: string
    content: string
    order?: number
    fontSize?: number | null
    fontFamily?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TextBlockUncheckedCreateWithoutSectionInput = {
    id?: string
    content: string
    order?: number
    fontSize?: number | null
    fontFamily?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TextBlockCreateOrConnectWithoutSectionInput = {
    where: TextBlockWhereUniqueInput
    create: XOR<TextBlockCreateWithoutSectionInput, TextBlockUncheckedCreateWithoutSectionInput>
  }

  export type TextBlockCreateManySectionInputEnvelope = {
    data: TextBlockCreateManySectionInput | TextBlockCreateManySectionInput[]
  }

  export type ImageBlockCreateWithoutSectionInput = {
    id?: string
    src: string
    alt?: string | null
    caption?: string | null
    imagePublicId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageBlockUncheckedCreateWithoutSectionInput = {
    id?: string
    src: string
    alt?: string | null
    caption?: string | null
    imagePublicId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageBlockCreateOrConnectWithoutSectionInput = {
    where: ImageBlockWhereUniqueInput
    create: XOR<ImageBlockCreateWithoutSectionInput, ImageBlockUncheckedCreateWithoutSectionInput>
  }

  export type ImageBlockCreateManySectionInputEnvelope = {
    data: ImageBlockCreateManySectionInput | ImageBlockCreateManySectionInput[]
  }

  export type HeroSectionContentCreateWithoutSectionInput = {
    id?: string
    portraitImageSrc?: string | null
    portraitImagePublicId?: string | null
    portraitAlt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HeroSectionContentUncheckedCreateWithoutSectionInput = {
    id?: string
    portraitImageSrc?: string | null
    portraitImagePublicId?: string | null
    portraitAlt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HeroSectionContentCreateOrConnectWithoutSectionInput = {
    where: HeroSectionContentWhereUniqueInput
    create: XOR<HeroSectionContentCreateWithoutSectionInput, HeroSectionContentUncheckedCreateWithoutSectionInput>
  }

  export type EducationItemCreateWithoutSectionInput = {
    id?: string
    institution: string
    degree?: string | null
    period: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: EducationImageCreateNestedManyWithoutEducationItemInput
  }

  export type EducationItemUncheckedCreateWithoutSectionInput = {
    id?: string
    institution: string
    degree?: string | null
    period: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: EducationImageUncheckedCreateNestedManyWithoutEducationItemInput
  }

  export type EducationItemCreateOrConnectWithoutSectionInput = {
    where: EducationItemWhereUniqueInput
    create: XOR<EducationItemCreateWithoutSectionInput, EducationItemUncheckedCreateWithoutSectionInput>
  }

  export type EducationItemCreateManySectionInputEnvelope = {
    data: EducationItemCreateManySectionInput | EducationItemCreateManySectionInput[]
  }

  export type SkillItemCreateWithoutSectionInput = {
    id?: string
    title: string
    description?: string | null
    level?: number | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillItemUncheckedCreateWithoutSectionInput = {
    id?: string
    title: string
    description?: string | null
    level?: number | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillItemCreateOrConnectWithoutSectionInput = {
    where: SkillItemWhereUniqueInput
    create: XOR<SkillItemCreateWithoutSectionInput, SkillItemUncheckedCreateWithoutSectionInput>
  }

  export type SkillItemCreateManySectionInputEnvelope = {
    data: SkillItemCreateManySectionInput | SkillItemCreateManySectionInput[]
  }

  export type SkillImageCreateWithoutSectionInput = {
    id?: string
    src: string
    imagePublicId?: string | null
    alt?: string | null
    caption?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type SkillImageUncheckedCreateWithoutSectionInput = {
    id?: string
    src: string
    imagePublicId?: string | null
    alt?: string | null
    caption?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type SkillImageCreateOrConnectWithoutSectionInput = {
    where: SkillImageWhereUniqueInput
    create: XOR<SkillImageCreateWithoutSectionInput, SkillImageUncheckedCreateWithoutSectionInput>
  }

  export type SkillImageCreateManySectionInputEnvelope = {
    data: SkillImageCreateManySectionInput | SkillImageCreateManySectionInput[]
  }

  export type ExperienceItemCreateWithoutSectionInput = {
    id?: string
    positionTitle: string
    companyName: string
    period: string
    summary?: string | null
    description?: string | null
    imageSrc: string
    imagePublicId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    detailImages?: ExperienceDetailImageCreateNestedManyWithoutExperienceItemInput
  }

  export type ExperienceItemUncheckedCreateWithoutSectionInput = {
    id?: string
    positionTitle: string
    companyName: string
    period: string
    summary?: string | null
    description?: string | null
    imageSrc: string
    imagePublicId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    detailImages?: ExperienceDetailImageUncheckedCreateNestedManyWithoutExperienceItemInput
  }

  export type ExperienceItemCreateOrConnectWithoutSectionInput = {
    where: ExperienceItemWhereUniqueInput
    create: XOR<ExperienceItemCreateWithoutSectionInput, ExperienceItemUncheckedCreateWithoutSectionInput>
  }

  export type ExperienceItemCreateManySectionInputEnvelope = {
    data: ExperienceItemCreateManySectionInput | ExperienceItemCreateManySectionInput[]
  }

  export type ProjectItemCreateWithoutSectionInput = {
    id?: string
    projectNumber?: string | null
    title: string
    companyName?: string | null
    description1: string
    description2?: string | null
    imageSrc: string
    imagePublicId?: string | null
    liveLink?: string | null
    sourceLink?: string | null
    layout?: string
    order?: number
    categoryIds?: ProjectItemCreatecategoryIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectItemUncheckedCreateWithoutSectionInput = {
    id?: string
    projectNumber?: string | null
    title: string
    companyName?: string | null
    description1: string
    description2?: string | null
    imageSrc: string
    imagePublicId?: string | null
    liveLink?: string | null
    sourceLink?: string | null
    layout?: string
    order?: number
    categoryIds?: ProjectItemCreatecategoryIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectItemCreateOrConnectWithoutSectionInput = {
    where: ProjectItemWhereUniqueInput
    create: XOR<ProjectItemCreateWithoutSectionInput, ProjectItemUncheckedCreateWithoutSectionInput>
  }

  export type ProjectItemCreateManySectionInputEnvelope = {
    data: ProjectItemCreateManySectionInput | ProjectItemCreateManySectionInput[]
  }

  export type TestimonialItemCreateWithoutSectionInput = {
    id?: string
    clientName: string
    role?: string | null
    company?: string | null
    content: string
    rating: number
    imageSrc?: string | null
    imagePublicId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialItemUncheckedCreateWithoutSectionInput = {
    id?: string
    clientName: string
    role?: string | null
    company?: string | null
    content: string
    rating: number
    imageSrc?: string | null
    imagePublicId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialItemCreateOrConnectWithoutSectionInput = {
    where: TestimonialItemWhereUniqueInput
    create: XOR<TestimonialItemCreateWithoutSectionInput, TestimonialItemUncheckedCreateWithoutSectionInput>
  }

  export type TestimonialItemCreateManySectionInputEnvelope = {
    data: TestimonialItemCreateManySectionInput | TestimonialItemCreateManySectionInput[]
  }

  export type ContactInfoItemCreateWithoutSectionInput = {
    id?: string
    type: string
    value: string
    label?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactInfoItemUncheckedCreateWithoutSectionInput = {
    id?: string
    type: string
    value: string
    label?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactInfoItemCreateOrConnectWithoutSectionInput = {
    where: ContactInfoItemWhereUniqueInput
    create: XOR<ContactInfoItemCreateWithoutSectionInput, ContactInfoItemUncheckedCreateWithoutSectionInput>
  }

  export type ContactInfoItemCreateManySectionInputEnvelope = {
    data: ContactInfoItemCreateManySectionInput | ContactInfoItemCreateManySectionInput[]
  }

  export type CustomSectionContentBlockCreateWithoutSectionInput = {
    id?: string
    type: string
    content?: string | null
    imageSrc?: string | null
    imageAlt?: string | null
    linkUrl?: string | null
    imagePublicId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomSectionContentBlockUncheckedCreateWithoutSectionInput = {
    id?: string
    type: string
    content?: string | null
    imageSrc?: string | null
    imageAlt?: string | null
    linkUrl?: string | null
    imagePublicId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomSectionContentBlockCreateOrConnectWithoutSectionInput = {
    where: CustomSectionContentBlockWhereUniqueInput
    create: XOR<CustomSectionContentBlockCreateWithoutSectionInput, CustomSectionContentBlockUncheckedCreateWithoutSectionInput>
  }

  export type CustomSectionContentBlockCreateManySectionInputEnvelope = {
    data: CustomSectionContentBlockCreateManySectionInput | CustomSectionContentBlockCreateManySectionInput[]
  }

  export type TextBlockUpsertWithWhereUniqueWithoutSectionInput = {
    where: TextBlockWhereUniqueInput
    update: XOR<TextBlockUpdateWithoutSectionInput, TextBlockUncheckedUpdateWithoutSectionInput>
    create: XOR<TextBlockCreateWithoutSectionInput, TextBlockUncheckedCreateWithoutSectionInput>
  }

  export type TextBlockUpdateWithWhereUniqueWithoutSectionInput = {
    where: TextBlockWhereUniqueInput
    data: XOR<TextBlockUpdateWithoutSectionInput, TextBlockUncheckedUpdateWithoutSectionInput>
  }

  export type TextBlockUpdateManyWithWhereWithoutSectionInput = {
    where: TextBlockScalarWhereInput
    data: XOR<TextBlockUpdateManyMutationInput, TextBlockUncheckedUpdateManyWithoutSectionInput>
  }

  export type TextBlockScalarWhereInput = {
    AND?: TextBlockScalarWhereInput | TextBlockScalarWhereInput[]
    OR?: TextBlockScalarWhereInput[]
    NOT?: TextBlockScalarWhereInput | TextBlockScalarWhereInput[]
    id?: StringFilter<"TextBlock"> | string
    content?: StringFilter<"TextBlock"> | string
    order?: IntFilter<"TextBlock"> | number
    sectionId?: StringFilter<"TextBlock"> | string
    fontSize?: IntNullableFilter<"TextBlock"> | number | null
    fontFamily?: StringNullableFilter<"TextBlock"> | string | null
    createdAt?: DateTimeFilter<"TextBlock"> | Date | string
    updatedAt?: DateTimeFilter<"TextBlock"> | Date | string
  }

  export type ImageBlockUpsertWithWhereUniqueWithoutSectionInput = {
    where: ImageBlockWhereUniqueInput
    update: XOR<ImageBlockUpdateWithoutSectionInput, ImageBlockUncheckedUpdateWithoutSectionInput>
    create: XOR<ImageBlockCreateWithoutSectionInput, ImageBlockUncheckedCreateWithoutSectionInput>
  }

  export type ImageBlockUpdateWithWhereUniqueWithoutSectionInput = {
    where: ImageBlockWhereUniqueInput
    data: XOR<ImageBlockUpdateWithoutSectionInput, ImageBlockUncheckedUpdateWithoutSectionInput>
  }

  export type ImageBlockUpdateManyWithWhereWithoutSectionInput = {
    where: ImageBlockScalarWhereInput
    data: XOR<ImageBlockUpdateManyMutationInput, ImageBlockUncheckedUpdateManyWithoutSectionInput>
  }

  export type ImageBlockScalarWhereInput = {
    AND?: ImageBlockScalarWhereInput | ImageBlockScalarWhereInput[]
    OR?: ImageBlockScalarWhereInput[]
    NOT?: ImageBlockScalarWhereInput | ImageBlockScalarWhereInput[]
    id?: StringFilter<"ImageBlock"> | string
    src?: StringFilter<"ImageBlock"> | string
    alt?: StringNullableFilter<"ImageBlock"> | string | null
    caption?: StringNullableFilter<"ImageBlock"> | string | null
    imagePublicId?: StringNullableFilter<"ImageBlock"> | string | null
    order?: IntFilter<"ImageBlock"> | number
    sectionId?: StringFilter<"ImageBlock"> | string
    createdAt?: DateTimeFilter<"ImageBlock"> | Date | string
    updatedAt?: DateTimeFilter<"ImageBlock"> | Date | string
  }

  export type HeroSectionContentUpsertWithoutSectionInput = {
    update: XOR<HeroSectionContentUpdateWithoutSectionInput, HeroSectionContentUncheckedUpdateWithoutSectionInput>
    create: XOR<HeroSectionContentCreateWithoutSectionInput, HeroSectionContentUncheckedCreateWithoutSectionInput>
    where?: HeroSectionContentWhereInput
  }

  export type HeroSectionContentUpdateToOneWithWhereWithoutSectionInput = {
    where?: HeroSectionContentWhereInput
    data: XOR<HeroSectionContentUpdateWithoutSectionInput, HeroSectionContentUncheckedUpdateWithoutSectionInput>
  }

  export type HeroSectionContentUpdateWithoutSectionInput = {
    portraitImageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    portraitImagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    portraitAlt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroSectionContentUncheckedUpdateWithoutSectionInput = {
    portraitImageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    portraitImagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    portraitAlt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationItemUpsertWithWhereUniqueWithoutSectionInput = {
    where: EducationItemWhereUniqueInput
    update: XOR<EducationItemUpdateWithoutSectionInput, EducationItemUncheckedUpdateWithoutSectionInput>
    create: XOR<EducationItemCreateWithoutSectionInput, EducationItemUncheckedCreateWithoutSectionInput>
  }

  export type EducationItemUpdateWithWhereUniqueWithoutSectionInput = {
    where: EducationItemWhereUniqueInput
    data: XOR<EducationItemUpdateWithoutSectionInput, EducationItemUncheckedUpdateWithoutSectionInput>
  }

  export type EducationItemUpdateManyWithWhereWithoutSectionInput = {
    where: EducationItemScalarWhereInput
    data: XOR<EducationItemUpdateManyMutationInput, EducationItemUncheckedUpdateManyWithoutSectionInput>
  }

  export type EducationItemScalarWhereInput = {
    AND?: EducationItemScalarWhereInput | EducationItemScalarWhereInput[]
    OR?: EducationItemScalarWhereInput[]
    NOT?: EducationItemScalarWhereInput | EducationItemScalarWhereInput[]
    id?: StringFilter<"EducationItem"> | string
    institution?: StringFilter<"EducationItem"> | string
    degree?: StringNullableFilter<"EducationItem"> | string | null
    period?: StringFilter<"EducationItem"> | string
    description?: StringNullableFilter<"EducationItem"> | string | null
    order?: IntFilter<"EducationItem"> | number
    sectionId?: StringFilter<"EducationItem"> | string
    createdAt?: DateTimeFilter<"EducationItem"> | Date | string
    updatedAt?: DateTimeFilter<"EducationItem"> | Date | string
  }

  export type SkillItemUpsertWithWhereUniqueWithoutSectionInput = {
    where: SkillItemWhereUniqueInput
    update: XOR<SkillItemUpdateWithoutSectionInput, SkillItemUncheckedUpdateWithoutSectionInput>
    create: XOR<SkillItemCreateWithoutSectionInput, SkillItemUncheckedCreateWithoutSectionInput>
  }

  export type SkillItemUpdateWithWhereUniqueWithoutSectionInput = {
    where: SkillItemWhereUniqueInput
    data: XOR<SkillItemUpdateWithoutSectionInput, SkillItemUncheckedUpdateWithoutSectionInput>
  }

  export type SkillItemUpdateManyWithWhereWithoutSectionInput = {
    where: SkillItemScalarWhereInput
    data: XOR<SkillItemUpdateManyMutationInput, SkillItemUncheckedUpdateManyWithoutSectionInput>
  }

  export type SkillItemScalarWhereInput = {
    AND?: SkillItemScalarWhereInput | SkillItemScalarWhereInput[]
    OR?: SkillItemScalarWhereInput[]
    NOT?: SkillItemScalarWhereInput | SkillItemScalarWhereInput[]
    id?: StringFilter<"SkillItem"> | string
    title?: StringFilter<"SkillItem"> | string
    description?: StringNullableFilter<"SkillItem"> | string | null
    level?: IntNullableFilter<"SkillItem"> | number | null
    order?: IntFilter<"SkillItem"> | number
    sectionId?: StringFilter<"SkillItem"> | string
    createdAt?: DateTimeFilter<"SkillItem"> | Date | string
    updatedAt?: DateTimeFilter<"SkillItem"> | Date | string
  }

  export type SkillImageUpsertWithWhereUniqueWithoutSectionInput = {
    where: SkillImageWhereUniqueInput
    update: XOR<SkillImageUpdateWithoutSectionInput, SkillImageUncheckedUpdateWithoutSectionInput>
    create: XOR<SkillImageCreateWithoutSectionInput, SkillImageUncheckedCreateWithoutSectionInput>
  }

  export type SkillImageUpdateWithWhereUniqueWithoutSectionInput = {
    where: SkillImageWhereUniqueInput
    data: XOR<SkillImageUpdateWithoutSectionInput, SkillImageUncheckedUpdateWithoutSectionInput>
  }

  export type SkillImageUpdateManyWithWhereWithoutSectionInput = {
    where: SkillImageScalarWhereInput
    data: XOR<SkillImageUpdateManyMutationInput, SkillImageUncheckedUpdateManyWithoutSectionInput>
  }

  export type SkillImageScalarWhereInput = {
    AND?: SkillImageScalarWhereInput | SkillImageScalarWhereInput[]
    OR?: SkillImageScalarWhereInput[]
    NOT?: SkillImageScalarWhereInput | SkillImageScalarWhereInput[]
    id?: StringFilter<"SkillImage"> | string
    src?: StringFilter<"SkillImage"> | string
    imagePublicId?: StringNullableFilter<"SkillImage"> | string | null
    alt?: StringNullableFilter<"SkillImage"> | string | null
    caption?: StringNullableFilter<"SkillImage"> | string | null
    order?: IntFilter<"SkillImage"> | number
    sectionId?: StringFilter<"SkillImage"> | string
    createdAt?: DateTimeFilter<"SkillImage"> | Date | string
  }

  export type ExperienceItemUpsertWithWhereUniqueWithoutSectionInput = {
    where: ExperienceItemWhereUniqueInput
    update: XOR<ExperienceItemUpdateWithoutSectionInput, ExperienceItemUncheckedUpdateWithoutSectionInput>
    create: XOR<ExperienceItemCreateWithoutSectionInput, ExperienceItemUncheckedCreateWithoutSectionInput>
  }

  export type ExperienceItemUpdateWithWhereUniqueWithoutSectionInput = {
    where: ExperienceItemWhereUniqueInput
    data: XOR<ExperienceItemUpdateWithoutSectionInput, ExperienceItemUncheckedUpdateWithoutSectionInput>
  }

  export type ExperienceItemUpdateManyWithWhereWithoutSectionInput = {
    where: ExperienceItemScalarWhereInput
    data: XOR<ExperienceItemUpdateManyMutationInput, ExperienceItemUncheckedUpdateManyWithoutSectionInput>
  }

  export type ExperienceItemScalarWhereInput = {
    AND?: ExperienceItemScalarWhereInput | ExperienceItemScalarWhereInput[]
    OR?: ExperienceItemScalarWhereInput[]
    NOT?: ExperienceItemScalarWhereInput | ExperienceItemScalarWhereInput[]
    id?: StringFilter<"ExperienceItem"> | string
    positionTitle?: StringFilter<"ExperienceItem"> | string
    companyName?: StringFilter<"ExperienceItem"> | string
    period?: StringFilter<"ExperienceItem"> | string
    summary?: StringNullableFilter<"ExperienceItem"> | string | null
    description?: StringNullableFilter<"ExperienceItem"> | string | null
    imageSrc?: StringFilter<"ExperienceItem"> | string
    imagePublicId?: StringNullableFilter<"ExperienceItem"> | string | null
    order?: IntFilter<"ExperienceItem"> | number
    sectionId?: StringFilter<"ExperienceItem"> | string
    createdAt?: DateTimeFilter<"ExperienceItem"> | Date | string
    updatedAt?: DateTimeFilter<"ExperienceItem"> | Date | string
  }

  export type ProjectItemUpsertWithWhereUniqueWithoutSectionInput = {
    where: ProjectItemWhereUniqueInput
    update: XOR<ProjectItemUpdateWithoutSectionInput, ProjectItemUncheckedUpdateWithoutSectionInput>
    create: XOR<ProjectItemCreateWithoutSectionInput, ProjectItemUncheckedCreateWithoutSectionInput>
  }

  export type ProjectItemUpdateWithWhereUniqueWithoutSectionInput = {
    where: ProjectItemWhereUniqueInput
    data: XOR<ProjectItemUpdateWithoutSectionInput, ProjectItemUncheckedUpdateWithoutSectionInput>
  }

  export type ProjectItemUpdateManyWithWhereWithoutSectionInput = {
    where: ProjectItemScalarWhereInput
    data: XOR<ProjectItemUpdateManyMutationInput, ProjectItemUncheckedUpdateManyWithoutSectionInput>
  }

  export type ProjectItemScalarWhereInput = {
    AND?: ProjectItemScalarWhereInput | ProjectItemScalarWhereInput[]
    OR?: ProjectItemScalarWhereInput[]
    NOT?: ProjectItemScalarWhereInput | ProjectItemScalarWhereInput[]
    id?: StringFilter<"ProjectItem"> | string
    projectNumber?: StringNullableFilter<"ProjectItem"> | string | null
    title?: StringFilter<"ProjectItem"> | string
    companyName?: StringNullableFilter<"ProjectItem"> | string | null
    description1?: StringFilter<"ProjectItem"> | string
    description2?: StringNullableFilter<"ProjectItem"> | string | null
    imageSrc?: StringFilter<"ProjectItem"> | string
    imagePublicId?: StringNullableFilter<"ProjectItem"> | string | null
    liveLink?: StringNullableFilter<"ProjectItem"> | string | null
    sourceLink?: StringNullableFilter<"ProjectItem"> | string | null
    layout?: StringFilter<"ProjectItem"> | string
    order?: IntFilter<"ProjectItem"> | number
    sectionId?: StringFilter<"ProjectItem"> | string
    categoryIds?: StringNullableListFilter<"ProjectItem">
    createdAt?: DateTimeFilter<"ProjectItem"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectItem"> | Date | string
  }

  export type TestimonialItemUpsertWithWhereUniqueWithoutSectionInput = {
    where: TestimonialItemWhereUniqueInput
    update: XOR<TestimonialItemUpdateWithoutSectionInput, TestimonialItemUncheckedUpdateWithoutSectionInput>
    create: XOR<TestimonialItemCreateWithoutSectionInput, TestimonialItemUncheckedCreateWithoutSectionInput>
  }

  export type TestimonialItemUpdateWithWhereUniqueWithoutSectionInput = {
    where: TestimonialItemWhereUniqueInput
    data: XOR<TestimonialItemUpdateWithoutSectionInput, TestimonialItemUncheckedUpdateWithoutSectionInput>
  }

  export type TestimonialItemUpdateManyWithWhereWithoutSectionInput = {
    where: TestimonialItemScalarWhereInput
    data: XOR<TestimonialItemUpdateManyMutationInput, TestimonialItemUncheckedUpdateManyWithoutSectionInput>
  }

  export type TestimonialItemScalarWhereInput = {
    AND?: TestimonialItemScalarWhereInput | TestimonialItemScalarWhereInput[]
    OR?: TestimonialItemScalarWhereInput[]
    NOT?: TestimonialItemScalarWhereInput | TestimonialItemScalarWhereInput[]
    id?: StringFilter<"TestimonialItem"> | string
    clientName?: StringFilter<"TestimonialItem"> | string
    role?: StringNullableFilter<"TestimonialItem"> | string | null
    company?: StringNullableFilter<"TestimonialItem"> | string | null
    content?: StringFilter<"TestimonialItem"> | string
    rating?: FloatFilter<"TestimonialItem"> | number
    imageSrc?: StringNullableFilter<"TestimonialItem"> | string | null
    imagePublicId?: StringNullableFilter<"TestimonialItem"> | string | null
    order?: IntFilter<"TestimonialItem"> | number
    sectionId?: StringFilter<"TestimonialItem"> | string
    createdAt?: DateTimeFilter<"TestimonialItem"> | Date | string
    updatedAt?: DateTimeFilter<"TestimonialItem"> | Date | string
  }

  export type ContactInfoItemUpsertWithWhereUniqueWithoutSectionInput = {
    where: ContactInfoItemWhereUniqueInput
    update: XOR<ContactInfoItemUpdateWithoutSectionInput, ContactInfoItemUncheckedUpdateWithoutSectionInput>
    create: XOR<ContactInfoItemCreateWithoutSectionInput, ContactInfoItemUncheckedCreateWithoutSectionInput>
  }

  export type ContactInfoItemUpdateWithWhereUniqueWithoutSectionInput = {
    where: ContactInfoItemWhereUniqueInput
    data: XOR<ContactInfoItemUpdateWithoutSectionInput, ContactInfoItemUncheckedUpdateWithoutSectionInput>
  }

  export type ContactInfoItemUpdateManyWithWhereWithoutSectionInput = {
    where: ContactInfoItemScalarWhereInput
    data: XOR<ContactInfoItemUpdateManyMutationInput, ContactInfoItemUncheckedUpdateManyWithoutSectionInput>
  }

  export type ContactInfoItemScalarWhereInput = {
    AND?: ContactInfoItemScalarWhereInput | ContactInfoItemScalarWhereInput[]
    OR?: ContactInfoItemScalarWhereInput[]
    NOT?: ContactInfoItemScalarWhereInput | ContactInfoItemScalarWhereInput[]
    id?: StringFilter<"ContactInfoItem"> | string
    type?: StringFilter<"ContactInfoItem"> | string
    value?: StringFilter<"ContactInfoItem"> | string
    label?: StringNullableFilter<"ContactInfoItem"> | string | null
    icon?: StringNullableFilter<"ContactInfoItem"> | string | null
    order?: IntFilter<"ContactInfoItem"> | number
    sectionId?: StringFilter<"ContactInfoItem"> | string
    createdAt?: DateTimeFilter<"ContactInfoItem"> | Date | string
    updatedAt?: DateTimeFilter<"ContactInfoItem"> | Date | string
  }

  export type CustomSectionContentBlockUpsertWithWhereUniqueWithoutSectionInput = {
    where: CustomSectionContentBlockWhereUniqueInput
    update: XOR<CustomSectionContentBlockUpdateWithoutSectionInput, CustomSectionContentBlockUncheckedUpdateWithoutSectionInput>
    create: XOR<CustomSectionContentBlockCreateWithoutSectionInput, CustomSectionContentBlockUncheckedCreateWithoutSectionInput>
  }

  export type CustomSectionContentBlockUpdateWithWhereUniqueWithoutSectionInput = {
    where: CustomSectionContentBlockWhereUniqueInput
    data: XOR<CustomSectionContentBlockUpdateWithoutSectionInput, CustomSectionContentBlockUncheckedUpdateWithoutSectionInput>
  }

  export type CustomSectionContentBlockUpdateManyWithWhereWithoutSectionInput = {
    where: CustomSectionContentBlockScalarWhereInput
    data: XOR<CustomSectionContentBlockUpdateManyMutationInput, CustomSectionContentBlockUncheckedUpdateManyWithoutSectionInput>
  }

  export type CustomSectionContentBlockScalarWhereInput = {
    AND?: CustomSectionContentBlockScalarWhereInput | CustomSectionContentBlockScalarWhereInput[]
    OR?: CustomSectionContentBlockScalarWhereInput[]
    NOT?: CustomSectionContentBlockScalarWhereInput | CustomSectionContentBlockScalarWhereInput[]
    id?: StringFilter<"CustomSectionContentBlock"> | string
    type?: StringFilter<"CustomSectionContentBlock"> | string
    content?: StringNullableFilter<"CustomSectionContentBlock"> | string | null
    imageSrc?: StringNullableFilter<"CustomSectionContentBlock"> | string | null
    imageAlt?: StringNullableFilter<"CustomSectionContentBlock"> | string | null
    linkUrl?: StringNullableFilter<"CustomSectionContentBlock"> | string | null
    imagePublicId?: StringNullableFilter<"CustomSectionContentBlock"> | string | null
    order?: IntFilter<"CustomSectionContentBlock"> | number
    sectionId?: StringFilter<"CustomSectionContentBlock"> | string
    createdAt?: DateTimeFilter<"CustomSectionContentBlock"> | Date | string
    updatedAt?: DateTimeFilter<"CustomSectionContentBlock"> | Date | string
  }

  export type SectionCreateWithoutTextBlocksInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageBlocks?: ImageBlockCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentCreateNestedOneWithoutSectionInput
    educationItems?: EducationItemCreateNestedManyWithoutSectionInput
    skillItems?: SkillItemCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutTextBlocksInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageBlocks?: ImageBlockUncheckedCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentUncheckedCreateNestedOneWithoutSectionInput
    educationItems?: EducationItemUncheckedCreateNestedManyWithoutSectionInput
    skillItems?: SkillItemUncheckedCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageUncheckedCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemUncheckedCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemUncheckedCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemUncheckedCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemUncheckedCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutTextBlocksInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutTextBlocksInput, SectionUncheckedCreateWithoutTextBlocksInput>
  }

  export type SectionUpsertWithoutTextBlocksInput = {
    update: XOR<SectionUpdateWithoutTextBlocksInput, SectionUncheckedUpdateWithoutTextBlocksInput>
    create: XOR<SectionCreateWithoutTextBlocksInput, SectionUncheckedCreateWithoutTextBlocksInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutTextBlocksInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutTextBlocksInput, SectionUncheckedUpdateWithoutTextBlocksInput>
  }

  export type SectionUpdateWithoutTextBlocksInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageBlocks?: ImageBlockUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUpdateOneWithoutSectionNestedInput
    educationItems?: EducationItemUpdateManyWithoutSectionNestedInput
    skillItems?: SkillItemUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutTextBlocksInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageBlocks?: ImageBlockUncheckedUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUncheckedUpdateOneWithoutSectionNestedInput
    educationItems?: EducationItemUncheckedUpdateManyWithoutSectionNestedInput
    skillItems?: SkillItemUncheckedUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUncheckedUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUncheckedUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUncheckedUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUncheckedUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUncheckedUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionCreateWithoutImageBlocksInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentCreateNestedOneWithoutSectionInput
    educationItems?: EducationItemCreateNestedManyWithoutSectionInput
    skillItems?: SkillItemCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutImageBlocksInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockUncheckedCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentUncheckedCreateNestedOneWithoutSectionInput
    educationItems?: EducationItemUncheckedCreateNestedManyWithoutSectionInput
    skillItems?: SkillItemUncheckedCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageUncheckedCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemUncheckedCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemUncheckedCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemUncheckedCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemUncheckedCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutImageBlocksInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutImageBlocksInput, SectionUncheckedCreateWithoutImageBlocksInput>
  }

  export type SectionUpsertWithoutImageBlocksInput = {
    update: XOR<SectionUpdateWithoutImageBlocksInput, SectionUncheckedUpdateWithoutImageBlocksInput>
    create: XOR<SectionCreateWithoutImageBlocksInput, SectionUncheckedCreateWithoutImageBlocksInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutImageBlocksInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutImageBlocksInput, SectionUncheckedUpdateWithoutImageBlocksInput>
  }

  export type SectionUpdateWithoutImageBlocksInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUpdateOneWithoutSectionNestedInput
    educationItems?: EducationItemUpdateManyWithoutSectionNestedInput
    skillItems?: SkillItemUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutImageBlocksInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUncheckedUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUncheckedUpdateOneWithoutSectionNestedInput
    educationItems?: EducationItemUncheckedUpdateManyWithoutSectionNestedInput
    skillItems?: SkillItemUncheckedUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUncheckedUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUncheckedUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUncheckedUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUncheckedUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUncheckedUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionCreateWithoutHeroContentInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockCreateNestedManyWithoutSectionInput
    imageBlocks?: ImageBlockCreateNestedManyWithoutSectionInput
    educationItems?: EducationItemCreateNestedManyWithoutSectionInput
    skillItems?: SkillItemCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutHeroContentInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockUncheckedCreateNestedManyWithoutSectionInput
    imageBlocks?: ImageBlockUncheckedCreateNestedManyWithoutSectionInput
    educationItems?: EducationItemUncheckedCreateNestedManyWithoutSectionInput
    skillItems?: SkillItemUncheckedCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageUncheckedCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemUncheckedCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemUncheckedCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemUncheckedCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemUncheckedCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutHeroContentInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutHeroContentInput, SectionUncheckedCreateWithoutHeroContentInput>
  }

  export type SectionUpsertWithoutHeroContentInput = {
    update: XOR<SectionUpdateWithoutHeroContentInput, SectionUncheckedUpdateWithoutHeroContentInput>
    create: XOR<SectionCreateWithoutHeroContentInput, SectionUncheckedCreateWithoutHeroContentInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutHeroContentInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutHeroContentInput, SectionUncheckedUpdateWithoutHeroContentInput>
  }

  export type SectionUpdateWithoutHeroContentInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUpdateManyWithoutSectionNestedInput
    imageBlocks?: ImageBlockUpdateManyWithoutSectionNestedInput
    educationItems?: EducationItemUpdateManyWithoutSectionNestedInput
    skillItems?: SkillItemUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutHeroContentInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUncheckedUpdateManyWithoutSectionNestedInput
    imageBlocks?: ImageBlockUncheckedUpdateManyWithoutSectionNestedInput
    educationItems?: EducationItemUncheckedUpdateManyWithoutSectionNestedInput
    skillItems?: SkillItemUncheckedUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUncheckedUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUncheckedUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUncheckedUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUncheckedUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUncheckedUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionCreateWithoutEducationItemsInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockCreateNestedManyWithoutSectionInput
    imageBlocks?: ImageBlockCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentCreateNestedOneWithoutSectionInput
    skillItems?: SkillItemCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutEducationItemsInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockUncheckedCreateNestedManyWithoutSectionInput
    imageBlocks?: ImageBlockUncheckedCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentUncheckedCreateNestedOneWithoutSectionInput
    skillItems?: SkillItemUncheckedCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageUncheckedCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemUncheckedCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemUncheckedCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemUncheckedCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemUncheckedCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutEducationItemsInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutEducationItemsInput, SectionUncheckedCreateWithoutEducationItemsInput>
  }

  export type EducationImageCreateWithoutEducationItemInput = {
    id?: string
    src: string
    imagePublicId?: string | null
    alt?: string | null
    caption?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type EducationImageUncheckedCreateWithoutEducationItemInput = {
    id?: string
    src: string
    imagePublicId?: string | null
    alt?: string | null
    caption?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type EducationImageCreateOrConnectWithoutEducationItemInput = {
    where: EducationImageWhereUniqueInput
    create: XOR<EducationImageCreateWithoutEducationItemInput, EducationImageUncheckedCreateWithoutEducationItemInput>
  }

  export type EducationImageCreateManyEducationItemInputEnvelope = {
    data: EducationImageCreateManyEducationItemInput | EducationImageCreateManyEducationItemInput[]
  }

  export type SectionUpsertWithoutEducationItemsInput = {
    update: XOR<SectionUpdateWithoutEducationItemsInput, SectionUncheckedUpdateWithoutEducationItemsInput>
    create: XOR<SectionCreateWithoutEducationItemsInput, SectionUncheckedCreateWithoutEducationItemsInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutEducationItemsInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutEducationItemsInput, SectionUncheckedUpdateWithoutEducationItemsInput>
  }

  export type SectionUpdateWithoutEducationItemsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUpdateManyWithoutSectionNestedInput
    imageBlocks?: ImageBlockUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUpdateOneWithoutSectionNestedInput
    skillItems?: SkillItemUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutEducationItemsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUncheckedUpdateManyWithoutSectionNestedInput
    imageBlocks?: ImageBlockUncheckedUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUncheckedUpdateOneWithoutSectionNestedInput
    skillItems?: SkillItemUncheckedUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUncheckedUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUncheckedUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUncheckedUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUncheckedUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUncheckedUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type EducationImageUpsertWithWhereUniqueWithoutEducationItemInput = {
    where: EducationImageWhereUniqueInput
    update: XOR<EducationImageUpdateWithoutEducationItemInput, EducationImageUncheckedUpdateWithoutEducationItemInput>
    create: XOR<EducationImageCreateWithoutEducationItemInput, EducationImageUncheckedCreateWithoutEducationItemInput>
  }

  export type EducationImageUpdateWithWhereUniqueWithoutEducationItemInput = {
    where: EducationImageWhereUniqueInput
    data: XOR<EducationImageUpdateWithoutEducationItemInput, EducationImageUncheckedUpdateWithoutEducationItemInput>
  }

  export type EducationImageUpdateManyWithWhereWithoutEducationItemInput = {
    where: EducationImageScalarWhereInput
    data: XOR<EducationImageUpdateManyMutationInput, EducationImageUncheckedUpdateManyWithoutEducationItemInput>
  }

  export type EducationImageScalarWhereInput = {
    AND?: EducationImageScalarWhereInput | EducationImageScalarWhereInput[]
    OR?: EducationImageScalarWhereInput[]
    NOT?: EducationImageScalarWhereInput | EducationImageScalarWhereInput[]
    id?: StringFilter<"EducationImage"> | string
    src?: StringFilter<"EducationImage"> | string
    imagePublicId?: StringNullableFilter<"EducationImage"> | string | null
    alt?: StringNullableFilter<"EducationImage"> | string | null
    caption?: StringNullableFilter<"EducationImage"> | string | null
    order?: IntFilter<"EducationImage"> | number
    educationItemId?: StringFilter<"EducationImage"> | string
    createdAt?: DateTimeFilter<"EducationImage"> | Date | string
  }

  export type EducationItemCreateWithoutImagesInput = {
    id?: string
    institution: string
    degree?: string | null
    period: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    section: SectionCreateNestedOneWithoutEducationItemsInput
  }

  export type EducationItemUncheckedCreateWithoutImagesInput = {
    id?: string
    institution: string
    degree?: string | null
    period: string
    description?: string | null
    order?: number
    sectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EducationItemCreateOrConnectWithoutImagesInput = {
    where: EducationItemWhereUniqueInput
    create: XOR<EducationItemCreateWithoutImagesInput, EducationItemUncheckedCreateWithoutImagesInput>
  }

  export type EducationItemUpsertWithoutImagesInput = {
    update: XOR<EducationItemUpdateWithoutImagesInput, EducationItemUncheckedUpdateWithoutImagesInput>
    create: XOR<EducationItemCreateWithoutImagesInput, EducationItemUncheckedCreateWithoutImagesInput>
    where?: EducationItemWhereInput
  }

  export type EducationItemUpdateToOneWithWhereWithoutImagesInput = {
    where?: EducationItemWhereInput
    data: XOR<EducationItemUpdateWithoutImagesInput, EducationItemUncheckedUpdateWithoutImagesInput>
  }

  export type EducationItemUpdateWithoutImagesInput = {
    institution?: StringFieldUpdateOperationsInput | string
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneRequiredWithoutEducationItemsNestedInput
  }

  export type EducationItemUncheckedUpdateWithoutImagesInput = {
    institution?: StringFieldUpdateOperationsInput | string
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionCreateWithoutSkillItemsInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockCreateNestedManyWithoutSectionInput
    imageBlocks?: ImageBlockCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentCreateNestedOneWithoutSectionInput
    educationItems?: EducationItemCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutSkillItemsInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockUncheckedCreateNestedManyWithoutSectionInput
    imageBlocks?: ImageBlockUncheckedCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentUncheckedCreateNestedOneWithoutSectionInput
    educationItems?: EducationItemUncheckedCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageUncheckedCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemUncheckedCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemUncheckedCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemUncheckedCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemUncheckedCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutSkillItemsInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutSkillItemsInput, SectionUncheckedCreateWithoutSkillItemsInput>
  }

  export type SectionUpsertWithoutSkillItemsInput = {
    update: XOR<SectionUpdateWithoutSkillItemsInput, SectionUncheckedUpdateWithoutSkillItemsInput>
    create: XOR<SectionCreateWithoutSkillItemsInput, SectionUncheckedCreateWithoutSkillItemsInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutSkillItemsInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutSkillItemsInput, SectionUncheckedUpdateWithoutSkillItemsInput>
  }

  export type SectionUpdateWithoutSkillItemsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUpdateManyWithoutSectionNestedInput
    imageBlocks?: ImageBlockUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUpdateOneWithoutSectionNestedInput
    educationItems?: EducationItemUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutSkillItemsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUncheckedUpdateManyWithoutSectionNestedInput
    imageBlocks?: ImageBlockUncheckedUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUncheckedUpdateOneWithoutSectionNestedInput
    educationItems?: EducationItemUncheckedUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUncheckedUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUncheckedUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUncheckedUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUncheckedUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUncheckedUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionCreateWithoutSkillImagesInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockCreateNestedManyWithoutSectionInput
    imageBlocks?: ImageBlockCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentCreateNestedOneWithoutSectionInput
    educationItems?: EducationItemCreateNestedManyWithoutSectionInput
    skillItems?: SkillItemCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutSkillImagesInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockUncheckedCreateNestedManyWithoutSectionInput
    imageBlocks?: ImageBlockUncheckedCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentUncheckedCreateNestedOneWithoutSectionInput
    educationItems?: EducationItemUncheckedCreateNestedManyWithoutSectionInput
    skillItems?: SkillItemUncheckedCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemUncheckedCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemUncheckedCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemUncheckedCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemUncheckedCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutSkillImagesInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutSkillImagesInput, SectionUncheckedCreateWithoutSkillImagesInput>
  }

  export type SectionUpsertWithoutSkillImagesInput = {
    update: XOR<SectionUpdateWithoutSkillImagesInput, SectionUncheckedUpdateWithoutSkillImagesInput>
    create: XOR<SectionCreateWithoutSkillImagesInput, SectionUncheckedCreateWithoutSkillImagesInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutSkillImagesInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutSkillImagesInput, SectionUncheckedUpdateWithoutSkillImagesInput>
  }

  export type SectionUpdateWithoutSkillImagesInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUpdateManyWithoutSectionNestedInput
    imageBlocks?: ImageBlockUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUpdateOneWithoutSectionNestedInput
    educationItems?: EducationItemUpdateManyWithoutSectionNestedInput
    skillItems?: SkillItemUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutSkillImagesInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUncheckedUpdateManyWithoutSectionNestedInput
    imageBlocks?: ImageBlockUncheckedUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUncheckedUpdateOneWithoutSectionNestedInput
    educationItems?: EducationItemUncheckedUpdateManyWithoutSectionNestedInput
    skillItems?: SkillItemUncheckedUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUncheckedUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUncheckedUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUncheckedUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUncheckedUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionCreateWithoutExperienceItemsInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockCreateNestedManyWithoutSectionInput
    imageBlocks?: ImageBlockCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentCreateNestedOneWithoutSectionInput
    educationItems?: EducationItemCreateNestedManyWithoutSectionInput
    skillItems?: SkillItemCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutExperienceItemsInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockUncheckedCreateNestedManyWithoutSectionInput
    imageBlocks?: ImageBlockUncheckedCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentUncheckedCreateNestedOneWithoutSectionInput
    educationItems?: EducationItemUncheckedCreateNestedManyWithoutSectionInput
    skillItems?: SkillItemUncheckedCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageUncheckedCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemUncheckedCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemUncheckedCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemUncheckedCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutExperienceItemsInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutExperienceItemsInput, SectionUncheckedCreateWithoutExperienceItemsInput>
  }

  export type ExperienceDetailImageCreateWithoutExperienceItemInput = {
    id?: string
    src: string
    imagePublicId?: string | null
    alt?: string | null
    caption?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type ExperienceDetailImageUncheckedCreateWithoutExperienceItemInput = {
    id?: string
    src: string
    imagePublicId?: string | null
    alt?: string | null
    caption?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type ExperienceDetailImageCreateOrConnectWithoutExperienceItemInput = {
    where: ExperienceDetailImageWhereUniqueInput
    create: XOR<ExperienceDetailImageCreateWithoutExperienceItemInput, ExperienceDetailImageUncheckedCreateWithoutExperienceItemInput>
  }

  export type ExperienceDetailImageCreateManyExperienceItemInputEnvelope = {
    data: ExperienceDetailImageCreateManyExperienceItemInput | ExperienceDetailImageCreateManyExperienceItemInput[]
  }

  export type SectionUpsertWithoutExperienceItemsInput = {
    update: XOR<SectionUpdateWithoutExperienceItemsInput, SectionUncheckedUpdateWithoutExperienceItemsInput>
    create: XOR<SectionCreateWithoutExperienceItemsInput, SectionUncheckedCreateWithoutExperienceItemsInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutExperienceItemsInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutExperienceItemsInput, SectionUncheckedUpdateWithoutExperienceItemsInput>
  }

  export type SectionUpdateWithoutExperienceItemsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUpdateManyWithoutSectionNestedInput
    imageBlocks?: ImageBlockUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUpdateOneWithoutSectionNestedInput
    educationItems?: EducationItemUpdateManyWithoutSectionNestedInput
    skillItems?: SkillItemUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutExperienceItemsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUncheckedUpdateManyWithoutSectionNestedInput
    imageBlocks?: ImageBlockUncheckedUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUncheckedUpdateOneWithoutSectionNestedInput
    educationItems?: EducationItemUncheckedUpdateManyWithoutSectionNestedInput
    skillItems?: SkillItemUncheckedUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUncheckedUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUncheckedUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUncheckedUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUncheckedUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type ExperienceDetailImageUpsertWithWhereUniqueWithoutExperienceItemInput = {
    where: ExperienceDetailImageWhereUniqueInput
    update: XOR<ExperienceDetailImageUpdateWithoutExperienceItemInput, ExperienceDetailImageUncheckedUpdateWithoutExperienceItemInput>
    create: XOR<ExperienceDetailImageCreateWithoutExperienceItemInput, ExperienceDetailImageUncheckedCreateWithoutExperienceItemInput>
  }

  export type ExperienceDetailImageUpdateWithWhereUniqueWithoutExperienceItemInput = {
    where: ExperienceDetailImageWhereUniqueInput
    data: XOR<ExperienceDetailImageUpdateWithoutExperienceItemInput, ExperienceDetailImageUncheckedUpdateWithoutExperienceItemInput>
  }

  export type ExperienceDetailImageUpdateManyWithWhereWithoutExperienceItemInput = {
    where: ExperienceDetailImageScalarWhereInput
    data: XOR<ExperienceDetailImageUpdateManyMutationInput, ExperienceDetailImageUncheckedUpdateManyWithoutExperienceItemInput>
  }

  export type ExperienceDetailImageScalarWhereInput = {
    AND?: ExperienceDetailImageScalarWhereInput | ExperienceDetailImageScalarWhereInput[]
    OR?: ExperienceDetailImageScalarWhereInput[]
    NOT?: ExperienceDetailImageScalarWhereInput | ExperienceDetailImageScalarWhereInput[]
    id?: StringFilter<"ExperienceDetailImage"> | string
    src?: StringFilter<"ExperienceDetailImage"> | string
    imagePublicId?: StringNullableFilter<"ExperienceDetailImage"> | string | null
    alt?: StringNullableFilter<"ExperienceDetailImage"> | string | null
    caption?: StringNullableFilter<"ExperienceDetailImage"> | string | null
    order?: IntFilter<"ExperienceDetailImage"> | number
    experienceItemId?: StringFilter<"ExperienceDetailImage"> | string
    createdAt?: DateTimeFilter<"ExperienceDetailImage"> | Date | string
  }

  export type ExperienceItemCreateWithoutDetailImagesInput = {
    id?: string
    positionTitle: string
    companyName: string
    period: string
    summary?: string | null
    description?: string | null
    imageSrc: string
    imagePublicId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    section: SectionCreateNestedOneWithoutExperienceItemsInput
  }

  export type ExperienceItemUncheckedCreateWithoutDetailImagesInput = {
    id?: string
    positionTitle: string
    companyName: string
    period: string
    summary?: string | null
    description?: string | null
    imageSrc: string
    imagePublicId?: string | null
    order?: number
    sectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExperienceItemCreateOrConnectWithoutDetailImagesInput = {
    where: ExperienceItemWhereUniqueInput
    create: XOR<ExperienceItemCreateWithoutDetailImagesInput, ExperienceItemUncheckedCreateWithoutDetailImagesInput>
  }

  export type ExperienceItemUpsertWithoutDetailImagesInput = {
    update: XOR<ExperienceItemUpdateWithoutDetailImagesInput, ExperienceItemUncheckedUpdateWithoutDetailImagesInput>
    create: XOR<ExperienceItemCreateWithoutDetailImagesInput, ExperienceItemUncheckedCreateWithoutDetailImagesInput>
    where?: ExperienceItemWhereInput
  }

  export type ExperienceItemUpdateToOneWithWhereWithoutDetailImagesInput = {
    where?: ExperienceItemWhereInput
    data: XOR<ExperienceItemUpdateWithoutDetailImagesInput, ExperienceItemUncheckedUpdateWithoutDetailImagesInput>
  }

  export type ExperienceItemUpdateWithoutDetailImagesInput = {
    positionTitle?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneRequiredWithoutExperienceItemsNestedInput
  }

  export type ExperienceItemUncheckedUpdateWithoutDetailImagesInput = {
    positionTitle?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    sectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionCreateWithoutProjectItemsInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockCreateNestedManyWithoutSectionInput
    imageBlocks?: ImageBlockCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentCreateNestedOneWithoutSectionInput
    educationItems?: EducationItemCreateNestedManyWithoutSectionInput
    skillItems?: SkillItemCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutProjectItemsInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockUncheckedCreateNestedManyWithoutSectionInput
    imageBlocks?: ImageBlockUncheckedCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentUncheckedCreateNestedOneWithoutSectionInput
    educationItems?: EducationItemUncheckedCreateNestedManyWithoutSectionInput
    skillItems?: SkillItemUncheckedCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageUncheckedCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemUncheckedCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemUncheckedCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemUncheckedCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutProjectItemsInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutProjectItemsInput, SectionUncheckedCreateWithoutProjectItemsInput>
  }

  export type SectionUpsertWithoutProjectItemsInput = {
    update: XOR<SectionUpdateWithoutProjectItemsInput, SectionUncheckedUpdateWithoutProjectItemsInput>
    create: XOR<SectionCreateWithoutProjectItemsInput, SectionUncheckedCreateWithoutProjectItemsInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutProjectItemsInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutProjectItemsInput, SectionUncheckedUpdateWithoutProjectItemsInput>
  }

  export type SectionUpdateWithoutProjectItemsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUpdateManyWithoutSectionNestedInput
    imageBlocks?: ImageBlockUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUpdateOneWithoutSectionNestedInput
    educationItems?: EducationItemUpdateManyWithoutSectionNestedInput
    skillItems?: SkillItemUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutProjectItemsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUncheckedUpdateManyWithoutSectionNestedInput
    imageBlocks?: ImageBlockUncheckedUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUncheckedUpdateOneWithoutSectionNestedInput
    educationItems?: EducationItemUncheckedUpdateManyWithoutSectionNestedInput
    skillItems?: SkillItemUncheckedUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUncheckedUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUncheckedUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUncheckedUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUncheckedUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionCreateWithoutTestimonialItemsInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockCreateNestedManyWithoutSectionInput
    imageBlocks?: ImageBlockCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentCreateNestedOneWithoutSectionInput
    educationItems?: EducationItemCreateNestedManyWithoutSectionInput
    skillItems?: SkillItemCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutTestimonialItemsInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockUncheckedCreateNestedManyWithoutSectionInput
    imageBlocks?: ImageBlockUncheckedCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentUncheckedCreateNestedOneWithoutSectionInput
    educationItems?: EducationItemUncheckedCreateNestedManyWithoutSectionInput
    skillItems?: SkillItemUncheckedCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageUncheckedCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemUncheckedCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemUncheckedCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemUncheckedCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutTestimonialItemsInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutTestimonialItemsInput, SectionUncheckedCreateWithoutTestimonialItemsInput>
  }

  export type SectionUpsertWithoutTestimonialItemsInput = {
    update: XOR<SectionUpdateWithoutTestimonialItemsInput, SectionUncheckedUpdateWithoutTestimonialItemsInput>
    create: XOR<SectionCreateWithoutTestimonialItemsInput, SectionUncheckedCreateWithoutTestimonialItemsInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutTestimonialItemsInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutTestimonialItemsInput, SectionUncheckedUpdateWithoutTestimonialItemsInput>
  }

  export type SectionUpdateWithoutTestimonialItemsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUpdateManyWithoutSectionNestedInput
    imageBlocks?: ImageBlockUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUpdateOneWithoutSectionNestedInput
    educationItems?: EducationItemUpdateManyWithoutSectionNestedInput
    skillItems?: SkillItemUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutTestimonialItemsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUncheckedUpdateManyWithoutSectionNestedInput
    imageBlocks?: ImageBlockUncheckedUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUncheckedUpdateOneWithoutSectionNestedInput
    educationItems?: EducationItemUncheckedUpdateManyWithoutSectionNestedInput
    skillItems?: SkillItemUncheckedUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUncheckedUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUncheckedUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUncheckedUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUncheckedUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionCreateWithoutContactInfoItemsInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockCreateNestedManyWithoutSectionInput
    imageBlocks?: ImageBlockCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentCreateNestedOneWithoutSectionInput
    educationItems?: EducationItemCreateNestedManyWithoutSectionInput
    skillItems?: SkillItemCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutContactInfoItemsInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockUncheckedCreateNestedManyWithoutSectionInput
    imageBlocks?: ImageBlockUncheckedCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentUncheckedCreateNestedOneWithoutSectionInput
    educationItems?: EducationItemUncheckedCreateNestedManyWithoutSectionInput
    skillItems?: SkillItemUncheckedCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageUncheckedCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemUncheckedCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemUncheckedCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemUncheckedCreateNestedManyWithoutSectionInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutContactInfoItemsInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutContactInfoItemsInput, SectionUncheckedCreateWithoutContactInfoItemsInput>
  }

  export type SectionUpsertWithoutContactInfoItemsInput = {
    update: XOR<SectionUpdateWithoutContactInfoItemsInput, SectionUncheckedUpdateWithoutContactInfoItemsInput>
    create: XOR<SectionCreateWithoutContactInfoItemsInput, SectionUncheckedCreateWithoutContactInfoItemsInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutContactInfoItemsInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutContactInfoItemsInput, SectionUncheckedUpdateWithoutContactInfoItemsInput>
  }

  export type SectionUpdateWithoutContactInfoItemsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUpdateManyWithoutSectionNestedInput
    imageBlocks?: ImageBlockUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUpdateOneWithoutSectionNestedInput
    educationItems?: EducationItemUpdateManyWithoutSectionNestedInput
    skillItems?: SkillItemUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutContactInfoItemsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUncheckedUpdateManyWithoutSectionNestedInput
    imageBlocks?: ImageBlockUncheckedUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUncheckedUpdateOneWithoutSectionNestedInput
    educationItems?: EducationItemUncheckedUpdateManyWithoutSectionNestedInput
    skillItems?: SkillItemUncheckedUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUncheckedUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUncheckedUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUncheckedUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUncheckedUpdateManyWithoutSectionNestedInput
    customSectionContentBlocks?: CustomSectionContentBlockUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionCreateWithoutCustomSectionContentBlocksInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockCreateNestedManyWithoutSectionInput
    imageBlocks?: ImageBlockCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentCreateNestedOneWithoutSectionInput
    educationItems?: EducationItemCreateNestedManyWithoutSectionInput
    skillItems?: SkillItemCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutCustomSectionContentBlocksInput = {
    id?: string
    slug: string
    title: string
    type: string
    visible?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    textBlocks?: TextBlockUncheckedCreateNestedManyWithoutSectionInput
    imageBlocks?: ImageBlockUncheckedCreateNestedManyWithoutSectionInput
    heroContent?: HeroSectionContentUncheckedCreateNestedOneWithoutSectionInput
    educationItems?: EducationItemUncheckedCreateNestedManyWithoutSectionInput
    skillItems?: SkillItemUncheckedCreateNestedManyWithoutSectionInput
    skillImages?: SkillImageUncheckedCreateNestedManyWithoutSectionInput
    experienceItems?: ExperienceItemUncheckedCreateNestedManyWithoutSectionInput
    projectItems?: ProjectItemUncheckedCreateNestedManyWithoutSectionInput
    testimonialItems?: TestimonialItemUncheckedCreateNestedManyWithoutSectionInput
    contactInfoItems?: ContactInfoItemUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutCustomSectionContentBlocksInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutCustomSectionContentBlocksInput, SectionUncheckedCreateWithoutCustomSectionContentBlocksInput>
  }

  export type SectionUpsertWithoutCustomSectionContentBlocksInput = {
    update: XOR<SectionUpdateWithoutCustomSectionContentBlocksInput, SectionUncheckedUpdateWithoutCustomSectionContentBlocksInput>
    create: XOR<SectionCreateWithoutCustomSectionContentBlocksInput, SectionUncheckedCreateWithoutCustomSectionContentBlocksInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutCustomSectionContentBlocksInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutCustomSectionContentBlocksInput, SectionUncheckedUpdateWithoutCustomSectionContentBlocksInput>
  }

  export type SectionUpdateWithoutCustomSectionContentBlocksInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUpdateManyWithoutSectionNestedInput
    imageBlocks?: ImageBlockUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUpdateOneWithoutSectionNestedInput
    educationItems?: EducationItemUpdateManyWithoutSectionNestedInput
    skillItems?: SkillItemUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutCustomSectionContentBlocksInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textBlocks?: TextBlockUncheckedUpdateManyWithoutSectionNestedInput
    imageBlocks?: ImageBlockUncheckedUpdateManyWithoutSectionNestedInput
    heroContent?: HeroSectionContentUncheckedUpdateOneWithoutSectionNestedInput
    educationItems?: EducationItemUncheckedUpdateManyWithoutSectionNestedInput
    skillItems?: SkillItemUncheckedUpdateManyWithoutSectionNestedInput
    skillImages?: SkillImageUncheckedUpdateManyWithoutSectionNestedInput
    experienceItems?: ExperienceItemUncheckedUpdateManyWithoutSectionNestedInput
    projectItems?: ProjectItemUncheckedUpdateManyWithoutSectionNestedInput
    testimonialItems?: TestimonialItemUncheckedUpdateManyWithoutSectionNestedInput
    contactInfoItems?: ContactInfoItemUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type TextBlockCreateManySectionInput = {
    id?: string
    content: string
    order?: number
    fontSize?: number | null
    fontFamily?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageBlockCreateManySectionInput = {
    id?: string
    src: string
    alt?: string | null
    caption?: string | null
    imagePublicId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EducationItemCreateManySectionInput = {
    id?: string
    institution: string
    degree?: string | null
    period: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillItemCreateManySectionInput = {
    id?: string
    title: string
    description?: string | null
    level?: number | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillImageCreateManySectionInput = {
    id?: string
    src: string
    imagePublicId?: string | null
    alt?: string | null
    caption?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type ExperienceItemCreateManySectionInput = {
    id?: string
    positionTitle: string
    companyName: string
    period: string
    summary?: string | null
    description?: string | null
    imageSrc: string
    imagePublicId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectItemCreateManySectionInput = {
    id?: string
    projectNumber?: string | null
    title: string
    companyName?: string | null
    description1: string
    description2?: string | null
    imageSrc: string
    imagePublicId?: string | null
    liveLink?: string | null
    sourceLink?: string | null
    layout?: string
    order?: number
    categoryIds?: ProjectItemCreatecategoryIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialItemCreateManySectionInput = {
    id?: string
    clientName: string
    role?: string | null
    company?: string | null
    content: string
    rating: number
    imageSrc?: string | null
    imagePublicId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactInfoItemCreateManySectionInput = {
    id?: string
    type: string
    value: string
    label?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomSectionContentBlockCreateManySectionInput = {
    id?: string
    type: string
    content?: string | null
    imageSrc?: string | null
    imageAlt?: string | null
    linkUrl?: string | null
    imagePublicId?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TextBlockUpdateWithoutSectionInput = {
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    fontSize?: NullableIntFieldUpdateOperationsInput | number | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextBlockUncheckedUpdateWithoutSectionInput = {
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    fontSize?: NullableIntFieldUpdateOperationsInput | number | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextBlockUncheckedUpdateManyWithoutSectionInput = {
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    fontSize?: NullableIntFieldUpdateOperationsInput | number | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageBlockUpdateWithoutSectionInput = {
    src?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageBlockUncheckedUpdateWithoutSectionInput = {
    src?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageBlockUncheckedUpdateManyWithoutSectionInput = {
    src?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationItemUpdateWithoutSectionInput = {
    institution?: StringFieldUpdateOperationsInput | string
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: EducationImageUpdateManyWithoutEducationItemNestedInput
  }

  export type EducationItemUncheckedUpdateWithoutSectionInput = {
    institution?: StringFieldUpdateOperationsInput | string
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: EducationImageUncheckedUpdateManyWithoutEducationItemNestedInput
  }

  export type EducationItemUncheckedUpdateManyWithoutSectionInput = {
    institution?: StringFieldUpdateOperationsInput | string
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    period?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillItemUpdateWithoutSectionInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillItemUncheckedUpdateWithoutSectionInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillItemUncheckedUpdateManyWithoutSectionInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillImageUpdateWithoutSectionInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillImageUncheckedUpdateWithoutSectionInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillImageUncheckedUpdateManyWithoutSectionInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperienceItemUpdateWithoutSectionInput = {
    positionTitle?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailImages?: ExperienceDetailImageUpdateManyWithoutExperienceItemNestedInput
  }

  export type ExperienceItemUncheckedUpdateWithoutSectionInput = {
    positionTitle?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailImages?: ExperienceDetailImageUncheckedUpdateManyWithoutExperienceItemNestedInput
  }

  export type ExperienceItemUncheckedUpdateManyWithoutSectionInput = {
    positionTitle?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectItemUpdateWithoutSectionInput = {
    projectNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    description1?: StringFieldUpdateOperationsInput | string
    description2?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    liveLink?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    layout?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    categoryIds?: ProjectItemUpdatecategoryIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectItemUncheckedUpdateWithoutSectionInput = {
    projectNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    description1?: StringFieldUpdateOperationsInput | string
    description2?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    liveLink?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    layout?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    categoryIds?: ProjectItemUpdatecategoryIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectItemUncheckedUpdateManyWithoutSectionInput = {
    projectNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    description1?: StringFieldUpdateOperationsInput | string
    description2?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    liveLink?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    layout?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    categoryIds?: ProjectItemUpdatecategoryIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialItemUpdateWithoutSectionInput = {
    clientName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialItemUncheckedUpdateWithoutSectionInput = {
    clientName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialItemUncheckedUpdateManyWithoutSectionInput = {
    clientName?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInfoItemUpdateWithoutSectionInput = {
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInfoItemUncheckedUpdateWithoutSectionInput = {
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInfoItemUncheckedUpdateManyWithoutSectionInput = {
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomSectionContentBlockUpdateWithoutSectionInput = {
    type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomSectionContentBlockUncheckedUpdateWithoutSectionInput = {
    type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomSectionContentBlockUncheckedUpdateManyWithoutSectionInput = {
    type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationImageCreateManyEducationItemInput = {
    id?: string
    src: string
    imagePublicId?: string | null
    alt?: string | null
    caption?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type EducationImageUpdateWithoutEducationItemInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationImageUncheckedUpdateWithoutEducationItemInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationImageUncheckedUpdateManyWithoutEducationItemInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperienceDetailImageCreateManyExperienceItemInput = {
    id?: string
    src: string
    imagePublicId?: string | null
    alt?: string | null
    caption?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type ExperienceDetailImageUpdateWithoutExperienceItemInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperienceDetailImageUncheckedUpdateWithoutExperienceItemInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperienceDetailImageUncheckedUpdateManyWithoutExperienceItemInput = {
    src?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}